<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Milkii0的秘密花园 • Posts by &#34;codeql&#34; category</title>
        <link>http://example.com</link>
        <description></description>
        <language>en</language>
        <pubDate>Fri, 10 Jun 2022 10:39:31 +0800</pubDate>
        <lastBuildDate>Fri, 10 Jun 2022 10:39:31 +0800</lastBuildDate>
        <category>web,HTTP</category>
        <category>redis,未授权,漏洞利用</category>
        <category>solr, 漏洞复现</category>
        <category>前后端分离</category>
        <category>文件上传靶场</category>
        <category>Java反序列化</category>
        <category>ysoserial调试</category>
        <category>木马,汇总</category>
        <category>pikachu,web靶场</category>
        <category>dorabox,靶场练习</category>
        <category>sql注入靶场</category>
        <category>webgoat</category>
        <category>solr, 代码审计</category>
        <category>CodeQL</category>
        <category>codeql, 搭建教程</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/06/10/CodeQLU-BootChallenge%20(CC++)/</guid>
            <title>CodeQLU-BootChallenge(CC++)</title>
            <link>http://example.com/2022/06/10/CodeQLU-BootChallenge%20(CC++)/</link>
            <category>CodeQL</category>
            <pubDate>Fri, 10 Jun 2022 10:39:31 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&#34;背景&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#背景&#34;&gt;#&lt;/a&gt; 背景&lt;/h1&gt;
&lt;p&gt;需要在 U-Boot 中寻找一组 9 个远程代码执行漏洞&lt;br&gt;
漏洞点位于 memcpy 函数&lt;br&gt;
但并非所有调用 memcpy 函数的都存在漏洞&lt;br&gt;
所以我们需要减少误报率，找到真正存在漏洞的 memcpy 调用&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://lab.github.com/githubtraining/codeql-u-boot-challenge-(cc++)&#34;&gt;放上题目链接&lt;/a&gt;&lt;br&gt;
关于环境搭建根据题目提示就可以顺利完成哦&lt;br&gt;
也可以参考我的文章 &amp;quot;CodeQL for VSCode 搭建流程&amp;quot;&lt;br&gt;
 不出意外会放在我的&lt;a href=&#34;https://milkii0.github.io&#34;&gt;博客中&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-3-our-first-query&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-3-our-first-query&#34;&gt;#&lt;/a&gt; Step 3 - our first query&lt;/h1&gt;
&lt;p&gt;在项目中寻找所有名为’strlen’的函数&lt;br&gt;
语法类似于 sql 语句&lt;br&gt;
 &lt;code&gt;import cpp&lt;/code&gt; : 导入 c++ 规则库&lt;br&gt;
 &lt;code&gt;From Function f1&lt;/code&gt; : 声明一个 Function 类的变量为 f1&lt;br&gt;
 &lt;code&gt;where f1.getName() = &amp;quot;strlen&amp;quot;&lt;/code&gt; : Function.getName () 顾名思义用于获取此声明的名称，也就是名称和&amp;quot;strlen&amp;quot; 相等的声明会被挑选出来&lt;br&gt;
 &lt;code&gt;select f1,&amp;quot;a function named strlen&amp;quot;&lt;/code&gt; : select 后接要在 result 中展示的项目，用逗号分隔&lt;br&gt;
 3_function_definitions.ql&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Function f1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where f1.getName() = &amp;quot;strlen&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select f1,&amp;quot;a function named strlen&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;f67230350390011a65f16d340406022d.png&#34; alt=&#34;f67230350390011a65f16d340406022d.png&#34;&gt;&lt;br&gt;
 直接在 main 提交&lt;br&gt;
&lt;img src=&#34;b20d0a09af05b0e0b6f0889c8bd499fe.png&#34; alt=&#34;b20d0a09af05b0e0b6f0889c8bd499fe.png&#34;&gt;&lt;br&gt;
commit 中查看结果，通过&lt;br&gt;
&lt;img src=&#34;9c74098f2c390ad1f066fa3cd8fc6349.png&#34; alt=&#34;9c74098f2c390ad1f066fa3cd8fc6349.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-4-anatomy-of-a-query&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-4-anatomy-of-a-query&#34;&gt;#&lt;/a&gt; Step 4 - Anatomy of a query&lt;/h1&gt;
&lt;p&gt;仿照上一步，在项目中寻找所有名为’memcpy’的函数&lt;br&gt;
 4_function_definitions.ql&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Function f&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where f.getName() = &amp;quot;memcpy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select f,&amp;quot;a function named memcpy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提交查看结果，通过&lt;br&gt;
&lt;img src=&#34;e7a2871ee72e24c0663d8b9042c8e434.png&#34; alt=&#34;e7a2871ee72e24c0663d8b9042c8e434.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-5-using-different-classes-and-their-predicates&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-5-using-different-classes-and-their-predicates&#34;&gt;#&lt;/a&gt; Step 5 - Using different classes and their predicates&lt;/h1&gt;
&lt;p&gt;自定义规则，查找三个名为 &lt;code&gt;ntohs&lt;/code&gt; ,  &lt;code&gt;ntohl&lt;/code&gt;  or  &lt;code&gt;ntohll&lt;/code&gt;  的宏定义&lt;br&gt;
需要一个紧凑的查询，而不是三个查找案例组合在一起&lt;br&gt;
给出以下两种方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用正则表达式&lt;br&gt;
 &lt;code&gt;string&lt;/code&gt;  类有一个方法 &lt;code&gt;regexpMatch&lt;/code&gt; ，接收器将参数与正则表达式匹配&lt;br&gt;
那我们需要先找到宏定义，再对该字符串进行正则匹配（使用的 java 的匹配模式）&lt;br&gt;
5_function_definitions.ql&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Macro m&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where m.getName().regexpMatch(&amp;quot;ntoh(s|l|ll)&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select m,&amp;quot;macros named ntohs, ntohl or ntohll&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行&lt;br&gt;
&lt;img src=&#34;dc5f776d88ef17d90e7be870a333f285.png&#34; alt=&#34;dc5f776d88ef17d90e7be870a333f285.png&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用集合表达式&lt;br&gt;
给出的格式：&amp;lt;your_variable_name&amp;gt; in [“bar”, “baz”, “quux”]&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Macro m&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where m.getName() in [&amp;quot;ntohs&amp;quot;,&amp;quot;ntohl&amp;quot;,&amp;quot;ntohll&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select m,&amp;quot;macros named ntohs, ntohl or ntohll&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行后和之前的结果相同，提交通过&lt;/p&gt;
&lt;p&gt;PS：&lt;br&gt;
上学的时候为了过考试自学的 c++，就是一些简单的语法&lt;br&gt;
看题目说明也没看明白 ntoh 族函数到底是个啥&lt;br&gt;
后来看见了&lt;a href=&#34;https://bestwing.me/codeql.html&#34;&gt; swing 的文章&lt;/a&gt;&lt;br&gt;
才知道 ntoh 族函数通常用来进行网络字节序到主机字节序的转换&lt;br&gt;
其实自己看到的时候就应该去查的，但是因为对题目影响不大就犯懒没去:-(&lt;br&gt;
以后不能这样了！看见没见过的看不懂的一定要去弄清楚&lt;/p&gt;
&lt;h1 id=&#34;step-6-relating-two-variables&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-6-relating-two-variables&#34;&gt;#&lt;/a&gt; Step 6 - Relating two variables&lt;/h1&gt;
&lt;p&gt;找到所有对 &lt;code&gt;memcpy&lt;/code&gt;  函数的调用&lt;br&gt;
先看看给的例子&lt;br&gt;
 &lt;code&gt;FunctionCall.getTarget()&lt;/code&gt;  查询该函数被调用的位置&lt;br&gt;
直接和 &lt;code&gt;Function&lt;/code&gt;  类型的 &lt;code&gt;fcn&lt;/code&gt;  对比值，说明他返回的值应该就是 &lt;code&gt;Function&lt;/code&gt;  类型（这点在下面优化中会用到）&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;Function.hasName()&lt;/code&gt;  获取方法名&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from FunctionCall call, Function fcn&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  call.getTarget() = fcn and&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  fcn.getDeclaringType().getSimpleName() = &amp;quot;map&amp;quot; and&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  fcn.getDeclaringType().getNamespace().getName() = &amp;quot;std&amp;quot; and&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  fcn.hasName(&amp;quot;find&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select call&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你想要省略中间变量 &lt;code&gt;Function&lt;/code&gt; ，使查询的更加紧凑，可以参考以下两个对比&lt;br&gt;
 &lt;code&gt;c1.getClass2()&lt;/code&gt;  返回的是 Class2 类型的值，因此可以直接调用 Class2 的方法&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;from Class1 c1, Class2 c2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  c1.getClass2() = c2 and&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  c2.getProp() = &amp;quot;something&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select c1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Class1 c1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where c1.getClass2().getProp() = &amp;quot;something&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select c1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根据以上案例思考&lt;br&gt;
我们需要找到 &lt;code&gt;memcpy&lt;/code&gt;  函数被调用的位置，可以使用&lt;br&gt;
 &lt;code&gt;FunctionCall.getTarget()&lt;/code&gt; &lt;br&gt;
 并希望查询更加紧凑，可以直接获取找到的函数的名称并进行判断&lt;br&gt;
 &lt;code&gt;FunctionCall.getTarget().getName=&amp;quot;memcpy&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;6_memcpy_calls.ql&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from FunctionCall functioncall&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where functioncall.getTarget().hasName(&amp;quot;memcpy&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select functioncall&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提交通过&lt;br&gt;
&lt;img src=&#34;40bdea82763f6ab88adaccc6e47931b4.png&#34; alt=&#34;40bdea82763f6ab88adaccc6e47931b4.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-7-relating-two-variables-continued&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-7-relating-two-variables-continued&#34;&gt;#&lt;/a&gt; Step 7 - Relating two variables, continued&lt;/h1&gt;
&lt;p&gt;寻找所有对 &lt;code&gt;ntoh*&lt;/code&gt;  宏定义的调用&lt;/p&gt;
&lt;p&gt;这里用到的是 &lt;code&gt;MacroInvocation&lt;/code&gt;  这个类，顾名思义就是宏定义调用的类&lt;br&gt;
鼠标悬浮看其注释也能看出来&lt;br&gt;
&lt;img src=&#34;69d9e0e24f06860213619664c0c91321.png&#34; alt=&#34;69d9e0e24f06860213619664c0c91321.png&#34;&gt;&lt;br&gt;
 那么我们就可以通过 &lt;code&gt;getMacro()&lt;/code&gt;  寻找被调用的宏定义，并得到返回的 &lt;code&gt;Macro&lt;/code&gt;  类型值&lt;br&gt;
再获得找到的 &lt;code&gt;Macro&lt;/code&gt;  名称进行正则匹配，即可获得我们想要的结果&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; from MacroInvocation macInvo&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; where macInvo.getMacro().getName().regexpMatch(&amp;quot;ntoh.*&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; select macInvo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（备注：关于正则表达式，不太会写，找的 java 正则 api 看的。&lt;br&gt;
 &lt;code&gt;.&lt;/code&gt;  表示匹配除换行符 \n 之外的任何单字符， &lt;code&gt;*&lt;/code&gt;  表示零次或多次，&lt;br&gt;
我这里希望得到的结果是以 &lt;code&gt;ntoh&lt;/code&gt;  开头的宏定义都会被选中。&lt;br&gt;
如果有不对的地方，还希望可以被提出指正◔ ‸◔）&lt;/p&gt;
&lt;p&gt;提交通过&lt;br&gt;
&lt;img src=&#34;5807d43f1ce8796d351638d6f55cde4a.png&#34; alt=&#34;5807d43f1ce8796d351638d6f55cde4a.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-8-changing-the-selected-output&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-8-changing-the-selected-output&#34;&gt;#&lt;/a&gt; Step 8 - Changing the selected output&lt;/h1&gt;
&lt;p&gt;根据提示，使用 &lt;code&gt;getExpr()&lt;/code&gt;  这个 predicate&lt;br&gt;
 先看看这个 &lt;code&gt;getExpr()&lt;/code&gt;  的注释说明&lt;br&gt;
是用来获取宏定义表达式的&lt;br&gt;
如果顶级拓展元素不是表达式，它只是一条语句，将不会被选中列为结果&lt;br&gt;
&lt;img src=&#34;09d6ad29dcccc9157677864a39460e27.png&#34; alt=&#34;09d6ad29dcccc9157677864a39460e27.png&#34;&gt;&lt;br&gt;
 使用 &lt;code&gt;select macInvo.getExpr()&lt;/code&gt; ，就能获得宏定义调用相关的表达式&lt;br&gt;
 8_macro_expressions.ql&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; from MacroInvocation macInvo&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; where macInvo.getMacro().getName().regexpMatch(&amp;quot;ntoh.*&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; select macInvo.getExpr()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如点击其中一个结果，就会跳转至下图位置&lt;br&gt;
&lt;img src=&#34;82697e23ad6a1cd05073bea662213bf8.png&#34; alt=&#34;82697e23ad6a1cd05073bea662213bf8.png&#34;&gt;&lt;br&gt;
 提交通过&lt;br&gt;
&lt;img src=&#34;839b8030c2474b52816e9afc1212d9a1.png&#34; alt=&#34;839b8030c2474b52816e9afc1212d9a1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么查询表达式和查询调用的区别是啥？&lt;br&gt;
看注释说明，&lt;br&gt;
 &lt;code&gt;getExpr()&lt;/code&gt; ：&lt;br&gt;
&lt;em&gt;Gets a top-level expression associated with this macro invocation,if any.&lt;br&gt;
Note that this predicate will fail if the top-level expanded element is not an expression (for example if it is a statement).&lt;br&gt;
This macro is intended to be used with macros that expand to a complete expression.&lt;br&gt;
In other cases, it may have multiple results or no results.&lt;/em&gt;&lt;br&gt;
 获取关于宏调用的顶级表达式&lt;br&gt;
注意，如果顶级扩展元素不是一个表达式的话查询将失败（例如，它是一个语句）&lt;br&gt;
此宏用于扩展为完整表达式的宏，在其他情况下可能会有多个结果或没有结果&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getMacro()&lt;/code&gt; ：&lt;br&gt;
&lt;em&gt;Gets the macro that is being accessed.&lt;/em&gt;&lt;br&gt;
 获取正在访问的宏&lt;/p&gt;
&lt;p&gt;即 &lt;code&gt;getMacro()&lt;/code&gt;  会获取所有调用的宏，即使他只是一个语句&lt;br&gt;
而 &lt;code&gt;getExpr()&lt;/code&gt;  只会获取宏调用的顶级表达式&lt;br&gt;
所以 &lt;code&gt;getExpr()&lt;/code&gt;  得到的结果集应该包含于 &lt;code&gt;getMacro()&lt;/code&gt;  的结果集&lt;br&gt;
这里放上&lt;a href=&#34;https://www.zhihu.com/question/20750344&#34;&gt;语句和表达式的区别讨论链接&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-9-write-your-own-class&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-9-write-your-own-class&#34;&gt;#&lt;/a&gt; Step 9 - Write your own class&lt;/h1&gt;
&lt;p&gt;首先看看学习 &lt;code&gt;exists&lt;/code&gt;  关键词给出的例子：&lt;br&gt;
这个规则只是为了获取不秃头的所有人&lt;/p&gt;
&lt;p&gt;不秃头的人都会有头发，那么他们的头发都会对应一个或多个颜色&lt;br&gt;
其中 &lt;code&gt;t.getHairColor()&lt;/code&gt;  会返回一个 &lt;code&gt;string&lt;/code&gt;  类型的值，例如 &amp;quot;red&amp;quot;&lt;br&gt;
 如果我们需要获得不秃头的人，我们并不需要知道他们头发的具体颜色，只需要知道 &lt;code&gt;t.getHairColor()&lt;/code&gt;  会返回 &lt;code&gt;string&lt;/code&gt;  类型的值即可，因为秃头 &lt;code&gt;getHairColor()&lt;/code&gt;  时，不会返回任何值&lt;/p&gt;
&lt;p&gt;所以我们利用 &lt;code&gt;string&lt;/code&gt;  类型的变量完成该操作&lt;br&gt;
更好的方式是使用 &lt;code&gt;exists&lt;/code&gt;  关键词，因为我们只是在 &lt;code&gt;where&lt;/code&gt;  中使用该变量&lt;br&gt;
例如， &lt;code&gt;exists(string c | t.getHairColor() = c)&lt;/code&gt;  使用了 string 类型的临时变量，用于获取 &lt;code&gt;t.getHairColor()&lt;/code&gt;  返回了 &lt;code&gt;string&lt;/code&gt;  值的 &lt;code&gt;t&lt;/code&gt; ，也就是查询了所有头发颜色的值为 &lt;code&gt;string&lt;/code&gt;  类型的人&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;from Person t&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where exists(string c | t.getHairColor() = c)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select t&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;/*在CodeQL中，以下代码功能同于以上代码，给出只是为了更好地理解*/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Person t, string c&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where t.getHairColor() = c&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select t&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再来看看类定义中给出的案例&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;class OneTwoThree extends int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  OneTwoThree() &amp;#123; // characteristic predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    this = 1 or this = 2 or this = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  string getAString() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    result = &amp;quot;One, two or three: &amp;quot; + this.toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  predicate isEven() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    this = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码定义了一个名为 &lt;code&gt;OneTwoThree&lt;/code&gt;  的类，继承于 int&lt;br&gt;
 类似于构造函数的部分是 &lt;code&gt;this = 1 or this = 2 or this = 3&lt;/code&gt; &lt;br&gt;
 文档中解释说明这个类中包括了 1,2,3 这三个值&lt;br&gt;
运行以下规则，可以发现 ott 中确实有 1，2，3 这三个值&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; /*from MacroInvocation macInvo&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; where macInvo.getMacro().getName().regexpMatch(&amp;quot;ntoh.*&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; select macInvo.getExpr()*/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; class OneTwoThree extends int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    OneTwoThree() &amp;#123; // characteristic predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      this = 1 or this = 2 or 3=this&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    string getAString() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      result = &amp;quot;One, two or three: &amp;quot; + this.toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    predicate isEven() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      this = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  from OneTwoThree ott&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  select ott&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;e4a0cc58f70e7e930a95949605394de8.png&#34; alt=&#34;e4a0cc58f70e7e930a95949605394de8.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中还有一个熟悉的单词 &lt;code&gt;predicate&lt;/code&gt; &lt;br&gt;
 这个是在类的主体内定义的谓词，是使用变量来限制类中可能的值的逻辑属性&lt;br&gt;
举个例子，运行以下规则，就会得到值 2&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;class OneTwoThree extends int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   OneTwoThree() &amp;#123; // characteristic predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     this = 1 or this = 2 or 3=this&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   string getAString() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     result = &amp;quot;One, two or three: &amp;quot; + this.toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   predicate isEven() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     this = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; from OneTwoThree ott&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; where ott.isEven()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; select ott&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行截图：&lt;br&gt;
&lt;img src=&#34;b7da8682bac3c07ef7a2d8d41cffc090.png&#34; alt=&#34;b7da8682bac3c07ef7a2d8d41cffc090.png&#34;&gt;&lt;br&gt;
 再更改规则如下：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;class OneTwoThree extends int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   OneTwoThree() &amp;#123; // characteristic predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     this = 1 or this = 2 or 3=this&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   string getAString() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     result = &amp;quot;One, two or three: &amp;quot; + this.toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   predicate isEven() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     this = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; from OneTwoThree ott&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; where ott = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; select ott&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;他们会得到相同的结果&lt;br&gt;
&lt;img src=&#34;c4bff2b9bd1c95c4becc00965b3a52f4.png&#34; alt=&#34;c4bff2b9bd1c95c4becc00965b3a52f4.png&#34;&gt;&lt;br&gt;
 也就是说 &lt;code&gt;where ott.isEven()&lt;/code&gt;  和 &lt;code&gt;where ott = 2&lt;/code&gt;  做出的是相同的限制&lt;br&gt;
那么我们也就能更好地理解， &lt;code&gt;predicate&lt;/code&gt;  特征是用于限制类中可能值的逻辑属性了&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;string getAString()&lt;/code&gt;  就不必多说，返回一个字符串，其中包含对应值&lt;br&gt;
&lt;img src=&#34;1da4e1a23a80b04ee390a564d069fc2e.png&#34; alt=&#34;1da4e1a23a80b04ee390a564d069fc2e.png&#34;&gt;&lt;br&gt;
 其中我发现一个很神奇事，不知该如何解释&lt;br&gt;
我将代码中 &lt;code&gt;this=1&lt;/code&gt;  改成 &lt;code&gt;1=this&lt;/code&gt;  也会得到一样的结果，没有任何不同或报错&lt;br&gt;
它和赋值语句不同，但好像又具有相似的功能&lt;br&gt;
在对变量做限制时，例如 &lt;code&gt;where ott = 2&lt;/code&gt; ，它就变成了一个符号，用于对两个值进行比较，这里还好理解，因为 sql 语法类似&lt;br&gt;
但是同样在以下代码中&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;predicate isEven() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     this = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;this=2&lt;/code&gt;  也是用于对两个值进行比较&lt;br&gt;
我认为这是由于 &lt;code&gt;predicate&lt;/code&gt;  带来的改变，使得其中的代码和 &lt;code&gt;where&lt;/code&gt;  后的代码具有相同得到功能&lt;br&gt;
如果有更好的见解，还不忘赐教&lt;/p&gt;
&lt;p&gt;最后来写题&lt;br&gt;
题目给了模板和提示&lt;br&gt;
按照 step8 中的规则进行编写， &lt;code&gt;exists&lt;/code&gt;  第二个参数放上 step8 中的 where 条件&lt;br&gt;
由于 select 由题目给出并为 Expr 的子类，所以我们需要增加一个条件获取宏调用相关表达式&lt;br&gt;
根据以上 &lt;code&gt;exists&lt;/code&gt;  案例可知，我们需要在 &lt;code&gt;mi.getExpr() =&lt;/code&gt;  后面写出他返回值的类型，这样当 &lt;code&gt;mi&lt;/code&gt;  为表达式时，就会被选中&lt;br&gt;
 &lt;code&gt;NetworkByteSwap&lt;/code&gt;  是 &lt;code&gt;Expr&lt;/code&gt;  的子类，因此&lt;/p&gt;
&lt;p&gt;9_class_network_byteswap.ql&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;class NetworkByteSwap extends Expr &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    NetworkByteSwap() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        exists(MacroInvocation mi | mi.getMacro().getName().regexpMatch(&amp;quot;ntoh.*&amp;quot;) | mi.getExpr() = this)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from NetworkByteSwap n&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select n, &amp;quot;Network byte swap&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&#34;step-10-data-flow-and-taint-tracking-analysis&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-10-data-flow-and-taint-tracking-analysis&#34;&gt;#&lt;/a&gt; Step 10 - Data flow and taint tracking analysis&lt;/h1&gt;
&lt;p&gt;最后一步，进行数据流分析&lt;/p&gt;
&lt;p&gt;先了解以下我们需要查询的函数背景， &lt;code&gt;ntoh*&lt;/code&gt;  函数会返回一个数，并用于 &lt;code&gt;memcpy&lt;/code&gt;  的第三个参数 &lt;code&gt;size&lt;/code&gt; ，所以我们需要追踪的数据流就是从 &lt;code&gt;ntoh*&lt;/code&gt;  到 &lt;code&gt;memcpy&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 C/C++ 写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。 这时就可能用到 htons (), ntohl (), ntohs ()，htons () 这 4 个网络字节顺序与本地字节顺序之间的转换函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;memcpy 指的是 c 和 c++ 使用的内存拷贝函数，memcpy 函数的功能是从源 src 所指的内存地址的起始位置开始拷贝 n 个字节到目标 dest 所指的内存地址的起始位置中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建 &lt;code&gt;Config&lt;/code&gt;  类，查找此类的数据流并进行污染点追踪分析&lt;br&gt;
进行数据流分析，我们需要用到，部分代码已经在给出的模板中&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import semmle.code.cpp.dataflow.TaintTracking&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;import DataFlow::PathGraph&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们需要写两个 &lt;code&gt;predicate&lt;/code&gt; ，一个是来源 &lt;code&gt;isSource&lt;/code&gt; ，一个是接收器 &lt;code&gt;isSink&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;isSource&lt;/code&gt;  中我们需要查询 &lt;code&gt;ntoh*&lt;/code&gt;  宏定义调用的相关表达式，这一步我们已经在 &lt;code&gt;NetworkByteSwap&lt;/code&gt;  中写过了&lt;br&gt;
 &lt;code&gt;isSink&lt;/code&gt;  中我们需要查询调用 &lt;code&gt;memcpy&lt;/code&gt;  函数时，传入的第三个参数 &lt;code&gt;size&lt;/code&gt; ，这一步我们需要新增加的步骤是获取参数&lt;/p&gt;
&lt;p&gt;弄清楚这些后，在编写规则时，根据提示完善代码&lt;br&gt;
我们就能获得 10_taint_tracking.ql 的答案&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; * @kind path-problem&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;import semmle.code.cpp.dataflow.TaintTracking&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;import DataFlow::PathGraph&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;class NetworkByteSwap extends Expr &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    NetworkByteSwap() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        exists(MacroInvocation mi| mi.getMacro().getName().regexpMatch(&amp;quot;ntoh(s|l|ll)&amp;quot;) | this = mi.getExpr())&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;class Config extends TaintTracking::Configuration &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  Config() &amp;#123; this = &amp;quot;NetworkToMemFuncLength&amp;quot; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  override predicate isSource(DataFlow::Node source) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // TODO&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    /*获取与此节点对应的表达式（如果有）。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    此谓词仅在表示表达式求值值的节点上具有结果。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    对于从表达式中流出的数据，例如通过引用传递参数时，请使用asDefiningArgument而不是asExpr。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    source.asExpr() instanceof NetworkByteSwap&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  override predicate isSink(DataFlow::Node sink) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // TODO&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    exists(FunctionCall fc | fc.getTarget().hasName(&amp;quot;memcpy&amp;quot;) | sink.asExpr() = fc.getArgument(2))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where cfg.hasFlowPath(source, sink)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select sink, source, sink, &amp;quot;Network byte swap flows to memcpy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&#34;传送门&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#传送门&#34;&gt;#&lt;/a&gt; 传送门&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://lgtm.com/help/lgtm/console/ql-cpp-basic-example&#34;&gt;cpp 规则语法说明&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html&#34;&gt; Java 正则模式&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://securitylab.github.com/research/cve-2018-4259-macos-nfs-vulnerability/&#34;&gt;给出的参考案例：CVE-2018-4259: MacOS NFS vulnerabilties lead to kernel RCE&lt;/a&gt;（知识点挺多的）&lt;br&gt;
&lt;a href=&#34;https://bestwing.me/codeql.html&#34;&gt;codeql-swing&lt;/a&gt;（swing 的语言云淡风轻，条理清晰，如沐春风，我的的语言阿巴阿巴阿巴）&lt;br&gt;
&lt;a href=&#34;https://github.com/github/securitylab/discussions&#34;&gt;讨论区&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/06/10/CodeQLforVSCode%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</guid>
            <title>CodeQLforVSCode搭建流程</title>
            <link>http://example.com/2022/06/10/CodeQLforVSCode%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</link>
            <category>codeql, 搭建教程</category>
            <pubDate>Fri, 10 Jun 2022 10:36:34 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&#34;visual-studio-code安装&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#visual-studio-code安装&#34;&gt;#&lt;/a&gt; Visual Studio Code 安装&lt;/h1&gt;
&lt;p&gt;都是免费的哈哈哈&lt;br&gt;
&lt;a href=&#34;https://code.visualstudio.com/Download&#34;&gt;官网下载&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;89f3979d3be08c5479bf1a9fac4ae8f4.png&#34; alt=&#34;89f3979d3be08c5479bf1a9fac4ae8f4.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;codeql安装&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#codeql安装&#34;&gt;#&lt;/a&gt; CodeQL 安装&lt;/h1&gt;
&lt;h2 id=&#34;使用chocolatey安装codeql-cli&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#使用chocolatey安装codeql-cli&#34;&gt;#&lt;/a&gt; 使用 Chocolatey 安装 CodeQL cli&lt;/h2&gt;
&lt;p&gt;使用 choco 安装可透过指令执行且环境变数也会自动设定好&lt;br&gt;
管理员权限打开 cmd&lt;br&gt;
 运行 &lt;code&gt;choco install codeql&lt;/code&gt; &lt;br&gt;
&lt;img src=&#34;8e97ed84bc39ad6f0c5ccda34d479d90.png&#34; alt=&#34;8e97ed84bc39ad6f0c5ccda34d479d90.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;安装成功&lt;br&gt;
&lt;img src=&#34;c79f98196394ebe90a752eb4bf512411.png&#34; alt=&#34;c79f98196394ebe90a752eb4bf512411.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果想要自定义安装目录的话，需要更改一下环境变量&lt;br&gt;
 ChocolateyInstall 就是默认的安装路径&lt;br&gt;
&lt;img src=&#34;03c3720b2dfed7a1702603e97ea56e19.png&#34; alt=&#34;03c3720b2dfed7a1702603e97ea56e19.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;gihub下载&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#gihub下载&#34;&gt;#&lt;/a&gt; gihub 下载&lt;/h2&gt;
&lt;p&gt;先下载 codeql-cli&lt;br&gt;
 选择对应操作系统下载即可&lt;br&gt;
&lt;img src=&#34;be05dbbd44da6e49e5a161a120478255.png&#34; alt=&#34;be05dbbd44da6e49e5a161a120478255.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/github/codeql-cli-binaries&#34;&gt;https://github.com/github/codeql-cli-binaries&lt;/a&gt;&lt;br&gt;
 下载好解压至自己选定的文件夹，再添加系统变量&lt;br&gt;
这里我将 codeql 文件夹名称改为 codeql-cli&lt;br&gt;
&lt;img src=&#34;cc76037dd0f7125ff2fa7ec3b2686824.png&#34; alt=&#34;cc76037dd0f7125ff2fa7ec3b2686824.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;在命令行输入 codeql，如下图即配置成功&lt;br&gt;
若提示找不到该命令，重启后再执行命令&lt;br&gt;
&lt;img src=&#34;f81317bf86bb5b8ece642a207391842b.png&#34; alt=&#34;f81317bf86bb5b8ece642a207391842b.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;下载 codeql 规则库（使用 starter workspace 可跳过此步骤）&lt;br&gt;
&lt;a href=&#34;https://github.com/github/codeql&#34;&gt;https://github.com/github/codeql&lt;/a&gt;&lt;br&gt;
 在 codeql 文件夹下打开 cmd&lt;br&gt;
 执行 &lt;code&gt;git clone https://github.com/github/codeql codeql-repo&lt;/code&gt; &lt;br&gt;
 下载完后如图&lt;br&gt;
&lt;img src=&#34;3aeebb3aca934f76ef649ccf7d200fb6.png&#34; alt=&#34;3aeebb3aca934f76ef649ccf7d200fb6.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;下载之后安装codeql插件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#下载之后安装codeql插件&#34;&gt;#&lt;/a&gt; 下载之后安装 codeql 插件&lt;/h1&gt;
&lt;p&gt;有三种方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 VS 插件中搜索 codeql 点击安装&lt;br&gt;
&lt;img src=&#34;9536c545af16d13d030ff3c42f767471.png&#34; alt=&#34;9536c545af16d13d030ff3c42f767471.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器打开&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql&#34;&gt;商城&lt;/a&gt;下载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;github 中下载&lt;a href=&#34;https://github.com/github/vscode-codeql/releases&#34;&gt; VSIX 文件&lt;/a&gt;&lt;br&gt;
在 more actions 中选择从 VSIX 文件安装&lt;br&gt;
&lt;img src=&#34;c748a4d35418471f99408284979433eb.png&#34; alt=&#34;c748a4d35418471f99408284979433eb.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;配置codeql-cli&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#配置codeql-cli&#34;&gt;#&lt;/a&gt; 配置 codeql-cli&lt;/h1&gt;
&lt;p&gt;终端无法访问扩展管理的 cli&lt;br&gt;
 可以自己下载 codeql, 并在插件中配置路径&lt;br&gt;
这样终端可以访问&lt;br&gt;
这个插件是使用 codeql-cli 编译并运行规则的，要确保下载的版本支持该插件即可&lt;br&gt;
&lt;img src=&#34;64d75944e23735a29f128c932e7824b7.png&#34; alt=&#34;64d75944e23735a29f128c932e7824b7.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Executable Path 输入 codeql.exe 所在路径&lt;br&gt;
&lt;img src=&#34;9ab953a7697bf20458868981a2523a3c.png&#34; alt=&#34;9ab953a7697bf20458868981a2523a3c.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;配置规则&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#配置规则&#34;&gt;#&lt;/a&gt; 配置规则&lt;/h1&gt;
&lt;p&gt;两种方法建立 codeql workspace&lt;br&gt;
 第一种就是把要审计的代码放入 codeql 中&lt;br&gt;
第二种是把 codeql 加入要审计的代码的 workspace 中&lt;/p&gt;
&lt;h2 id=&#34;使用starter-workspace也就是git仓库&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#使用starter-workspace也就是git仓库&#34;&gt;#&lt;/a&gt; 使用‘starter workspace’，也就是 git 仓库&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载 starter&lt;br&gt;
 &lt;code&gt;git clone --recursive https://github.com/github/vscode-codeql-starter/&lt;/code&gt; &lt;br&gt;
 或者&lt;br&gt;
 &lt;code&gt;git clone https://github.com/github/vscode-codeql-starter/&lt;/code&gt; &lt;br&gt;
 项目下载完成后，进入项目目录&lt;br&gt;
 &lt;code&gt;git submodule update --init &lt;/code&gt; &lt;br&gt;
 &lt;code&gt;git submodule update --remote&lt;/code&gt; &lt;br&gt;
 确保包含需要的子模块&lt;br&gt;
截图使用的是第一种方法&lt;br&gt;
&lt;img src=&#34;:/c7bf21f2a552483780c58a4ee06b70a0&#34; alt=&#34;479934456f6c44228c2f3e8057ac0e86.png&#34;&gt;&lt;br&gt;
 子模块需要定期更新&lt;br&gt;
&lt;img src=&#34;:/3c8180aaa0b040ecaafd4217cbc18503&#34; alt=&#34;ef88b51020a9d4ed8fdb5bda8029fc94.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 VS Code 中打开 starter workspace&lt;br&gt;
&lt;img src=&#34;:/29486ddc144542318d779b859916c3fb&#34; alt=&#34;84a6738a5e83ddeb45752d064e986647.png&#34;&gt;&lt;br&gt;
&lt;img src=&#34;:/b02d0248007c458a8554fcc54a7d04ea&#34; alt=&#34;4e682ce5e87fbc0dd1897081928067fd.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：&lt;br&gt;
starter 子模块中包括 C/C++, C#, Java, JavaScript, Python, Ruby 以及 GO 的规则，在 vscode-codeql-starter\ql 下&lt;br&gt;
 CodeQL 暂时无法扫描 php 代码&lt;/p&gt;
&lt;h2 id=&#34;将codeql规则库加入现有的工作站&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#将codeql规则库加入现有的工作站&#34;&gt;#&lt;/a&gt; 将 CodeQL 规则库加入现有的工作站&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;此种方法未实现，仅按文档进行流程说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将下载好的本地 CodeQL 库加入你的 workspace&lt;br&gt;
&lt;a href=&#34;https://github.com/github/codeql&#34;&gt;CodeQL 库下载链接&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择 File &amp;gt; Add Folder to Workspace，加入下载好的 codeql 库&lt;br&gt;
&lt;img src=&#34;:/97e2d507bde8497d9d9d5c54a79c7da3&#34; alt=&#34;3ccc9692c80a5e50bf93123ffbf04e4c.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每种语言都要创建一个新的文件夹&lt;br&gt;
通过 New Folder 或者 Add Folder to Workspace 选项&lt;br&gt;
放置你的自定义规则和规则库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在每个语言目录下新建一个 qlpack.yml 文件&lt;br&gt;
用来告诉 CodeQL，这个目录下的语言类型和依赖包&lt;br&gt;
例如：&lt;br&gt;
在 C&lt;ins&gt; 代码目录下自定义一个 CodeQL 文件夹名为’my-custom-cpp-pack’&lt;br&gt;
在 C&lt;/ins&gt; 代码目录下创建一个 qlpack.yml 文件，内容如下&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;name: my-custom-cpp-pack&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;version: 0.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;libraryPathDependencies: codeql/cpp-all&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;br&gt;
GO 语言的规则库并不在 github/codeql 中&lt;br&gt;
扫描 GO 代码，需要下载 https://github.com/github/codeql-go&lt;br&gt;
 然后将规则像上面说的这样加入规则库&lt;br&gt;
（starter 中都是包含的）&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;运行codeql&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#运行codeql&#34;&gt;#&lt;/a&gt; 运行 CodeQL&lt;/h1&gt;
&lt;h2 id=&#34;选择数据库&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#选择数据库&#34;&gt;#&lt;/a&gt; 选择数据库&lt;/h2&gt;
&lt;p&gt;扫描分析一个 project，我们需要建立一个 CodeQL 数据库&lt;br&gt;
在侧边栏打开 CodeQL 数据库&lt;br&gt;
如图有四种添加数据库的方法&lt;br&gt;
&lt;img src=&#34;b9557aadc5d02dcc220fc4f20977e102.png&#34; alt=&#34;b9557aadc5d02dcc220fc4f20977e102.png&#34;&gt;&lt;br&gt;
 当添加数据库之后，会有数据库视图&lt;br&gt;
可以右击列表中的项进行数据库交互&lt;br&gt;
可以利用 Ctrl/Cmd+click 选择多个数据库&lt;/p&gt;
&lt;h2 id=&#34;创建本地数据库&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建本地数据库&#34;&gt;#&lt;/a&gt; 创建本地数据库&lt;/h2&gt;
&lt;p&gt;如果没有存在的数据库导入，也可以先创建一个本地数据库&lt;br&gt;
有三种方法&lt;/p&gt;
&lt;h3 id=&#34;通过coedql-cli创建一个数据库&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#通过coedql-cli创建一个数据库&#34;&gt;#&lt;/a&gt; 通过 coedql-cli 创建一个数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;执行命令：
`codeql database create &amp;lt;database&amp;gt; --language=&amp;lt;language-identifier&amp;gt;`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;br&gt;
 &lt;code&gt;&amp;lt;database&amp;gt;&lt;/code&gt; ：创建数据库的路径，目录会在执行命令的时候被创建&lt;br&gt;
 &lt;code&gt;--language&lt;/code&gt; : 指定数据库语言，输入标识符。当和–db-cluster 一起使用时，可以指定多个，用’,&#39; 分隔，也可以进行多次指定。&lt;br&gt;
 &lt;code&gt;--db-cluster&lt;/code&gt; ：为多种语言创建数据库&lt;br&gt;
 &lt;code&gt;--command&lt;/code&gt; ：创建一个或多个编译语言数据库的时候使用。python 和 JavaScript/TypeScript 不需要该参数，如果编译语言不带该参数，codeql 会自动检测并编译&lt;br&gt;
 &lt;code&gt;--no-run-unnecessary-builds&lt;/code&gt; ：为多语言创建数据库，且包括编译和非编译语言时，可以利用  &lt;code&gt;--no-run-unnecessary-builds&lt;/code&gt;  来帮助非编译语言跳过 command 选项&lt;br&gt;
&lt;a href=&#34;https://codeql.github.com/docs/codeql-cli/manual/database-create/&#34;&gt;更多参数说明&lt;/a&gt;&lt;br&gt;
 CodeQL 支持以下语言&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语言&lt;/th&gt;
&lt;th&gt;标识符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C/C++&lt;/td&gt;
&lt;td&gt;cpp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C#&lt;/td&gt;
&lt;td&gt;csharp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GO&lt;/td&gt;
&lt;td&gt;go&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;java&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JavaScript/TypeScript&lt;/td&gt;
&lt;td&gt;javascript&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;python&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;ruby&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;找了 codeql-repo 中的 python 案列测试创建数据库成功&lt;br&gt;
&lt;img src=&#34;48af0641ac03eb15ee8781d860f9e724.png&#34; alt=&#34;48af0641ac03eb15ee8781d860f9e724.png&#34;&gt;&lt;br&gt;
&lt;img src=&#34;18db53f51f1f4c80cbae05e19d286cb4.png&#34; alt=&#34;18db53f51f1f4c80cbae05e19d286cb4.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;官方给出的command案例&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#官方给出的command案例&#34;&gt;#&lt;/a&gt; 官方给出的 command 案例&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Specifying build commands&lt;/p&gt;
&lt;p&gt;The following examples are designed to give you an idea of some of the build commands that you can specify for compiled languages.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Important&lt;/p&gt;
&lt;p&gt;The  &lt;code&gt;--command&lt;/code&gt;  option accepts a single argument—if you need to use more than one command, specify  &lt;code&gt;--command&lt;/code&gt;  multiple times.&lt;/p&gt;
&lt;p&gt;If you need to pass subcommands and options, the whole argument needs to be quoted to be interpreted correctly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;C/C++ project built using  &lt;code&gt;make&lt;/code&gt; :&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;codeql database create cpp-database --language=cpp --command=make&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C# project built using  &lt;code&gt;dotnet build&lt;/code&gt;  (.NET Core 3.0 or later):&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;codeql database create csharp-database --language=csharp --command=&amp;#x27;dotnet build /t:rebuild&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;On Linux and macOS (but not Windows), you need to disable shared compilation when building C# projects with .NET Core 2 or earlier, so expand the command to:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;codeql database create csharp-database --language=csharp --command=&amp;#x27;dotnet build /p:UseSharedCompilation=false /t:rebuild&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go project built using the  &lt;code&gt;COEQL_EXTRACTOR_GO_BUILD_TRACING=on&lt;/code&gt;  environment variable:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;CODEQL_EXTRACTOR_GO_BUILD_TRACING=on codeql database create go-database --language=go&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go project built using a custom build script:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;codeql database create go-database --language=go --command=&amp;#x27;./scripts/build.sh&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java project built using Gradle:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;codeql database create java-database --language=java --command=&amp;#x27;gradle clean test&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java project built using Maven:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;codeql database create java-database --language=java --command=&amp;#x27;mvn clean install&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java project built using Ant:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;codeql database create java-database --language=java --command=&amp;#x27;ant -f build.xml&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Project built using Bazel:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;# Navigate to the Bazel workspace.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# Before building, remove cached objects&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# and stop all running Bazel server processes.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;bazel clean --expunge&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# Build using the following Bazel flags, to help CodeQL detect the build:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# `--spawn_strategy=local`: build locally, instead of using a distributed build&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# `--nouse_action_cache`: turn off build caching, which might prevent recompilation of source code&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# `--noremote_accept_cached`, `--noremote_upload_local_results`: avoid using a remote cache&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;codeql database create new-database --language=&amp;lt;language&amp;gt; \&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  --command=&amp;#x27;bazel build --spawn_strategy=local --nouse_action_cache --noremote_accept_cached --noremote_upload_local_results //path/to/package:target&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# After building, stop all running Bazel server processes.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# This ensures future build commands start in a clean Bazel server process&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;# without CodeQL attached.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;bazel shutdown&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Project built using a custom build script:&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;codeql database create new-database --language=&amp;lt;language&amp;gt; --command=&amp;#x27;./scripts/build.sh&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;This command runs a custom script that contains all of the commands required to build the project.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;剩下两种方法未测试仅给出说明链接&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#剩下两种方法未测试仅给出说明链接&#34;&gt;#&lt;/a&gt; 剩下两种方法未测试，仅给出&lt;a href=&#34;https://codeql.github.com/docs/codeql-for-visual-studio-code/analyzing-your-projects/&#34;&gt;说明链接&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&#34;编写运行规则建议通过官方给出的练习题进行练习&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#编写运行规则建议通过官方给出的练习题进行练习&#34;&gt;#&lt;/a&gt; 编写运行规则，建议通过官方给出的练习题进行练习&lt;/h2&gt;
&lt;h1 id=&#34;传送门&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#传送门&#34;&gt;#&lt;/a&gt; 传送门&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://codeql.github.com/docs/&#34;&gt;CodeQL 官方文档&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://lab.github.com/githubtraining&#34;&gt;练习室&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
