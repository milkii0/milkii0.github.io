<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Milkii0的秘密花园 • Posts by &#34;codeql&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>en</language>
        <pubDate>Fri, 10 Jun 2022 10:39:31 +0800</pubDate>
        <lastBuildDate>Fri, 10 Jun 2022 10:39:31 +0800</lastBuildDate>
        <category>web,HTTP</category>
        <category>redis,未授权,漏洞利用</category>
        <category>solr, 漏洞复现</category>
        <category>前后端分离</category>
        <category>文件上传靶场</category>
        <category>Java反序列化</category>
        <category>ysoserial调试</category>
        <category>木马,汇总</category>
        <category>pikachu,web靶场</category>
        <category>dorabox,靶场练习</category>
        <category>sql注入靶场</category>
        <category>webgoat</category>
        <category>solr, 代码审计</category>
        <category>CodeQL</category>
        <category>codeql, 搭建教程</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/06/10/CodeQLU-BootChallenge%20(CC++)/</guid>
            <title>CodeQLU-BootChallenge(CC++)</title>
            <link>http://example.com/2022/06/10/CodeQLU-BootChallenge%20(CC++)/</link>
            <category>CodeQL</category>
            <pubDate>Fri, 10 Jun 2022 10:39:31 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&#34;背景&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#背景&#34;&gt;#&lt;/a&gt; 背景&lt;/h1&gt;
&lt;p&gt;需要在 U-Boot 中寻找一组 9 个远程代码执行漏洞&lt;br&gt;
漏洞点位于 memcpy 函数&lt;br&gt;
但并非所有调用 memcpy 函数的都存在漏洞&lt;br&gt;
所以我们需要减少误报率，找到真正存在漏洞的 memcpy 调用&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://lab.github.com/githubtraining/codeql-u-boot-challenge-(cc++)&#34;&gt;放上题目链接&lt;/a&gt;&lt;br&gt;
关于环境搭建根据题目提示就可以顺利完成哦&lt;br&gt;
也可以参考我的文章 &amp;quot;CodeQL for VSCode 搭建流程&amp;quot;&lt;br&gt;
 不出意外会放在我的&lt;a href=&#34;https://milkii0.github.io&#34;&gt;博客中&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-3-our-first-query&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-3-our-first-query&#34;&gt;#&lt;/a&gt; Step 3 - our first query&lt;/h1&gt;
&lt;p&gt;在项目中寻找所有名为’strlen’的函数&lt;br&gt;
语法类似于 sql 语句&lt;br&gt;
 &lt;code&gt;import cpp&lt;/code&gt; : 导入 c++ 规则库&lt;br&gt;
 &lt;code&gt;From Function f1&lt;/code&gt; : 声明一个 Function 类的变量为 f1&lt;br&gt;
 &lt;code&gt;where f1.getName() = &amp;quot;strlen&amp;quot;&lt;/code&gt; : Function.getName () 顾名思义用于获取此声明的名称，也就是名称和&amp;quot;strlen&amp;quot; 相等的声明会被挑选出来&lt;br&gt;
 &lt;code&gt;select f1,&amp;quot;a function named strlen&amp;quot;&lt;/code&gt; : select 后接要在 result 中展示的项目，用逗号分隔&lt;br&gt;
 3_function_definitions.ql&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Function f1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where f1.getName() = &amp;quot;strlen&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select f1,&amp;quot;a function named strlen&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;:/ffb04cb23fbe44299da44913566bd6fc&#34; alt=&#34;f67230350390011a65f16d340406022d.png&#34;&gt;&lt;br&gt;
 直接在 main 提交&lt;br&gt;
&lt;img src=&#34;:/03d383ef4092475cb06f7e451c2ee773&#34; alt=&#34;b20d0a09af05b0e0b6f0889c8bd499fe.png&#34;&gt;&lt;br&gt;
commit 中查看结果，通过&lt;br&gt;
&lt;img src=&#34;:/c4b375ab14c94f5fbdbbb698b1c8d60a&#34; alt=&#34;9c74098f2c390ad1f066fa3cd8fc6349.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-4-anatomy-of-a-query&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-4-anatomy-of-a-query&#34;&gt;#&lt;/a&gt; Step 4 - Anatomy of a query&lt;/h1&gt;
&lt;p&gt;仿照上一步，在项目中寻找所有名为’memcpy’的函数&lt;br&gt;
 4_function_definitions.ql&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Function f&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where f.getName() = &amp;quot;memcpy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select f,&amp;quot;a function named memcpy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提交查看结果，通过&lt;br&gt;
&lt;img src=&#34;:/1697f3993e7543c9ad834738c48da7b2&#34; alt=&#34;e7a2871ee72e24c0663d8b9042c8e434.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-5-using-different-classes-and-their-predicates&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-5-using-different-classes-and-their-predicates&#34;&gt;#&lt;/a&gt; Step 5 - Using different classes and their predicates&lt;/h1&gt;
&lt;p&gt;自定义规则，查找三个名为 &lt;code&gt;ntohs&lt;/code&gt; ,  &lt;code&gt;ntohl&lt;/code&gt;  or  &lt;code&gt;ntohll&lt;/code&gt;  的宏定义&lt;br&gt;
需要一个紧凑的查询，而不是三个查找案例组合在一起&lt;br&gt;
给出以下两种方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用正则表达式&lt;br&gt;
 &lt;code&gt;string&lt;/code&gt;  类有一个方法 &lt;code&gt;regexpMatch&lt;/code&gt; ，接收器将参数与正则表达式匹配&lt;br&gt;
那我们需要先找到宏定义，再对该字符串进行正则匹配（使用的 java 的匹配模式）&lt;br&gt;
5_function_definitions.ql&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Macro m&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where m.getName().regexpMatch(&amp;quot;ntoh(s|l|ll)&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select m,&amp;quot;macros named ntohs, ntohl or ntohll&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行&lt;br&gt;
&lt;img src=&#34;:/3a390210587349809d842a297621d813&#34; alt=&#34;dc5f776d88ef17d90e7be870a333f285.png&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用集合表达式&lt;br&gt;
给出的格式：&amp;lt;your_variable_name&amp;gt; in [“bar”, “baz”, “quux”]&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Macro m&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where m.getName() in [&amp;quot;ntohs&amp;quot;,&amp;quot;ntohl&amp;quot;,&amp;quot;ntohll&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select m,&amp;quot;macros named ntohs, ntohl or ntohll&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行后和之前的结果相同，提交通过&lt;/p&gt;
&lt;p&gt;PS：&lt;br&gt;
上学的时候为了过考试自学的 c++，就是一些简单的语法&lt;br&gt;
看题目说明也没看明白 ntoh 族函数到底是个啥&lt;br&gt;
后来看见了&lt;a href=&#34;https://bestwing.me/codeql.html&#34;&gt; swing 的文章&lt;/a&gt;&lt;br&gt;
才知道 ntoh 族函数通常用来进行网络字节序到主机字节序的转换&lt;br&gt;
其实自己看到的时候就应该去查的，但是因为对题目影响不大就犯懒没去:-(&lt;br&gt;
以后不能这样了！看见没见过的看不懂的一定要去弄清楚&lt;/p&gt;
&lt;h1 id=&#34;step-6-relating-two-variables&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-6-relating-two-variables&#34;&gt;#&lt;/a&gt; Step 6 - Relating two variables&lt;/h1&gt;
&lt;p&gt;找到所有对 &lt;code&gt;memcpy&lt;/code&gt;  函数的调用&lt;br&gt;
先看看给的例子&lt;br&gt;
 &lt;code&gt;FunctionCall.getTarget()&lt;/code&gt;  查询该函数被调用的位置&lt;br&gt;
直接和 &lt;code&gt;Function&lt;/code&gt;  类型的 &lt;code&gt;fcn&lt;/code&gt;  对比值，说明他返回的值应该就是 &lt;code&gt;Function&lt;/code&gt;  类型（这点在下面优化中会用到）&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;Function.hasName()&lt;/code&gt;  获取方法名&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from FunctionCall call, Function fcn&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  call.getTarget() = fcn and&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  fcn.getDeclaringType().getSimpleName() = &amp;quot;map&amp;quot; and&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  fcn.getDeclaringType().getNamespace().getName() = &amp;quot;std&amp;quot; and&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  fcn.hasName(&amp;quot;find&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select call&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你想要省略中间变量 &lt;code&gt;Function&lt;/code&gt; ，使查询的更加紧凑，可以参考以下两个对比&lt;br&gt;
 &lt;code&gt;c1.getClass2()&lt;/code&gt;  返回的是 Class2 类型的值，因此可以直接调用 Class2 的方法&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;from Class1 c1, Class2 c2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  c1.getClass2() = c2 and&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  c2.getProp() = &amp;quot;something&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select c1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Class1 c1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where c1.getClass2().getProp() = &amp;quot;something&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select c1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根据以上案例思考&lt;br&gt;
我们需要找到 &lt;code&gt;memcpy&lt;/code&gt;  函数被调用的位置，可以使用&lt;br&gt;
 &lt;code&gt;FunctionCall.getTarget()&lt;/code&gt; &lt;br&gt;
 并希望查询更加紧凑，可以直接获取找到的函数的名称并进行判断&lt;br&gt;
 &lt;code&gt;FunctionCall.getTarget().getName=&amp;quot;memcpy&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;6_memcpy_calls.ql&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from FunctionCall functioncall&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where functioncall.getTarget().hasName(&amp;quot;memcpy&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select functioncall&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提交通过&lt;br&gt;
&lt;img src=&#34;:/c09330aef79f45aeaad79c40da6356e6&#34; alt=&#34;40bdea82763f6ab88adaccc6e47931b4.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-7-relating-two-variables-continued&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-7-relating-two-variables-continued&#34;&gt;#&lt;/a&gt; Step 7 - Relating two variables, continued&lt;/h1&gt;
&lt;p&gt;寻找所有对 &lt;code&gt;ntoh*&lt;/code&gt;  宏定义的调用&lt;/p&gt;
&lt;p&gt;这里用到的是 &lt;code&gt;MacroInvocation&lt;/code&gt;  这个类，顾名思义就是宏定义调用的类&lt;br&gt;
鼠标悬浮看其注释也能看出来&lt;br&gt;
&lt;img src=&#34;:/41c8b2e4cca14540bc401075a4cad08f&#34; alt=&#34;69d9e0e24f06860213619664c0c91321.png&#34;&gt;&lt;br&gt;
 那么我们就可以通过 &lt;code&gt;getMacro()&lt;/code&gt;  寻找被调用的宏定义，并得到返回的 &lt;code&gt;Macro&lt;/code&gt;  类型值&lt;br&gt;
再获得找到的 &lt;code&gt;Macro&lt;/code&gt;  名称进行正则匹配，即可获得我们想要的结果&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; from MacroInvocation macInvo&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; where macInvo.getMacro().getName().regexpMatch(&amp;quot;ntoh.*&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; select macInvo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（备注：关于正则表达式，不太会写，找的 java 正则 api 看的。&lt;br&gt;
 &lt;code&gt;.&lt;/code&gt;  表示匹配除换行符 \n 之外的任何单字符， &lt;code&gt;*&lt;/code&gt;  表示零次或多次，&lt;br&gt;
我这里希望得到的结果是以 &lt;code&gt;ntoh&lt;/code&gt;  开头的宏定义都会被选中。&lt;br&gt;
如果有不对的地方，还希望可以被提出指正◔ ‸◔）&lt;/p&gt;
&lt;p&gt;提交通过&lt;br&gt;
&lt;img src=&#34;:/432f3ae4cae04cbcb5ab7186e6e221ba&#34; alt=&#34;5807d43f1ce8796d351638d6f55cde4a.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-8-changing-the-selected-output&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-8-changing-the-selected-output&#34;&gt;#&lt;/a&gt; Step 8 - Changing the selected output&lt;/h1&gt;
&lt;p&gt;根据提示，使用 &lt;code&gt;getExpr()&lt;/code&gt;  这个 predicate&lt;br&gt;
 先看看这个 &lt;code&gt;getExpr()&lt;/code&gt;  的注释说明&lt;br&gt;
是用来获取宏定义表达式的&lt;br&gt;
如果顶级拓展元素不是表达式，它只是一条语句，将不会被选中列为结果&lt;br&gt;
&lt;img src=&#34;:/d452b131a0f54fd1ae883812865eb77a&#34; alt=&#34;09d6ad29dcccc9157677864a39460e27.png&#34;&gt;&lt;br&gt;
 使用 &lt;code&gt;select macInvo.getExpr()&lt;/code&gt; ，就能获得宏定义调用相关的表达式&lt;br&gt;
 8_macro_expressions.ql&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; from MacroInvocation macInvo&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; where macInvo.getMacro().getName().regexpMatch(&amp;quot;ntoh.*&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; select macInvo.getExpr()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如点击其中一个结果，就会跳转至下图位置&lt;br&gt;
&lt;img src=&#34;:/57c7ff8deabb48a6b8ab9d2820bdcc81&#34; alt=&#34;82697e23ad6a1cd05073bea662213bf8.png&#34;&gt;&lt;br&gt;
 提交通过&lt;br&gt;
&lt;img src=&#34;:/18dc9a5714244fa5bb9c099a5d6a7a89&#34; alt=&#34;839b8030c2474b52816e9afc1212d9a1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么查询表达式和查询调用的区别是啥？&lt;br&gt;
看注释说明，&lt;br&gt;
 &lt;code&gt;getExpr()&lt;/code&gt; ：&lt;br&gt;
&lt;em&gt;Gets a top-level expression associated with this macro invocation,if any.&lt;br&gt;
Note that this predicate will fail if the top-level expanded element is not an expression (for example if it is a statement).&lt;br&gt;
This macro is intended to be used with macros that expand to a complete expression.&lt;br&gt;
In other cases, it may have multiple results or no results.&lt;/em&gt;&lt;br&gt;
 获取关于宏调用的顶级表达式&lt;br&gt;
注意，如果顶级扩展元素不是一个表达式的话查询将失败（例如，它是一个语句）&lt;br&gt;
此宏用于扩展为完整表达式的宏，在其他情况下可能会有多个结果或没有结果&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getMacro()&lt;/code&gt; ：&lt;br&gt;
&lt;em&gt;Gets the macro that is being accessed.&lt;/em&gt;&lt;br&gt;
 获取正在访问的宏&lt;/p&gt;
&lt;p&gt;即 &lt;code&gt;getMacro()&lt;/code&gt;  会获取所有调用的宏，即使他只是一个语句&lt;br&gt;
而 &lt;code&gt;getExpr()&lt;/code&gt;  只会获取宏调用的顶级表达式&lt;br&gt;
所以 &lt;code&gt;getExpr()&lt;/code&gt;  得到的结果集应该包含于 &lt;code&gt;getMacro()&lt;/code&gt;  的结果集&lt;br&gt;
这里放上&lt;a href=&#34;https://www.zhihu.com/question/20750344&#34;&gt;语句和表达式的区别讨论链接&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;step-9-write-your-own-class&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-9-write-your-own-class&#34;&gt;#&lt;/a&gt; Step 9 - Write your own class&lt;/h1&gt;
&lt;p&gt;首先看看学习 &lt;code&gt;exists&lt;/code&gt;  关键词给出的例子：&lt;br&gt;
这个规则只是为了获取不秃头的所有人&lt;/p&gt;
&lt;p&gt;不秃头的人都会有头发，那么他们的头发都会对应一个或多个颜色&lt;br&gt;
其中 &lt;code&gt;t.getHairColor()&lt;/code&gt;  会返回一个 &lt;code&gt;string&lt;/code&gt;  类型的值，例如 &amp;quot;red&amp;quot;&lt;br&gt;
 如果我们需要获得不秃头的人，我们并不需要知道他们头发的具体颜色，只需要知道 &lt;code&gt;t.getHairColor()&lt;/code&gt;  会返回 &lt;code&gt;string&lt;/code&gt;  类型的值即可，因为秃头 &lt;code&gt;getHairColor()&lt;/code&gt;  时，不会返回任何值&lt;/p&gt;
&lt;p&gt;所以我们利用 &lt;code&gt;string&lt;/code&gt;  类型的变量完成该操作&lt;br&gt;
更好的方式是使用 &lt;code&gt;exists&lt;/code&gt;  关键词，因为我们只是在 &lt;code&gt;where&lt;/code&gt;  中使用该变量&lt;br&gt;
例如， &lt;code&gt;exists(string c | t.getHairColor() = c)&lt;/code&gt;  使用了 string 类型的临时变量，用于获取 &lt;code&gt;t.getHairColor()&lt;/code&gt;  返回了 &lt;code&gt;string&lt;/code&gt;  值的 &lt;code&gt;t&lt;/code&gt; ，也就是查询了所有头发颜色的值为 &lt;code&gt;string&lt;/code&gt;  类型的人&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;from Person t&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where exists(string c | t.getHairColor() = c)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select t&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;/*在CodeQL中，以下代码功能同于以上代码，给出只是为了更好地理解*/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Person t, string c&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where t.getHairColor() = c&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select t&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再来看看类定义中给出的案例&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;class OneTwoThree extends int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  OneTwoThree() &amp;#123; // characteristic predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    this = 1 or this = 2 or this = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  string getAString() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    result = &amp;quot;One, two or three: &amp;quot; + this.toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  predicate isEven() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    this = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码定义了一个名为 &lt;code&gt;OneTwoThree&lt;/code&gt;  的类，继承于 int&lt;br&gt;
 类似于构造函数的部分是 &lt;code&gt;this = 1 or this = 2 or this = 3&lt;/code&gt; &lt;br&gt;
 文档中解释说明这个类中包括了 1,2,3 这三个值&lt;br&gt;
运行以下规则，可以发现 ott 中确实有 1，2，3 这三个值&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; /*from MacroInvocation macInvo&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; where macInvo.getMacro().getName().regexpMatch(&amp;quot;ntoh.*&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; select macInvo.getExpr()*/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; class OneTwoThree extends int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    OneTwoThree() &amp;#123; // characteristic predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      this = 1 or this = 2 or 3=this&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    string getAString() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      result = &amp;quot;One, two or three: &amp;quot; + this.toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    predicate isEven() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      this = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  from OneTwoThree ott&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  select ott&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;:/26038db25b254623bab7f404ae1457a2&#34; alt=&#34;e4a0cc58f70e7e930a95949605394de8.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中还有一个熟悉的单词 &lt;code&gt;predicate&lt;/code&gt; &lt;br&gt;
 这个是在类的主体内定义的谓词，是使用变量来限制类中可能的值的逻辑属性&lt;br&gt;
举个例子，运行以下规则，就会得到值 2&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;class OneTwoThree extends int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   OneTwoThree() &amp;#123; // characteristic predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     this = 1 or this = 2 or 3=this&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   string getAString() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     result = &amp;quot;One, two or three: &amp;quot; + this.toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   predicate isEven() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     this = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; from OneTwoThree ott&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; where ott.isEven()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; select ott&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行截图：&lt;br&gt;
&lt;img src=&#34;:/678d834def2441e69e01ad9a576c14ec&#34; alt=&#34;b7da8682bac3c07ef7a2d8d41cffc090.png&#34;&gt;&lt;br&gt;
 再更改规则如下：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;class OneTwoThree extends int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   OneTwoThree() &amp;#123; // characteristic predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     this = 1 or this = 2 or 3=this&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   string getAString() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     result = &amp;quot;One, two or three: &amp;quot; + this.toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   predicate isEven() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     this = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; from OneTwoThree ott&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; where ott = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; select ott&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;他们会得到相同的结果&lt;br&gt;
&lt;img src=&#34;:/02edf6f0dfec4f5b8139ff090d007385&#34; alt=&#34;c4bff2b9bd1c95c4becc00965b3a52f4.png&#34;&gt;&lt;br&gt;
 也就是说 &lt;code&gt;where ott.isEven()&lt;/code&gt;  和 &lt;code&gt;where ott = 2&lt;/code&gt;  做出的是相同的限制&lt;br&gt;
那么我们也就能更好地理解， &lt;code&gt;predicate&lt;/code&gt;  特征是用于限制类中可能值的逻辑属性了&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;string getAString()&lt;/code&gt;  就不必多说，返回一个字符串，其中包含对应值&lt;br&gt;
&lt;img src=&#34;:/6caa12562e92485698cad9abe38fd1df&#34; alt=&#34;1da4e1a23a80b04ee390a564d069fc2e.png&#34;&gt;&lt;br&gt;
 其中我发现一个很神奇事，不知该如何解释&lt;br&gt;
我将代码中 &lt;code&gt;this=1&lt;/code&gt;  改成 &lt;code&gt;1=this&lt;/code&gt;  也会得到一样的结果，没有任何不同或报错&lt;br&gt;
它和赋值语句不同，但好像又具有相似的功能&lt;br&gt;
在对变量做限制时，例如 &lt;code&gt;where ott = 2&lt;/code&gt; ，它就变成了一个符号，用于对两个值进行比较，这里还好理解，因为 sql 语法类似&lt;br&gt;
但是同样在以下代码中&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;predicate isEven() &amp;#123; // member predicate&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     this = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;this=2&lt;/code&gt;  也是用于对两个值进行比较&lt;br&gt;
我认为这是由于 &lt;code&gt;predicate&lt;/code&gt;  带来的改变，使得其中的代码和 &lt;code&gt;where&lt;/code&gt;  后的代码具有相同得到功能&lt;br&gt;
如果有更好的见解，还不忘赐教&lt;/p&gt;
&lt;p&gt;最后来写题&lt;br&gt;
题目给了模板和提示&lt;br&gt;
按照 step8 中的规则进行编写， &lt;code&gt;exists&lt;/code&gt;  第二个参数放上 step8 中的 where 条件&lt;br&gt;
由于 select 由题目给出并为 Expr 的子类，所以我们需要增加一个条件获取宏调用相关表达式&lt;br&gt;
根据以上 &lt;code&gt;exists&lt;/code&gt;  案例可知，我们需要在 &lt;code&gt;mi.getExpr() =&lt;/code&gt;  后面写出他返回值的类型，这样当 &lt;code&gt;mi&lt;/code&gt;  为表达式时，就会被选中&lt;br&gt;
 &lt;code&gt;NetworkByteSwap&lt;/code&gt;  是 &lt;code&gt;Expr&lt;/code&gt;  的子类，因此&lt;/p&gt;
&lt;p&gt;9_class_network_byteswap.ql&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;class NetworkByteSwap extends Expr &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    NetworkByteSwap() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        exists(MacroInvocation mi | mi.getMacro().getName().regexpMatch(&amp;quot;ntoh.*&amp;quot;) | mi.getExpr() = this)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from NetworkByteSwap n&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select n, &amp;quot;Network byte swap&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&#34;step-10-data-flow-and-taint-tracking-analysis&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#step-10-data-flow-and-taint-tracking-analysis&#34;&gt;#&lt;/a&gt; Step 10 - Data flow and taint tracking analysis&lt;/h1&gt;
&lt;p&gt;最后一步，进行数据流分析&lt;/p&gt;
&lt;p&gt;先了解以下我们需要查询的函数背景， &lt;code&gt;ntoh*&lt;/code&gt;  函数会返回一个数，并用于 &lt;code&gt;memcpy&lt;/code&gt;  的第三个参数 &lt;code&gt;size&lt;/code&gt; ，所以我们需要追踪的数据流就是从 &lt;code&gt;ntoh*&lt;/code&gt;  到 &lt;code&gt;memcpy&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 C/C++ 写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。 这时就可能用到 htons (), ntohl (), ntohs ()，htons () 这 4 个网络字节顺序与本地字节顺序之间的转换函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;memcpy 指的是 c 和 c++ 使用的内存拷贝函数，memcpy 函数的功能是从源 src 所指的内存地址的起始位置开始拷贝 n 个字节到目标 dest 所指的内存地址的起始位置中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建 &lt;code&gt;Config&lt;/code&gt;  类，查找此类的数据流并进行污染点追踪分析&lt;br&gt;
进行数据流分析，我们需要用到，部分代码已经在给出的模板中&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;import semmle.code.cpp.dataflow.TaintTracking&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;import DataFlow::PathGraph&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们需要写两个 &lt;code&gt;predicate&lt;/code&gt; ，一个是来源 &lt;code&gt;isSource&lt;/code&gt; ，一个是接收器 &lt;code&gt;isSink&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;isSource&lt;/code&gt;  中我们需要查询 &lt;code&gt;ntoh*&lt;/code&gt;  宏定义调用的相关表达式，这一步我们已经在 &lt;code&gt;NetworkByteSwap&lt;/code&gt;  中写过了&lt;br&gt;
 &lt;code&gt;isSink&lt;/code&gt;  中我们需要查询调用 &lt;code&gt;memcpy&lt;/code&gt;  函数时，传入的第三个参数 &lt;code&gt;size&lt;/code&gt; ，这一步我们需要新增加的步骤是获取参数&lt;/p&gt;
&lt;p&gt;弄清楚这些后，在编写规则时，根据提示完善代码&lt;br&gt;
我们就能获得 10_taint_tracking.ql 的答案&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; * @kind path-problem&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;import cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;import semmle.code.cpp.dataflow.TaintTracking&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;import DataFlow::PathGraph&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;class NetworkByteSwap extends Expr &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    NetworkByteSwap() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        exists(MacroInvocation mi| mi.getMacro().getName().regexpMatch(&amp;quot;ntoh(s|l|ll)&amp;quot;) | this = mi.getExpr())&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;class Config extends TaintTracking::Configuration &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  Config() &amp;#123; this = &amp;quot;NetworkToMemFuncLength&amp;quot; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  override predicate isSource(DataFlow::Node source) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // TODO&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    /*获取与此节点对应的表达式（如果有）。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    此谓词仅在表示表达式求值值的节点上具有结果。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    对于从表达式中流出的数据，例如通过引用传递参数时，请使用asDefiningArgument而不是asExpr。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    source.asExpr() instanceof NetworkByteSwap&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  override predicate isSink(DataFlow::Node sink) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    // TODO&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    exists(FunctionCall fc | fc.getTarget().hasName(&amp;quot;memcpy&amp;quot;) | sink.asExpr() = fc.getArgument(2))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;where cfg.hasFlowPath(source, sink)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;select sink, source, sink, &amp;quot;Network byte swap flows to memcpy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&#34;传送门&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#传送门&#34;&gt;#&lt;/a&gt; 传送门&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://lgtm.com/help/lgtm/console/ql-cpp-basic-example&#34;&gt;cpp 规则语法说明&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html&#34;&gt; Java 正则模式&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://securitylab.github.com/research/cve-2018-4259-macos-nfs-vulnerability/&#34;&gt;给出的参考案例：CVE-2018-4259: MacOS NFS vulnerabilties lead to kernel RCE&lt;/a&gt;（知识点挺多的）&lt;br&gt;
&lt;a href=&#34;https://bestwing.me/codeql.html&#34;&gt;codeql-swing&lt;/a&gt;（swing 的语言云淡风轻，条理清晰，如沐春风，我的的语言阿巴阿巴阿巴）&lt;br&gt;
&lt;a href=&#34;https://github.com/github/securitylab/discussions&#34;&gt;讨论区&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
