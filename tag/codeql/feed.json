{
    "version": "https://jsonfeed.org/version/1",
    "title": "Milkii0的秘密花园 • All posts by \"codeql\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/06/12/CodeQL%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/",
            "url": "http://example.com/2022/06/12/CodeQL%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/",
            "title": "CodeQL使用流程",
            "date_published": "2022-06-12T04:41:31.000Z",
            "content_html": "<p>[toc]</p>\n<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>好久没用 CodeQL 了，看了自己之前写的文章发现竟然没有做过相关记录<br>\n然后就不知道怎么用了 hhh</p>\n<h1 id=\"使用流程\"><a class=\"markdownIt-Anchor\" href=\"#使用流程\">#</a> 使用流程</h1>\n<h2 id=\"0x1-生成数据库\"><a class=\"markdownIt-Anchor\" href=\"#0x1-生成数据库\">#</a> 0x1 生成数据库</h2>\n<p>我们拿到一套源码，首先需要使用 CodeQL 生成数据库</p>\n<p>执行命令：<br>\n <code>codeql database create &lt;database&gt; --language=&lt;language-identifier&gt;</code> <br>\n 参数说明：<br>\n <code>&lt;database&gt;</code> ：创建数据库的路径，目录会在执行命令的时候被创建<br>\n <code>--language</code> : 指定数据库语言，输入标识符。当和–db-cluster 一起使用时，可以指定多个，用’,' 分隔，也可以进行多次指定。<br>\n <code>--db-cluster</code> ：为多种语言创建数据库<br>\n <code>--command</code> ：创建一个或多个编译语言数据库的时候使用。python 和 JavaScript/TypeScript 不需要该参数，如果编译语言不带该参数，codeql 会自动检测并编译<br>\n <code>--no-run-unnecessary-builds</code> ：为多语言创建数据库，且包括编译和非编译语言时，可以利用  <code>--no-run-unnecessary-builds</code>  来帮助非编译语言跳过 command 选项<br>\n<a href=\"https://codeql.github.com/docs/codeql-cli/manual/database-create/\">更多参数说明</a><br>\n CodeQL 支持以下语言</p>\n<table>\n<thead>\n<tr>\n<th>语言</th>\n<th>标识符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>C/C++</td>\n<td>cpp</td>\n</tr>\n<tr>\n<td>C#</td>\n<td>csharp</td>\n</tr>\n<tr>\n<td>GO</td>\n<td>go</td>\n</tr>\n<tr>\n<td>Java</td>\n<td>java</td>\n</tr>\n<tr>\n<td>JavaScript/TypeScript</td>\n<td>javascript</td>\n</tr>\n<tr>\n<td>Python</td>\n<td>python</td>\n</tr>\n<tr>\n<td>Ruby</td>\n<td>ruby</td>\n</tr>\n</tbody>\n</table>\n<p>案例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codeql database create xxx-database  --language=&quot;java&quot;  --command=&quot;mvn clean install --file pom.xml&quot; --source-root=文件目录</span><br></pre></td></tr></table></figure>\n<p><img src=\"962dcc2d739aeddc138604f43eabb6e8.png\" alt=\"962dcc2d739aeddc138604f43eabb6e8.png\"><br>\n 成功之后<br>\n<img src=\"0ce711b4c117dfc66b296a08b6c7b929.png\" alt=\"0ce711b4c117dfc66b296a08b6c7b929.png\"><br>\n 然后在当前目录下会生成一个名为 “xxx-database” 的文件夹</p>\n<h2 id=\"0x2导入codeql规则\"><a class=\"markdownIt-Anchor\" href=\"#0x2导入codeql规则\">#</a> 0x2 导入 codeql 规则</h2>\n<p>这里使用‘starter workspace’，也就是 git 仓库</p>\n<ol>\n<li>\n<p>下载 starter<br>\n <code>git clone --recursive https://github.com/github/vscode-codeql-starter/</code> <br>\n 或者<br>\n <code>git clone https://github.com/github/vscode-codeql-starter/</code> <br>\n 项目下载完成后，进入项目目录<br>\n <code>git submodule update --init </code> <br>\n <code>git submodule update --remote</code> <br>\n 确保包含需要的子模块<br>\n截图使用的是第一种方法<br>\n<img src=\"479934456f6c44228c2f3e8057ac0e86.png\" alt=\"479934456f6c44228c2f3e8057ac0e86.png\"><br>\n 子模块需要定期更新<br>\n<img src=\"ef88b51020a9d4ed8fdb5bda8029fc94.png\" alt=\"ef88b51020a9d4ed8fdb5bda8029fc94.png\"></p>\n</li>\n<li>\n<p>在 VS Code 中打开 starter workspace<br>\n<img src=\"84a6738a5e83ddeb45752d064e986647.png\" alt=\"84a6738a5e83ddeb45752d064e986647.png\"><br>\n<img src=\"4e682ce5e87fbc0dd1897081928067fd.png\" alt=\"4e682ce5e87fbc0dd1897081928067fd.png\"></p>\n</li>\n</ol>\n<p>注意：<br>\nstarter 子模块中包括 C/C++, C#, Java, JavaScript, Python, Ruby 以及 GO 的规则，在 vscode-codeql-starter\\ql 下<br>\n CodeQL 暂时无法扫描 php 代码</p>\n<h2 id=\"0x3-导入数据库\"><a class=\"markdownIt-Anchor\" href=\"#0x3-导入数据库\">#</a> 0x3 导入数据库</h2>\n<p>我们生成的数据库为文件夹，那我们就选择 “From a folder”<br>\n<img src=\"f34afaeeb873e92b778012073f19323d.png\" alt=\"f34afaeeb873e92b778012073f19323d.png\"></p>\n<h2 id=\"0x4-运行规则\"><a class=\"markdownIt-Anchor\" href=\"#0x4-运行规则\">#</a> 0x4 运行规则</h2>\n<p>点开项目文件，我们可以看见 ql 下有很多规则<br>\n<img src=\"b21766327a9941eca1f56dd455c1ec10.png\" alt=\"b21766327a9941eca1f56dd455c1ec10.png\"><br>\n 因为示例源码为 java 语言，我们选择 java 下的规则文件夹<br>\n右键选择 &quot;CodeQL:RunQueries in Selected Files&quot;<br>\n 里面有 81 个 CWE 规则<br>\n<img src=\"bce12ed22e130d749eeae5b4d9caffcf.png\" alt=\"bce12ed22e130d749eeae5b4d9caffcf.png\"></p>\n<h2 id=\"0x5-查看结果\"><a class=\"markdownIt-Anchor\" href=\"#0x5-查看结果\">#</a> 0x5 查看结果</h2>\n<p>点击左侧的一条规则，可以看到对应规则运行的结果在右侧<br>\n<img src=\"ccbdb52e0810eda9b4d99e3ac19c4e0d.png\" alt=\"ccbdb52e0810eda9b4d99e3ac19c4e0d.png\"></p>\n",
            "tags": [
                "CodeQL"
            ]
        },
        {
            "id": "http://example.com/2022/06/10/CodeQLU-BootChallenge%20(CC++)/",
            "url": "http://example.com/2022/06/10/CodeQLU-BootChallenge%20(CC++)/",
            "title": "CodeQLU-BootChallenge(CC++)",
            "date_published": "2022-06-10T02:39:31.000Z",
            "content_html": "<p>[toc]</p>\n<h1 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\">#</a> 背景</h1>\n<p>需要在 U-Boot 中寻找一组 9 个远程代码执行漏洞<br>\n漏洞点位于 memcpy 函数<br>\n但并非所有调用 memcpy 函数的都存在漏洞<br>\n所以我们需要减少误报率，找到真正存在漏洞的 memcpy 调用</p>\n<p><a href=\"https://lab.github.com/githubtraining/codeql-u-boot-challenge-(cc++)\">放上题目链接</a><br>\n关于环境搭建根据题目提示就可以顺利完成哦<br>\n也可以参考我的文章 &quot;CodeQL for VSCode 搭建流程&quot;<br>\n 不出意外会放在我的<a href=\"https://milkii0.github.io\">博客中</a></p>\n<h1 id=\"step-3-our-first-query\"><a class=\"markdownIt-Anchor\" href=\"#step-3-our-first-query\">#</a> Step 3 - our first query</h1>\n<p>在项目中寻找所有名为’strlen’的函数<br>\n语法类似于 sql 语句<br>\n <code>import cpp</code> : 导入 c++ 规则库<br>\n <code>From Function f1</code> : 声明一个 Function 类的变量为 f1<br>\n <code>where f1.getName() = &quot;strlen&quot;</code> : Function.getName () 顾名思义用于获取此声明的名称，也就是名称和&quot;strlen&quot; 相等的声明会被挑选出来<br>\n <code>select f1,&quot;a function named strlen&quot;</code> : select 后接要在 result 中展示的项目，用逗号分隔<br>\n 3_function_definitions.ql</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import cpp</span><br><span class=\"line\"></span><br><span class=\"line\">from Function f1</span><br><span class=\"line\">where f1.getName() = &quot;strlen&quot;</span><br><span class=\"line\">select f1,&quot;a function named strlen&quot;</span><br></pre></td></tr></table></figure>\n<p><img src=\"f67230350390011a65f16d340406022d.png\" alt=\"f67230350390011a65f16d340406022d.png\"><br>\n 直接在 main 提交<br>\n<img src=\"b20d0a09af05b0e0b6f0889c8bd499fe.png\" alt=\"b20d0a09af05b0e0b6f0889c8bd499fe.png\"><br>\ncommit 中查看结果，通过<br>\n<img src=\"9c74098f2c390ad1f066fa3cd8fc6349.png\" alt=\"9c74098f2c390ad1f066fa3cd8fc6349.png\"></p>\n<h1 id=\"step-4-anatomy-of-a-query\"><a class=\"markdownIt-Anchor\" href=\"#step-4-anatomy-of-a-query\">#</a> Step 4 - Anatomy of a query</h1>\n<p>仿照上一步，在项目中寻找所有名为’memcpy’的函数<br>\n 4_function_definitions.ql</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import cpp</span><br><span class=\"line\"></span><br><span class=\"line\">from Function f</span><br><span class=\"line\">where f.getName() = &quot;memcpy&quot;</span><br><span class=\"line\">select f,&quot;a function named memcpy&quot;</span><br></pre></td></tr></table></figure>\n<p>提交查看结果，通过<br>\n<img src=\"e7a2871ee72e24c0663d8b9042c8e434.png\" alt=\"e7a2871ee72e24c0663d8b9042c8e434.png\"></p>\n<h1 id=\"step-5-using-different-classes-and-their-predicates\"><a class=\"markdownIt-Anchor\" href=\"#step-5-using-different-classes-and-their-predicates\">#</a> Step 5 - Using different classes and their predicates</h1>\n<p>自定义规则，查找三个名为 <code>ntohs</code> ,  <code>ntohl</code>  or  <code>ntohll</code>  的宏定义<br>\n需要一个紧凑的查询，而不是三个查找案例组合在一起<br>\n给出以下两种方法</p>\n<ol>\n<li>利用正则表达式<br>\n <code>string</code>  类有一个方法 <code>regexpMatch</code> ，接收器将参数与正则表达式匹配<br>\n那我们需要先找到宏定义，再对该字符串进行正则匹配（使用的 java 的匹配模式）<br>\n5_function_definitions.ql</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import cpp</span><br><span class=\"line\"></span><br><span class=\"line\">from Macro m</span><br><span class=\"line\">where m.getName().regexpMatch(&quot;ntoh(s|l|ll)&quot;)</span><br><span class=\"line\">select m,&quot;macros named ntohs, ntohl or ntohll&quot;</span><br></pre></td></tr></table></figure>\n<p>运行<br>\n<img src=\"dc5f776d88ef17d90e7be870a333f285.png\" alt=\"dc5f776d88ef17d90e7be870a333f285.png\"></p>\n<ol start=\"2\">\n<li>使用集合表达式<br>\n给出的格式：&lt;your_variable_name&gt; in [“bar”, “baz”, “quux”]</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import cpp</span><br><span class=\"line\"></span><br><span class=\"line\">from Macro m</span><br><span class=\"line\">where m.getName() in [&quot;ntohs&quot;,&quot;ntohl&quot;,&quot;ntohll&quot;]</span><br><span class=\"line\">select m,&quot;macros named ntohs, ntohl or ntohll&quot;</span><br></pre></td></tr></table></figure>\n<p>运行后和之前的结果相同，提交通过</p>\n<p>PS：<br>\n上学的时候为了过考试自学的 c++，就是一些简单的语法<br>\n看题目说明也没看明白 ntoh 族函数到底是个啥<br>\n后来看见了<a href=\"https://bestwing.me/codeql.html\"> swing 的文章</a><br>\n才知道 ntoh 族函数通常用来进行网络字节序到主机字节序的转换<br>\n其实自己看到的时候就应该去查的，但是因为对题目影响不大就犯懒没去:-(<br>\n以后不能这样了！看见没见过的看不懂的一定要去弄清楚</p>\n<h1 id=\"step-6-relating-two-variables\"><a class=\"markdownIt-Anchor\" href=\"#step-6-relating-two-variables\">#</a> Step 6 - Relating two variables</h1>\n<p>找到所有对 <code>memcpy</code>  函数的调用<br>\n先看看给的例子<br>\n <code>FunctionCall.getTarget()</code>  查询该函数被调用的位置<br>\n直接和 <code>Function</code>  类型的 <code>fcn</code>  对比值，说明他返回的值应该就是 <code>Function</code>  类型（这点在下面优化中会用到）</p>\n<p>通过 <code>Function.hasName()</code>  获取方法名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import cpp</span><br><span class=\"line\"></span><br><span class=\"line\">from FunctionCall call, Function fcn</span><br><span class=\"line\">where</span><br><span class=\"line\">  call.getTarget() = fcn and</span><br><span class=\"line\">  fcn.getDeclaringType().getSimpleName() = &quot;map&quot; and</span><br><span class=\"line\">  fcn.getDeclaringType().getNamespace().getName() = &quot;std&quot; and</span><br><span class=\"line\">  fcn.hasName(&quot;find&quot;)</span><br><span class=\"line\">select call</span><br></pre></td></tr></table></figure>\n<p>如果你想要省略中间变量 <code>Function</code> ，使查询的更加紧凑，可以参考以下两个对比<br>\n <code>c1.getClass2()</code>  返回的是 Class2 类型的值，因此可以直接调用 Class2 的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from Class1 c1, Class2 c2</span><br><span class=\"line\">where</span><br><span class=\"line\">  c1.getClass2() = c2 and</span><br><span class=\"line\">  c2.getProp() = &quot;something&quot;</span><br><span class=\"line\">select c1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">from Class1 c1</span><br><span class=\"line\">where c1.getClass2().getProp() = &quot;something&quot;</span><br><span class=\"line\">select c1</span><br></pre></td></tr></table></figure>\n<p>根据以上案例思考<br>\n我们需要找到 <code>memcpy</code>  函数被调用的位置，可以使用<br>\n <code>FunctionCall.getTarget()</code> <br>\n 并希望查询更加紧凑，可以直接获取找到的函数的名称并进行判断<br>\n <code>FunctionCall.getTarget().getName=&quot;memcpy&quot;</code></p>\n<p>6_memcpy_calls.ql</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import cpp</span><br><span class=\"line\">from FunctionCall functioncall</span><br><span class=\"line\">where functioncall.getTarget().hasName(&quot;memcpy&quot;)</span><br><span class=\"line\">select functioncall</span><br></pre></td></tr></table></figure>\n<p>提交通过<br>\n<img src=\"40bdea82763f6ab88adaccc6e47931b4.png\" alt=\"40bdea82763f6ab88adaccc6e47931b4.png\"></p>\n<h1 id=\"step-7-relating-two-variables-continued\"><a class=\"markdownIt-Anchor\" href=\"#step-7-relating-two-variables-continued\">#</a> Step 7 - Relating two variables, continued</h1>\n<p>寻找所有对 <code>ntoh*</code>  宏定义的调用</p>\n<p>这里用到的是 <code>MacroInvocation</code>  这个类，顾名思义就是宏定义调用的类<br>\n鼠标悬浮看其注释也能看出来<br>\n<img src=\"69d9e0e24f06860213619664c0c91321.png\" alt=\"69d9e0e24f06860213619664c0c91321.png\"><br>\n 那么我们就可以通过 <code>getMacro()</code>  寻找被调用的宏定义，并得到返回的 <code>Macro</code>  类型值<br>\n再获得找到的 <code>Macro</code>  名称进行正则匹配，即可获得我们想要的结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import cpp</span><br><span class=\"line\"> from MacroInvocation macInvo</span><br><span class=\"line\"> where macInvo.getMacro().getName().regexpMatch(&quot;ntoh.*&quot;)</span><br><span class=\"line\"> select macInvo</span><br></pre></td></tr></table></figure>\n<p>（备注：关于正则表达式，不太会写，找的 java 正则 api 看的。<br>\n <code>.</code>  表示匹配除换行符 \\n 之外的任何单字符， <code>*</code>  表示零次或多次，<br>\n我这里希望得到的结果是以 <code>ntoh</code>  开头的宏定义都会被选中。<br>\n如果有不对的地方，还希望可以被提出指正◔ ‸◔）</p>\n<p>提交通过<br>\n<img src=\"5807d43f1ce8796d351638d6f55cde4a.png\" alt=\"5807d43f1ce8796d351638d6f55cde4a.png\"></p>\n<h1 id=\"step-8-changing-the-selected-output\"><a class=\"markdownIt-Anchor\" href=\"#step-8-changing-the-selected-output\">#</a> Step 8 - Changing the selected output</h1>\n<p>根据提示，使用 <code>getExpr()</code>  这个 predicate<br>\n 先看看这个 <code>getExpr()</code>  的注释说明<br>\n是用来获取宏定义表达式的<br>\n如果顶级拓展元素不是表达式，它只是一条语句，将不会被选中列为结果<br>\n<img src=\"09d6ad29dcccc9157677864a39460e27.png\" alt=\"09d6ad29dcccc9157677864a39460e27.png\"><br>\n 使用 <code>select macInvo.getExpr()</code> ，就能获得宏定义调用相关的表达式<br>\n 8_macro_expressions.ql</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import cpp</span><br><span class=\"line\"> from MacroInvocation macInvo</span><br><span class=\"line\"> where macInvo.getMacro().getName().regexpMatch(&quot;ntoh.*&quot;)</span><br><span class=\"line\"> select macInvo.getExpr()</span><br></pre></td></tr></table></figure>\n<p>例如点击其中一个结果，就会跳转至下图位置<br>\n<img src=\"82697e23ad6a1cd05073bea662213bf8.png\" alt=\"82697e23ad6a1cd05073bea662213bf8.png\"><br>\n 提交通过<br>\n<img src=\"839b8030c2474b52816e9afc1212d9a1.png\" alt=\"839b8030c2474b52816e9afc1212d9a1.png\"></p>\n<p>那么查询表达式和查询调用的区别是啥？<br>\n看注释说明，<br>\n <code>getExpr()</code> ：<br>\n<em>Gets a top-level expression associated with this macro invocation,if any.<br>\nNote that this predicate will fail if the top-level expanded element is not an expression (for example if it is a statement).<br>\nThis macro is intended to be used with macros that expand to a complete expression.<br>\nIn other cases, it may have multiple results or no results.</em><br>\n 获取关于宏调用的顶级表达式<br>\n注意，如果顶级扩展元素不是一个表达式的话查询将失败（例如，它是一个语句）<br>\n此宏用于扩展为完整表达式的宏，在其他情况下可能会有多个结果或没有结果</p>\n<p><code>getMacro()</code> ：<br>\n<em>Gets the macro that is being accessed.</em><br>\n 获取正在访问的宏</p>\n<p>即 <code>getMacro()</code>  会获取所有调用的宏，即使他只是一个语句<br>\n而 <code>getExpr()</code>  只会获取宏调用的顶级表达式<br>\n所以 <code>getExpr()</code>  得到的结果集应该包含于 <code>getMacro()</code>  的结果集<br>\n这里放上<a href=\"https://www.zhihu.com/question/20750344\">语句和表达式的区别讨论链接</a></p>\n<h1 id=\"step-9-write-your-own-class\"><a class=\"markdownIt-Anchor\" href=\"#step-9-write-your-own-class\">#</a> Step 9 - Write your own class</h1>\n<p>首先看看学习 <code>exists</code>  关键词给出的例子：<br>\n这个规则只是为了获取不秃头的所有人</p>\n<p>不秃头的人都会有头发，那么他们的头发都会对应一个或多个颜色<br>\n其中 <code>t.getHairColor()</code>  会返回一个 <code>string</code>  类型的值，例如 &quot;red&quot;<br>\n 如果我们需要获得不秃头的人，我们并不需要知道他们头发的具体颜色，只需要知道 <code>t.getHairColor()</code>  会返回 <code>string</code>  类型的值即可，因为秃头 <code>getHairColor()</code>  时，不会返回任何值</p>\n<p>所以我们利用 <code>string</code>  类型的变量完成该操作<br>\n更好的方式是使用 <code>exists</code>  关键词，因为我们只是在 <code>where</code>  中使用该变量<br>\n例如， <code>exists(string c | t.getHairColor() = c)</code>  使用了 string 类型的临时变量，用于获取 <code>t.getHairColor()</code>  返回了 <code>string</code>  值的 <code>t</code> ，也就是查询了所有头发颜色的值为 <code>string</code>  类型的人</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from Person t</span><br><span class=\"line\">where exists(string c | t.getHairColor() = c)</span><br><span class=\"line\">select t</span><br><span class=\"line\"></span><br><span class=\"line\">/*在CodeQL中，以下代码功能同于以上代码，给出只是为了更好地理解*/</span><br><span class=\"line\">from Person t, string c</span><br><span class=\"line\">where t.getHairColor() = c</span><br><span class=\"line\">select t</span><br></pre></td></tr></table></figure>\n<p>再来看看类定义中给出的案例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class OneTwoThree extends int &#123;</span><br><span class=\"line\">  OneTwoThree() &#123; // characteristic predicate</span><br><span class=\"line\">    this = 1 or this = 2 or this = 3</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  string getAString() &#123; // member predicate</span><br><span class=\"line\">    result = &quot;One, two or three: &quot; + this.toString()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  predicate isEven() &#123; // member predicate</span><br><span class=\"line\">    this = 2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码定义了一个名为 <code>OneTwoThree</code>  的类，继承于 int<br>\n 类似于构造函数的部分是 <code>this = 1 or this = 2 or this = 3</code> <br>\n 文档中解释说明这个类中包括了 1,2,3 这三个值<br>\n运行以下规则，可以发现 ott 中确实有 1，2，3 这三个值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import cpp</span><br><span class=\"line\"> /*from MacroInvocation macInvo</span><br><span class=\"line\"> where macInvo.getMacro().getName().regexpMatch(&quot;ntoh.*&quot;)</span><br><span class=\"line\"> select macInvo.getExpr()*/</span><br><span class=\"line\"> class OneTwoThree extends int &#123;</span><br><span class=\"line\">    OneTwoThree() &#123; // characteristic predicate</span><br><span class=\"line\">      this = 1 or this = 2 or 3=this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    string getAString() &#123; // member predicate</span><br><span class=\"line\">      result = &quot;One, two or three: &quot; + this.toString()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    predicate isEven() &#123; // member predicate</span><br><span class=\"line\">      this = 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  from OneTwoThree ott</span><br><span class=\"line\">  select ott</span><br></pre></td></tr></table></figure>\n<p><img src=\"e4a0cc58f70e7e930a95949605394de8.png\" alt=\"e4a0cc58f70e7e930a95949605394de8.png\"></p>\n<p>其中还有一个熟悉的单词 <code>predicate</code> <br>\n 这个是在类的主体内定义的谓词，是使用变量来限制类中可能的值的逻辑属性<br>\n举个例子，运行以下规则，就会得到值 2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class OneTwoThree extends int &#123;</span><br><span class=\"line\">   OneTwoThree() &#123; // characteristic predicate</span><br><span class=\"line\">     this = 1 or this = 2 or 3=this</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">   string getAString() &#123; // member predicate</span><br><span class=\"line\">     result = &quot;One, two or three: &quot; + this.toString()</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">   predicate isEven() &#123; // member predicate</span><br><span class=\"line\">     this = 2</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> from OneTwoThree ott</span><br><span class=\"line\"> where ott.isEven()</span><br><span class=\"line\"> select ott</span><br></pre></td></tr></table></figure>\n<p>运行截图：<br>\n<img src=\"b7da8682bac3c07ef7a2d8d41cffc090.png\" alt=\"b7da8682bac3c07ef7a2d8d41cffc090.png\"><br>\n 再更改规则如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class OneTwoThree extends int &#123;</span><br><span class=\"line\">   OneTwoThree() &#123; // characteristic predicate</span><br><span class=\"line\">     this = 1 or this = 2 or 3=this</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">   string getAString() &#123; // member predicate</span><br><span class=\"line\">     result = &quot;One, two or three: &quot; + this.toString()</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">   predicate isEven() &#123; // member predicate</span><br><span class=\"line\">     this = 2</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> from OneTwoThree ott</span><br><span class=\"line\"> where ott = 2</span><br><span class=\"line\"> select ott</span><br></pre></td></tr></table></figure>\n<p>他们会得到相同的结果<br>\n<img src=\"c4bff2b9bd1c95c4becc00965b3a52f4.png\" alt=\"c4bff2b9bd1c95c4becc00965b3a52f4.png\"><br>\n 也就是说 <code>where ott.isEven()</code>  和 <code>where ott = 2</code>  做出的是相同的限制<br>\n那么我们也就能更好地理解， <code>predicate</code>  特征是用于限制类中可能值的逻辑属性了</p>\n<p>其中 <code>string getAString()</code>  就不必多说，返回一个字符串，其中包含对应值<br>\n<img src=\"1da4e1a23a80b04ee390a564d069fc2e.png\" alt=\"1da4e1a23a80b04ee390a564d069fc2e.png\"><br>\n 其中我发现一个很神奇事，不知该如何解释<br>\n我将代码中 <code>this=1</code>  改成 <code>1=this</code>  也会得到一样的结果，没有任何不同或报错<br>\n它和赋值语句不同，但好像又具有相似的功能<br>\n在对变量做限制时，例如 <code>where ott = 2</code> ，它就变成了一个符号，用于对两个值进行比较，这里还好理解，因为 sql 语法类似<br>\n但是同样在以下代码中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">predicate isEven() &#123; // member predicate</span><br><span class=\"line\">     this = 2</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p><code>this=2</code>  也是用于对两个值进行比较<br>\n我认为这是由于 <code>predicate</code>  带来的改变，使得其中的代码和 <code>where</code>  后的代码具有相同得到功能<br>\n如果有更好的见解，还不忘赐教</p>\n<p>最后来写题<br>\n题目给了模板和提示<br>\n按照 step8 中的规则进行编写， <code>exists</code>  第二个参数放上 step8 中的 where 条件<br>\n由于 select 由题目给出并为 Expr 的子类，所以我们需要增加一个条件获取宏调用相关表达式<br>\n根据以上 <code>exists</code>  案例可知，我们需要在 <code>mi.getExpr() =</code>  后面写出他返回值的类型，这样当 <code>mi</code>  为表达式时，就会被选中<br>\n <code>NetworkByteSwap</code>  是 <code>Expr</code>  的子类，因此</p>\n<p>9_class_network_byteswap.ql</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import cpp</span><br><span class=\"line\"></span><br><span class=\"line\">class NetworkByteSwap extends Expr &#123;</span><br><span class=\"line\">    NetworkByteSwap() &#123; </span><br><span class=\"line\">        exists(MacroInvocation mi | mi.getMacro().getName().regexpMatch(&quot;ntoh.*&quot;) | mi.getExpr() = this)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">from NetworkByteSwap n</span><br><span class=\"line\">select n, &quot;Network byte swap&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"step-10-data-flow-and-taint-tracking-analysis\"><a class=\"markdownIt-Anchor\" href=\"#step-10-data-flow-and-taint-tracking-analysis\">#</a> Step 10 - Data flow and taint tracking analysis</h1>\n<p>最后一步，进行数据流分析</p>\n<p>先了解以下我们需要查询的函数背景， <code>ntoh*</code>  函数会返回一个数，并用于 <code>memcpy</code>  的第三个参数 <code>size</code> ，所以我们需要追踪的数据流就是从 <code>ntoh*</code>  到 <code>memcpy</code></p>\n<blockquote>\n<p>在 C/C++ 写网络程序的时候，往往会遇到字节的网络顺序和主机顺序的问题。 这时就可能用到 htons (), ntohl (), ntohs ()，htons () 这 4 个网络字节顺序与本地字节顺序之间的转换函数</p>\n</blockquote>\n<blockquote>\n<p>memcpy 指的是 c 和 c++ 使用的内存拷贝函数，memcpy 函数的功能是从源 src 所指的内存地址的起始位置开始拷贝 n 个字节到目标 dest 所指的内存地址的起始位置中</p>\n</blockquote>\n<p>创建 <code>Config</code>  类，查找此类的数据流并进行污染点追踪分析<br>\n进行数据流分析，我们需要用到，部分代码已经在给出的模板中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import semmle.code.cpp.dataflow.TaintTracking</span><br><span class=\"line\">import DataFlow::PathGraph</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们需要写两个 <code>predicate</code> ，一个是来源 <code>isSource</code> ，一个是接收器 <code>isSink</code></p>\n<p><code>isSource</code>  中我们需要查询 <code>ntoh*</code>  宏定义调用的相关表达式，这一步我们已经在 <code>NetworkByteSwap</code>  中写过了<br>\n <code>isSink</code>  中我们需要查询调用 <code>memcpy</code>  函数时，传入的第三个参数 <code>size</code> ，这一步我们需要新增加的步骤是获取参数</p>\n<p>弄清楚这些后，在编写规则时，根据提示完善代码<br>\n我们就能获得 10_taint_tracking.ql 的答案</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @kind path-problem</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">import cpp</span><br><span class=\"line\">import semmle.code.cpp.dataflow.TaintTracking</span><br><span class=\"line\">import DataFlow::PathGraph</span><br><span class=\"line\"></span><br><span class=\"line\">class NetworkByteSwap extends Expr &#123;</span><br><span class=\"line\">    NetworkByteSwap() &#123; </span><br><span class=\"line\">        exists(MacroInvocation mi| mi.getMacro().getName().regexpMatch(&quot;ntoh(s|l|ll)&quot;) | this = mi.getExpr())</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Config extends TaintTracking::Configuration &#123;</span><br><span class=\"line\">  Config() &#123; this = &quot;NetworkToMemFuncLength&quot; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class=\"line\">    // TODO</span><br><span class=\"line\">    /*获取与此节点对应的表达式（如果有）。</span><br><span class=\"line\">    此谓词仅在表示表达式求值值的节点上具有结果。</span><br><span class=\"line\">    对于从表达式中流出的数据，例如通过引用传递参数时，请使用asDefiningArgument而不是asExpr。*/</span><br><span class=\"line\">    source.asExpr() instanceof NetworkByteSwap</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class=\"line\">    // TODO</span><br><span class=\"line\">    exists(FunctionCall fc | fc.getTarget().hasName(&quot;memcpy&quot;) | sink.asExpr() = fc.getArgument(2))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class=\"line\">where cfg.hasFlowPath(source, sink)</span><br><span class=\"line\">select sink, source, sink, &quot;Network byte swap flows to memcpy&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"传送门\"><a class=\"markdownIt-Anchor\" href=\"#传送门\">#</a> 传送门</h1>\n<p><a href=\"https://lgtm.com/help/lgtm/console/ql-cpp-basic-example\">cpp 规则语法说明</a><br>\n<a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html\"> Java 正则模式</a><br>\n<a href=\"https://securitylab.github.com/research/cve-2018-4259-macos-nfs-vulnerability/\">给出的参考案例：CVE-2018-4259: MacOS NFS vulnerabilties lead to kernel RCE</a>（知识点挺多的）<br>\n<a href=\"https://bestwing.me/codeql.html\">codeql-swing</a>（swing 的语言云淡风轻，条理清晰，如沐春风，我的的语言阿巴阿巴阿巴）<br>\n<a href=\"https://github.com/github/securitylab/discussions\">讨论区</a></p>\n",
            "tags": [
                "CodeQL"
            ]
        }
    ]
}