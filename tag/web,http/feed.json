{
    "version": "https://jsonfeed.org/version/1",
    "title": "Milkii0的秘密花园 • All posts by \"web,http\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/08/03/HTTP%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/",
            "url": "http://example.com/2021/08/03/HTTP%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/",
            "title": "HTTP请求走私简述",
            "date_published": "2021-08-03T02:20:54.000Z",
            "content_html": "<h1 id=\"http请求走私是什么\"><a class=\"markdownIt-Anchor\" href=\"#http请求走私是什么\">#</a> HTTP 请求走私是什么</h1>\n<p>HTTP 请求走私，一种干扰网站处理来自用户的 HTTP <ins class=\"wavy\">请求序列</ins> 的技术</p>\n<h2 id=\"相关知识点\"><a class=\"markdownIt-Anchor\" href=\"#相关知识点\">#</a> 相关知识点</h2>\n<p>该漏洞的产生主要和 HTTP 请求中的两个头相关：</p>\n<p><span class=\"spoiler\" title=\"...\">Transfer_Encoding</span>  &amp; <span class=\"spoiler\" title=\"...\">Content-Length</span></p>\n<h3 id=\"transfer-encoding\"><a class=\"markdownIt-Anchor\" href=\"#transfer-encoding\">#</a> <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding\">Transfer-Encoding</a></h3>\n<p>Transfer-Encoding 通用标头字段指示已对消息正文应用了什么（如果有）类型的转换，以便在发送方和接收方之间安全地传输它，在 HTTP1.1 中可用</p>\n<p>利用该漏洞，需指定参数为 chunked  <code> Transfer-Encoding: chunked</code> ，表示数据以一系列块发送，而不是等到完整的段可用</p>\n<p>在 CTE 中，每个块前面都有它的大小（字节为单位）</p>\n<p>当接收到零长度块时（不可省略），传输结束</p>\n<p>✋🌰</p>\n<figure class=\"highlight plaintext\"><figcaption><span>数据包喔</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK </span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">5\\r\\n</span><br><span class=\"line\">Media\\r\\n</span><br><span class=\"line\">8\\r\\n</span><br><span class=\"line\">Services\\r\\n</span><br><span class=\"line\">4\\r\\n</span><br><span class=\"line\">Live\\r\\n</span><br><span class=\"line\">0\\r\\n</span><br><span class=\"line\">\\r\\n</span><br></pre></td></tr></table></figure>\n<p>第一部分： 当前组块长度（16 进制）+ \\r\\n</p>\n<p>第二部分： 块内容 + \\r\\n</p>\n<p>（例如 Media 就是 5 个字节长度）</p>\n<p>倒数第二部分： 终止块 -&gt; 分块编码以任何大小为零的块结束，长度为 0 -&gt; 0\\r\\n</p>\n<p>最后一部分： 以空行终止（\\r\\n）</p>\n<h3 id=\"content-length\"><a class=\"markdownIt-Anchor\" href=\"#content-length\">#</a> Content-Length</h3>\n<p>该字段指示发送给接受者的实体主体的大小，以十进制的 OCTET 数表示</p>\n<p>这个可以自己用 burp 发包试试哦，bp 的 repeat 选项中默认开启了 Update Content-Length 选项</p>\n<h3 id=\"注意connection\"><a class=\"markdownIt-Anchor\" href=\"#注意connection\">#</a> ⭐注意 Connection</h3>\n<blockquote>\n<p>每当传输编码应用于消息体时，传输编码集必须包括 “分块”，除非消息因关闭连接而终止</p>\n<p>——<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6\">HTTP/1.1: Protocol Parameters</a></p>\n</blockquote>\n<p>也就是说，当连接关闭时，也会导致消息终止</p>\n<p>那么我们在发送数据包时，就需要注意 <ins>Connection</ins> 头</p>\n<p>Connection: keep-alive -&gt; 表示客户端希望保持连接打开，拥有持久连接是 HTTP/1.1 请求的默认设置</p>\n<p>Connection: close -&gt; 表示客户端或服务器想要关闭连接，这是 HTTP/1.0 请求的默认设置</p>\n<h1 id=\"http请求走私的原理\"><a class=\"markdownIt-Anchor\" href=\"#http请求走私的原理\">#</a> HTTP 请求走私的原理</h1>\n<p>现很多应用程序使用 HTTP 服务链（2 个或多个服务器）</p>\n<p>其中前端服务器有时称为负载均衡器或反向代理</p>\n<p><img src=\"1.png\" alt=\"burp图片哦\"></p>\n<p>这时，若前端后端系统就请求之间的边界没有达成一致，就可以发送一个模棱两可的请求，让前端和后端系统对该请求进行不同的解释</p>\n<p><img src=\"2.png\" alt=\"\"></p>\n<p>👇👇👇</p>\n<p>由于 HTTP 规范提供了两种方法指定消息长度（Content-Length&amp;Transform-Encoding），所以单个消息​同时使用两种方法时，不同的服务器可能出现不同的解释</p>\n<p>如果消息头以某种方式模糊了，则可以诱导消息头不处理它</p>\n<p>👆👆👆</p>\n<h1 id=\"http请求走私利用\"><a class=\"markdownIt-Anchor\" href=\"#http请求走私利用\">#</a> HTTP 请求走私利用</h1>\n<p>请求走私大致分为 3️⃣种类型</p>\n<ul>\n<li><a href=\"http://CL.ET\">CL.ET</a> -&gt; 前端服务器使用 Content-Length，后端服务器使用 Transfer-Encoding</li>\n<li><a href=\"http://TE.CL\">TE.CL</a> -&gt; 前端服务器使用 Transfer-Encoding，后端服务器使用 Content-Length</li>\n<li>TE.TE -&gt; 前后端均使用 Transfer-Encoding，但其中一个服务器可被某种方式诱导不处理该头部字段</li>\n</ul>\n<h2 id=\"实验环境\"><a class=\"markdownIt-Anchor\" href=\"#实验环境\">#</a> <a href=\"https://portswigger.net/web-security/request-smuggling\">实验环境</a></h2>\n<p>但是不知道为什么我一直没办法注册 portswigger，只能分析一下给出的例子了</p>\n<h3 id=\"clet\"><a class=\"markdownIt-Anchor\" href=\"#clet\">#</a> <a href=\"http://CL.ET\">CL.ET</a></h3>\n<p>攻击数据包</p>\n<figure class=\"highlight plaintext\"><figcaption><span>数据包</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST / HTTP/1.1</span><br><span class=\"line\">Host: vulnerable-website.com</span><br><span class=\"line\">Content-Length: 13</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\"></span><br><span class=\"line\">0</span><br><span class=\"line\"></span><br><span class=\"line\">SMUGGLED</span><br></pre></td></tr></table></figure>\n<p>数据同时使用两种方法指定消息长度</p>\n<p>🎀前服务器处理 Content-Length 头，认为请求主体为 13 字节，刚好至 smuggled 末尾，再将消息转发至后端服务器</p>\n<p>🎀后服务器处理 Transfer-Encoding 头，由上述 Transfer-Encoding 知识点可知，这是一个终止块，那么接下来的 smuggled 不会被处理，后端服务器会将 smuggled 拼接至下一个请求的开始</p>\n<h3 id=\"tecl\"><a class=\"markdownIt-Anchor\" href=\"#tecl\">#</a> <a href=\"http://TE.CL\">TE.CL</a></h3>\n<p>类似 CL.TE</p>\n<figure class=\"highlight plaintext\"><figcaption><span>数据包</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST / HTTP/1.1</span><br><span class=\"line\">Host: vulnerable-website.com</span><br><span class=\"line\">Content-Length: 3</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\"></span><br><span class=\"line\">8</span><br><span class=\"line\">SMUGGLED</span><br><span class=\"line\">0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>（⭐burp 上方 repeater 选项取消 Update Content-Length，这个选项会根据实体长度自动更新 Content-Length 头）</p>\n<p>🎀前服务器处理 Transfer-Encoding 头，第一块 8 个字节，第二块为终止块，请求终止，请求转发至后端服务器</p>\n<p>🎀后服务器处理 Content-Length 头，实体长度为 3，那么从 S 开始的内容，都将被视为序列中下一个请求的开始</p>\n<h3 id=\"tete\"><a class=\"markdownIt-Anchor\" href=\"#tete\">#</a> TE.TE</h3>\n<p>混淆 Transfer-Encoding 头的方式很多，例如</p>\n<ul>\n<li>Transfer-Encoding: xchunked</li>\n<li>Transfer-Encoding : chunked</li>\n<li>Transfer-Encoding: chunked<br>\nTransfer-Encoding: x</li>\n<li>Transfer-Encoding:[tab]chunked</li>\n<li>[space]Transfer-Encoding: chunked</li>\n<li>X: X[\\n]Transfer-Encoding: chunked</li>\n<li>\n<dl>\n<dt>Transfer-Encoding</dt>\n<dd>chunked</dd>\n</dl>\n</li>\n</ul>\n<h1 id=\"检测http请求走私\"><a class=\"markdownIt-Anchor\" href=\"#检测http请求走私\">#</a> 检测 HTTP 请求走私</h1>\n<p>实时站点，流量较大，可能将我们的 payload 拼接至别的用户数据包中</p>\n<p>以下列出一种几乎没有影响其他用户风险的检测手段</p>\n<figure class=\"highlight plaintext\"><figcaption><span>数据包</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /smuggled HTTP/1.1</span><br><span class=\"line\">HOST: example.com</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Content-Length: 4</span><br><span class=\"line\"></span><br><span class=\"line\">1</span><br><span class=\"line\">Z</span><br><span class=\"line\">Q</span><br></pre></td></tr></table></figure>\n<h2 id=\"clet-2\"><a class=\"markdownIt-Anchor\" href=\"#clet-2\">#</a> <a href=\"http://CL.ET\">CL.ET</a></h2>\n<p>前端检测实体长度为 4 个字节，Q 不会被转发，后端没有接受到终止块，会一直等待至超时，此时会有明显的延迟效果</p>\n<h2 id=\"clcl\"><a class=\"markdownIt-Anchor\" href=\"#clcl\">#</a> <a href=\"http://CL.CL\">CL.CL</a></h2>\n<p>会被两个系统无害处理</p>\n<h2 id=\"tecl-2\"><a class=\"markdownIt-Anchor\" href=\"#tecl-2\">#</a> <a href=\"http://TE.CL\">TE.CL</a>&amp;TE.TE</h2>\n<p>由于无效的大小块 Q，前端将拒绝该消息，不会将其转发至后端</p>\n<p>那么怎么区分以上两个呢，且看下面这个数据包</p>\n<figure class=\"highlight plaintext\"><figcaption><span>数据包</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /smuggled HTTP/1.1</span><br><span class=\"line\">HOST: example.com</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Content-Length: 9</span><br><span class=\"line\"></span><br><span class=\"line\">0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">X</span><br></pre></td></tr></table></figure>\n<p>为 TE.CL 模式时，前端接收终止块，转发 X（不包括 X）以前的内容至后端服务器，共 7 个字节。后端服务器处理 Content-Length 头，认为实体为 9 个字节（&gt;7），此时也会出现明显延迟</p>\n<p>为 TE.TE 时，正确的终止块格式，会被系统无害处理</p>\n<p>⭐burp 商店中也可以找到 HTTP Request Smuggler 模块，可以 scan 出来后，右键 Smuggle attack</p>\n<p>⭐工具：<a href=\"https://github.com/defparam/smuggler\">https://github.com/defparam/smuggler</a></p>\n<h1 id=\"修复http请求走私\"><a class=\"markdownIt-Anchor\" href=\"#修复http请求走私\">#</a> 修复 HTTP 请求走私</h1>\n<h2 id=\"我-不-理-解\"><a class=\"markdownIt-Anchor\" href=\"#我-不-理-解\">#</a> 我 不 理 解</h2>\n<p>在前端服务器通过同一网络连接将多个请求转发到后端服务器的情况下，会出现 HTTP 请求走私漏洞，并且后端连接所使用的协议有可能会造成边界不统一的风险。防止 HTTP 请求走私漏洞的一些通用方法如下：</p>\n<p>1. 禁用后端连接的重用，以便每个后端请求通过单独的网络连接发送。</p>\n<p>2. 使用 HTTP / 2 进行后端连接，因为此协议可防止对请求之间的边界产生歧义。</p>\n<p>3. 前端服务器和后端服务器使用完全相同的 Web 服务器软件，以便它们就请求之间的界限达成一致。</p>\n<h1 id=\"传送门\"><a class=\"markdownIt-Anchor\" href=\"#传送门\">#</a> 传送门</h1>\n<p><a href=\"https://portswigger.net/web-security/request-smuggling\">PortSwigger_HTTP request smuggling</a></p>\n<p><a href=\"https://www.freebuf.com/column/221488.html\">HTTP 走私漏洞分析</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzAwMzYxNzc1OA==&amp;mid=2247486547&amp;idx=1&amp;sn=de1f1390b6526eb2e45a0e05c4fd444d&amp;chksm=9b392ae2ac4ea3f4fbc01e19a9494a2d8fec4b20fae5e93041cfc6f874f7eebff14d5420c499&amp;mpshare=1&amp;scene=23&amp;srcid=0824Nx28uGiuA86YDMRjhkR0&amp;sharer_sharetime=1598277825562&amp;sharer_shareid=ff83fe2fe7db7fcd8a1fcbc183d841c4#rd\">由一次渗透测试引发的 HTTP 请求走私思考 (牛的)</a></p>\n<p>Copyright ©milkii0</p>\n",
            "tags": [
                "web,HTTP"
            ]
        }
    ]
}